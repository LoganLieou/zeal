const V2_VERSION = "2.2.9"

const HEADER = `
> Details about my setup and related raw data follow the tables. Other notes:
> - I show both estimated median ("Med.") and 99th percentile ("P99") since those are what best predict end user experience.
> - "v2" refers to v${V2_VERSION}, while "v3" refers to the code in this PR.
`.trim()

const SETUP_INFO = `
Browser info:

- Chromium-based: (from \`about:version\`)
  - Brave: 1.71.114 Chromium: 130.0.6723.58 (Official Build) (64-bit)
  - Revision: 89c4031c685a4296315a6f421f46275f0b72dd55
  - OS: Windows 10 Version 22H2 (Build 19045.4894)
  - JavaScript: V8 13.0.245.16

  This was run in a private window, with only the following two extensions:

  - Tampermonkey (ID: dhdgffkkebhmkfjojejmpbldmpobfkfo)
    - No userscripts installed
  - Rearrange Tabs (ID: ccnnhhnmpoffieppjjkhdakcoejcpbga)

- Gecko-based: (from \`about:support\`)
  - Name: Firefox
  - Version: 132.0
  - Build ID: 20241021175835 (commit: https://hg.mozilla.org/releases/mozilla-release/rev/0e15e2edd460163e40ac3ca3cb29ff48cfbc3967)

  Only extension active is uBlock Origin v1.60.0.

I did 5 runs each in a private window, shared across all runs but in different tabs. Each run was done one at a time.
`.trim()

const prefixes = [
	"do nothing",
	"route",
	"path",
	"construct",
	"render",
	"add/remove",
	"mount",
	"redraw",
]

const NULL_TEST_NAME = "*** null test ***"
const NULL_TEST_REPLACEMENT = "do nothing"

const headers = ["Benchmark", "Med. v2", "Med. v3", "Change", "P99 v2", "P99 v3", "Change"]

/** @param {[string, ...unknown[]]} value */
function prefixKey({0: value}) {
	const index = prefixes.findIndex((prefix) => value.startsWith(prefix))
	if (index < 0) throw new TypeError(`No prefix found for ${JSON.stringify(value)}`)
	return index
}

/** @param {[string, ...unknown[]]} a @param {[string, ...unknown[]]} b */
function prefixComparator(a, b) {
	return prefixKey(a) - prefixKey(b)
}

export class BrowserTableList {
	/**
	 *
	 * @param {string[]} raw
	 * @param {Map<string, import("./parse.js").Test[]>} tests
	 */
	constructor(raw, tests) {
		this.raw = raw
		this.tests = tests
	}
}

/** @param {string[][]} rows */
function getColSizes(rows) {
	return Uint32Array.from(headers, (header, i) => {
		let size = header.length
		for (const row of rows) {
			const found = row[i].length
			if (size < found) size = found
		}
		return size
	})
}

/** @param {string[]} row @param {Uint32Array} colSizes */
function renderRow(row, colSizes, biasRight) {
	return row.map((cell, i) => {
		const padSize = colSizes[i] - cell.length
		if (i === 0) {
			// Benchmark name is left-aligned
			return `${cell}${" ".repeat(padSize)}`
		} else {
			// Other columns are center-aligned
			let padLeft = Math.floor(padSize / 2)
			let padRight = Math.ceil(padSize / 2)
			if (biasRight) [padLeft, padRight] = [padRight, padLeft]
			return `${" ".repeat(padLeft)}${cell}${" ".repeat(padRight)}`
		}
	}).join(" | ")
}

/** @param {number} change @param {boolean} alwaysSigned */
function roundDisplay(change, alwaysSigned) {
	const sign = change < 0 ? "-" : alwaysSigned ? "+" : ""
	const abs = Math.abs(change)
	if (abs >= 99.5) return `${sign}${Math.round(abs)}`
	return `${sign}${abs.toFixed(abs < 9.95 ? 2 : 1)}`
}

/** @param {import("./parse.js").Test[]} tests */
function getHzRange(tests) {
	let pop = 0
	let maxMean = 0
	let minMean = 0
	let adjustedMedian = 0

	for (const {n, raw: {median, confidenceInterval}} of tests) {
		pop += n
		minMean += confidenceInterval.min.hz * n
		maxMean += confidenceInterval.max.hz * n
		adjustedMedian += median.hz * n
	}

	maxMean /= pop
	minMean /= pop
	adjustedMedian /= pop

	if (maxMean < minMean) {
		[minMean, maxMean] = [maxMean, minMean]
	}

	return {min: minMean, max: maxMean, median: adjustedMedian}
}

function getDeltaPercent(from, to) {
	return (to - from) / (from * 0.01)
}

/** @param {BrowserTableList} v2 @param {BrowserTableList} v3 */
function renderTable(v2, v3) {
	/** @type {string[][]} */
	const rows = []

	for (const [name, v2Tests] of v2.tests) {
		const v3Tests = v3.tests.get(name)
		if (v3Tests === undefined) {
			continue
		}

		const from = getHzRange(v2Tests)
		const to = getHzRange(v3Tests)

		rows.push([
			name === NULL_TEST_NAME ? NULL_TEST_REPLACEMENT : name,
			`${roundDisplay(from.median, false)}`,
			`${roundDisplay(to.median, false)}`,
			name === NULL_TEST_NAME ? "" : `${roundDisplay(getDeltaPercent(from.median, to.median), true)}%`,
			`${roundDisplay(from.min, false)}`,
			`${roundDisplay(to.min, false)}`,
			name === NULL_TEST_NAME ? "" : `${roundDisplay(getDeltaPercent(from.min, to.min), true)}%`,
		])
	}

	rows.sort(prefixComparator)

	const colSizes = getColSizes(rows)

	return `| ${
		renderRow(headers, colSizes, false)
	} |\n| ${
		Array.from(colSizes, (size, i) => `:${"-".repeat(size - 2)}${i ? ":" : "-"}`).join(" | ")
	} |\n${
		rows.map((row) => `| ${renderRow(row, colSizes, true)} |`).join("\n")
	}`
}

// This is also the render order I'm going with.
export const browserPrettyNames = [
	["chrome", "Chromium (Blink)"],
	["firefox", "Firefox (Gecko)"],
]

/** @param {Map<string, BrowserTableList>} map */
function renderRaw(map) {
	let result = ""

	for (const [name, pretty] of browserPrettyNames) {
		const list = map.get(name)
		for (const [i, raw] of list.raw.entries()) {
			result = `${result}\n\n**${pretty}, run ${i + 1}:**\n\n\`\`\`\n${raw}\n\`\`\``
		}
	}

	return result
}

/**
 * @param {Map<string, BrowserTableList>} v2
 * @param {Map<string, BrowserTableList>} v3
 */
export function renderTables(v2, v3) {
	let result = HEADER

	for (const [name, pretty] of browserPrettyNames) {
		const v2List = v2.get(name)
		const v3List = v3.get(name)
		// Catch potential mistakes.
		if (!v2List) throw new ReferenceError(`v2 missing browser: ${name}`)
		if (!v3List) throw new ReferenceError(`v3 missing browser: ${name}`)
		result = `${result}\n\n**${pretty}:**\n\n${renderTable(v2List, v3List)}`
	}

	return `${result}

${SETUP_INFO}

Raw output for v${V2_VERSION} benchmarks (ported from this PR's):${renderRaw(v2)}

Raw output for benchmarks for this PR:${renderRaw(v3)}`
}
