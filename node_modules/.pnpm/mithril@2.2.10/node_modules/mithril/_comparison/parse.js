import * as path from "node:path"
import {fileURLToPath} from "node:url"

export const dirname = path.dirname(fileURLToPath(import.meta.url))

export const formatWithSeparators = new Intl.NumberFormat("en-US", {useGrouping: true}).format

export class Time {
	/** @type {number} */ rate = 0
	/** @type {string} */ unit = ""

	serialize() {
		return `${this.rate} ${this.unit}`
	}
}

export class Rate {
	/** @type {number} */ rate = 0
	/** @type {string} */ unit = ""
	/** @type {number} */ hz = 0

	serialize() {
		return `${this.rate} ${this.unit} (${formatWithSeparators(this.hz)} Hz)`
	}
}

export class RateRange {
	min = new Rate()
	max = this.min

	serialize() {
		return this.min === this.max
			? this.min.serialize()
			: `${this.min.serialize()} to ${this.max.serialize()}`
	}
}

export class Resolution {
	min = new Rate()
	max = new Rate()
	median = new Rate()
	assumed = new Rate()
}

export class Stats {
	mean = new Rate()
	median = new Rate()
	expected = new RateRange()
	range = new RateRange()
	confidenceInterval = new RateRange()
}

export class Test {
	n = 0
	population = 0
	raw = new Stats()
	/** @type {undefined | Stats} */ nullAdjusted = undefined
	marginOfError = new Time()
}

export class Table {
	timerResolution = new Resolution()
	/** @type {undefined | Resolution} */ frameInterval = undefined
	minConfidenceLevel = 0
	minSamplesPerTest = 0
	minDurationPerTest = new Time()
	maxDurationPerTest = new Time()
	minDurationPerPass = new Time()
	/** @type {Map<string, Test>} */ tests = new Map()
}

/** @param {string} hz */
function parseHz(hz) {
	if (hz === "âˆž") return Infinity
	return Number.parseInt(hz.replace(/\D+/g, ""), 10)
}

/** @returns {never} */
function unexpectedEOF(name) {
	throw new Error(`${name}: Unexpected end of file`)
}

/** @returns {never} */
function lineNotMatched(name, line) {
	throw new Error(`${name}: Line not matched: ${JSON.stringify(line)}`)
}

/**
 * @param {string} name
 * @param {Resolution} resolution
 * @param {string} line
 */
function parseResolutionPart(name, resolution, line) {
	const result = (/^- ([^:]+): ([+-]?\d+(?:\.\d+)?) (\S+) \((\S+) Hz\)/).exec(line)

	if (result === null) {
		lineNotMatched(name, line)
	}

	let rate

	switch (result[1]) {
		case "min": rate = resolution.min; break
		case "max": rate = resolution.max; break
		case "median": rate = resolution.median; break
		case "assumed": rate = resolution.assumed; break
		default: lineNotMatched(name, line)
	}

	rate.rate = Number(result[2])
	rate.unit = result[3]
	rate.hz = parseHz(result[4])
}

/**
 * @param {string} name
 * @param {Table} table
 * @param {string} line
 */
function parseConfigPart(name, table, line) {
	const result = (/^- ([^:]+): ([+-]?\d+(?:\.\d+)?)(?: (\S+))?/).exec(line)

	if (result === null) {
		return false
	}

	const duration = Number(result[2])
	const unit = result[3]

	switch (result[1]) {
		case "min confidence level":
			table.minConfidenceLevel = duration
			break
		case "min samples/test":
			table.minSamplesPerTest = duration
			break
		case "min duration/test":
			table.minDurationPerTest.rate = duration
			table.minDurationPerTest.unit = unit
			break
		case "max duration/test":
			table.maxDurationPerTest.rate = duration
			table.maxDurationPerTest.unit = unit
			break
		case "min duration/pass":
			table.minDurationPerPass.rate = duration
			table.minDurationPerPass.unit = unit
			break
		default:
			lineNotMatched(name, line)
	}

	return true
}

/**
 * @param {string} name
 * @param {Rate} rate
 * @param {RegExpExecArray} result
 * @param {number} offset
 * @param {string} line
 */
function fillRate(name, rate, result, offset, line) {
	if (result[offset] === undefined) lineNotMatched(name, line)
	rate.rate = Number(result[offset])
	rate.unit = result[offset + 1]
	rate.hz = parseHz(result[offset + 2])
}

/**
 * @param {string} name
 * @param {RateRange} range
 * @param {RegExpExecArray} result
 * @param {string} line
 */
function fillRateRange(name, range, result, line) {
	fillRate(name, range.min, result, 2, line)
	if (result[5] !== undefined) {
		fillRate(name, range.max = new Rate(), result, 5, line)
	}
}

/**
 * @param {string} name
 * @param {Test} test
 * @param {string} line
 */
function parseTestPart(name, test, line) {
	const result = (/^- ([^:]+): ([+-]?\d+(?:\.\d+)?)(?: (\S+)(?: \((\S+) Hz\)(?: to ([+-]?\d+(?:\.\d+)?) (\S+) \((\S+) Hz\))?)?)?/).exec(line)

	if (result === null) {
		return false
	}

	switch (result[1]) {
		case "MOE":
			if (result[3] === undefined) {
				lineNotMatched(name, line)
			}
			test.marginOfError.rate = Number(result[2])
			test.marginOfError.unit = result[3]
			break
		case "N": test.n = Number(result[2]); break
		case "pop": test.population = Number(result[2]); break
		case "mean": fillRate(name, test.raw.mean, result, 2, line); break
		case "median": fillRate(name, test.raw.median, result, 2, line); break
		case "expected": fillRateRange(name, test.raw.expected, result, line); break
		case "range": fillRateRange(name, test.raw.range, result, line); break
		case "CI": fillRateRange(name, test.raw.confidenceInterval, result, line); break
		case "null-adjusted mean": fillRate(name, (test.nullAdjusted ??= new Stats()).mean, result, 2, line); break
		case "null-adjusted median": fillRate(name, (test.nullAdjusted ??= new Stats()).median, result, 2, line); break
		case "null-adjusted expected": fillRateRange(name, (test.nullAdjusted ??= new Stats()).expected, result, line); break
		case "null-adjusted range": fillRateRange(name, (test.nullAdjusted ??= new Stats()).range, result, line); break
		case "null-adjusted CI": fillRateRange(name, (test.nullAdjusted ??= new Stats()).confidenceInterval, result, line); break
		default: lineNotMatched(name, line)
	}

	return true
}

/** @param {string} source @param {string} name */
export function parseText(source, name) {
	// Regexp also drops the `bench.js:NNN` prefix that some lines have (but not all).
	const lines = source.split(/[^\r\n\S]*\r?\n[^\r\n\S]*/g)
	let i = 0

	for (;;) {
		if (i === lines.length) unexpectedEOF(name)
		if (lines[i++].startsWith("Timer resolution")) break
	}

	const table = new Table()
	/** @type {string} */let line

	parseTestRecords: {
		for (;;) {
			if (i === lines.length) unexpectedEOF(name)
			line = lines[i++]
			if (line.startsWith("Tests warmed up")) break parseTestRecords
			if (line.startsWith("Frame interval")) break
			parseResolutionPart(name, table.timerResolution, line)
		}

		for (;;) {
			if (i === lines.length) unexpectedEOF(name)
			line = lines[i++]
			if (line.startsWith("Tests warmed up")) break
			parseResolutionPart(name, table.frameInterval = new Resolution(), line)
		}
	}

	for (;;) {
		if (i === lines.length) unexpectedEOF(name)
		// Don't increment. I want to reconsume the line after this
		if (!parseConfigPart(name, table, lines[i])) break
		i++
	}

	outer:
	while (i !== lines.length) {
		line = lines[i++]
		if (line.startsWith("Benchmark run completed")) break
		const result = (/^\[([^\]]*)\]:/).exec(line)
		if (result === null) continue

		const testName = result[1]
		const test = new Test()

		while (i !== lines.length) {
			line = lines[i++]
			if (line.startsWith("Benchmark run completed")) break outer
			if (!parseTestPart(name, test, line)) {
				i--
				break
			}
		}

		table.tests.set(testName, test)
	}

	return table
}
