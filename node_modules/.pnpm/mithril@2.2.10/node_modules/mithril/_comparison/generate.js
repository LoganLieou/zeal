import * as fs from "node:fs"
import * as path from "node:path"

import {BrowserTableList, browserPrettyNames, renderTables} from "./render.js"
import {dirname, parseText} from "./parse.js"

/** @type {Map<string, BrowserTableList>} */ const v2 = new Map()
/** @type {Map<string, BrowserTableList>} */ const v3 = new Map()

let tablesPending = 0

function renderIfReady() {
	if (--tablesPending === 0) {
		const output = renderTables(v2, v3)
		console.log(output)
	}
}

function compareSourceByName(a, b) {
	if (a.name > b.name) return 1
	if (a.name < b.name) return -1
	return 0
}

/**
 * @param {Map<string, import("./parse.js").Test[]>} tests
 * @param {Array<{name: string, raw: string}>} sources
 * @param {string} sourceName
 * @param {string} fileName
 * @param {string} raw
 */
function parseAndPush(tests, sources, sourceName, fileName, raw) {
	raw = raw
		.replace(/bench\.js:\d+(?::\d+)?/g, "")
		.replace(/Sample CSVs[\s\S]*$/g, "")
		.replace(/^[^\r\n\S]+|[^\r\n\S]+$/gm, "")
		.trim()
	const table = parseText(raw, sourceName)

	for (const [testName, test] of table.tests) {
		const list = tests.get(testName)
		if (list !== undefined) {
			list.push(test)
		} else {
			tests.set(testName, [test])
		}
	}

	sources.push({name: fileName, raw})
}

/**
 * @param {string} version
 * @param {string} name
 * @param {Map<string, BrowserTableList>} table
 * @param {string[]} files
 */
function readTableFromList(version, name, table, files) {
	/** @type {Map<string, import("./parse.js").Test[]>} */
	const tests = new Map()
	/** @type {Array<{name: string, raw: string}>} */
	const sources = []
	let pending = files.length

	const settle = () => {
		if (--pending === 0) {
			sources.sort(compareSourceByName)
			table.set(name, new BrowserTableList(sources.map((r) => r.raw), tests))
			renderIfReady()
		}
	}

	for (const fileName of files) {
		fs.readFile(path.join(dirname, name, version, fileName), "utf-8", (err, raw) => {
			if (err) {
				if (err.code !== "ENOENT") throw err
			} else {
				parseAndPush(tests, sources, path.posix.join(name, version, fileName), fileName, raw)
			}
			settle()
		})
	}
}

/**
 * @param {string} version
 * @param {string} name
 * @param {Map<string, BrowserTableList>} table
 */
function fetchTable(version, name, table) {
	tablesPending++
	fs.readdir(path.join(dirname, name, version), (err, files) => {
		if (err) {
			if (err.code !== "ENOENT") throw err
			console.error(`Skipping missing browser path: ${name}/${version}`)
			renderIfReady()
		} else {
			readTableFromList(version, name, table, files)
		}
	})
}

for (const {0: name} of browserPrettyNames) {
	fetchTable("v2", name, v2)
	fetchTable("v3", name, v3)
}

if (tablesPending === 0) {
	throw new Error("No tables being fetched.")
}
