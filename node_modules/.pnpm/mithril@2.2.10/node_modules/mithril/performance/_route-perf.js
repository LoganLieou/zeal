import m from "../dist/mithril.esm.min.js"

import {setupBenchmarks} from "./bench.js"

import {numVars, routes, stringVars, templates} from "./routes.js"

const routeObjects = routes.map((path) => ({path, params: new URLSearchParams()}))

let i = 0

setupBenchmarks(() => {}, () => {}, {
	// This just needs to be sub-millisecond
	"route match": {
		fn() {
			// eslint-disable-next-line no-bitwise
			i = (i - 1) & 255
			return m.match(routeObjects[i], templates[i])
		},
	},

	// These four need to be at most a few microseconds, as 300 of these * 3 us/op = 0.9 ms. (And yes,
	// while 300 may seem like a lot, I've worked with apps that exceeded 100, and for 60 FPS, you only
	// truly have room for about 5ms total for logic.)

	"route non-match": {
		fn() {
			const j = i
			// eslint-disable-next-line no-bitwise
			i = (i - 1) & 255
			return m.match(routeObjects[i], templates[j])
		},
	},

	"path generate with string interpolations": {
		fn() {
			// eslint-disable-next-line no-bitwise
			i = (i - 1) & 255
			return m.p(templates[i], stringVars[i])
		},
	},

	"path generate with number interpolations": {
		fn() {
			// eslint-disable-next-line no-bitwise
			i = (i - 1) & 255
			return m.p(templates[i], numVars[i])
		},
	},

	"path generate no interpolations": {
		fn() {
			// eslint-disable-next-line no-bitwise
			i = (i - 1) & 255
			return m.p(templates[i])
		},
	},
})
