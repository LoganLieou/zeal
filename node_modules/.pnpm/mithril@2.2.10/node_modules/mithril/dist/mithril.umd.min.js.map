{"version":3,"file":"mithril.umd.min.js","sources":["../src/util.js","../src/core.js","../src/std/rate-limit.js","../src/std/router.js","../src/std/path-query.js","../src/std/tracked.js","../src/std/init.js","../src/entry/mithril.esm.js","../src/std/fetch.js","../src/std/lazy.js","../src/entry/mithril.umd.js"],"sourcesContent":["export var hasOwn = {}.hasOwnProperty\n\nexport var invokeRedrawable = async (redraw, fn, thisValue, ...args) => {\n\tif (typeof fn === \"function\") {\n\t\tthisValue = Reflect.apply(fn, thisValue, args)\n\t\tif (thisValue === \"skip-redraw\") return\n\t\tif (thisValue && typeof thisValue.then === \"function\" && (await thisValue) === \"skip-redraw\") return\n\t\tredraw()\n\t}\n}\n\nexport var checkCallback = (callback, allowNull, label = \"callback\") => {\n\tif (allowNull && callback == null || typeof callback === \"function\") {\n\t\treturn callback\n\t}\n\n\tthrow new TypeError(`\\`${label}\\` must be a function${allowNull ? \" if provided.\" : \".\"}`)\n}\n\nexport var noop = () => {}\n","/* eslint-disable no-bitwise */\nimport {checkCallback, hasOwn, invokeRedrawable, noop} from \"./util.js\"\n\nexport {m as default}\n\n/*\nCaution: be sure to check the minified output. I've noticed an issue with Terser trying to inline\nsingle-use functions as IIFEs, and this predictably causes perf issues since engines don't seem to\nreliably lower this in either their bytecode generation *or* their optimized code.\n\nRather than painfully trying to reduce that to an MVC and filing a bug against it, I'm just\ninlining and commenting everything. It also gives me a better idea of the true cost of various\nfunctions.\n\nIn `m`, I do use a no-inline hints (the `__NOINLINE__` in an inline block comment there) to\nprevent Terser from inlining a cold function in a very hot code path, to try to squeeze a little\nmore performance out of the framework. Likewise, to try to preserve this through build scripts,\nTerser annotations are preserved in the ESM production bundle (but not the UMD bundle).\n\nAlso, be aware: I use some bit operations here. Nothing super fancy like find-first-set, just\nmainly ANDs, ORs, and a one-off XOR for inequality.\n*/\n\n/*\nState note:\n\nIf remove on throw is `true` and an error occurs:\n- All visited vnodes' new versions are removed.\n- All unvisited vnodes' old versions are removed.\n\nIf remove on throw is `false` and an error occurs:\n- Attribute modification errors are logged.\n- Views that throw retain the previous version and log their error.\n- Errors other than the above cause the tree to be torn down as if remove on throw was `true`.\n*/\n\n/*\nThis same structure is used for several nodes. Here's an explainer for each type.\n\nRetain:\n- `m`: `-1`\n- All other properties are unused\n- On ingest, the vnode itself is converted into the type of the element it's retaining. This\n  includes changing its type.\n\nFragments:\n- `m` bits 0-3: `0`\n- `t`: unused\n- `s`: unused\n- `a`: unused\n- `c`: virtual DOM children\n- `d`: unused\n\nKeyed:\n- `m` bits 0-3: `1`\n- `t`: unused\n- `s`: unused\n- `a`: key to child map, also holds children\n- `c`: unused\n- `d`: unused\n\nText:\n- `m` bits 0-3: `2`\n- `t`: unused\n- `s`: unused\n- `a`: text string\n- `c`: unused\n- `d`: abort controller reference\n\nComponents:\n- `m` bits 0-3: `3`\n- `t`: component reference\n- `s`: view function, may be same as component reference\n- `a`: most recently received attributes\n- `c`: instance vnode\n- `d`: unused\n\nDOM elements:\n- `m` bits 0-3: `4`\n- `t`: tag name string\n- `s`: event listener dictionary, if any events were ever registered\n- `a`: most recently received attributes\n- `c`: virtual DOM children\n- `d`: element reference\n\nLayout:\n- `m` bits 0-3: `5`\n- `t`: unused\n- `s`: uncaught\n- `a`: callback to schedule\n- `c`: unused\n- `d`: parent DOM reference, for easier queueing\n\nRemove:\n- `m` bits 0-3: `6`\n- `t`: unused\n- `s`: unused\n- `a`: callback to schedule\n- `c`: unused\n- `d`: parent DOM reference, for easier queueing\n\nSet context:\n- `m` bits 0-3: `7`\n- `t`: unused\n- `s`: unused\n- `a`: unused\n- `c`: virtual DOM children\n- `d`: unused\n\nUse dependencies:\n- `m` bits 0-3: `8`\n- `t`: unused\n- `s`: unused\n- `a`: Dependency array\n- `c`: virtual DOM children\n- `d`: unused\n\nInline:\n- `m` bits 0-3: `8`\n- `t`: unused\n- `s`: unused\n- `a`: view function\n- `c`: instance vnode\n- `d`: unused\n\nThe `m` field is also used for various assertions, that aren't described here.\n*/\n\nvar TYPE_MASK = 15\nvar TYPE_RETAIN = -1\nvar TYPE_FRAGMENT = 0\nvar TYPE_KEYED = 1\nvar TYPE_TEXT = 2\nvar TYPE_ELEMENT = 3\nvar TYPE_COMPONENT = 4\nvar TYPE_LAYOUT = 5\nvar TYPE_REMOVE = 6\nvar TYPE_SET_CONTEXT = 7\nvar TYPE_USE = 8\nvar TYPE_INLINE = 9\n// var TYPE_RETAIN = 15\n\nvar FLAG_USED = 1 << 4\nvar FLAG_IS_REMOVE = 1 << 5\nvar FLAG_HTML_ELEMENT = 1 << 6\nvar FLAG_CUSTOM_ELEMENT = 1 << 7\nvar FLAG_INPUT_ELEMENT = 1 << 8\nvar FLAG_SELECT_ELEMENT = 1 << 9\nvar FLAG_OPTION_ELEMENT = 1 << 10\nvar FLAG_TEXTAREA_ELEMENT = 1 << 11\nvar FLAG_IS_FILE_INPUT = 1 << 12\n// Implicitly used as part of checking for `m.retain()`.\n// var FLAG_IS_RETAIN = 1 << 31\n\nvar Vnode = (mask, tag, attrs, children) => ({\n\tm: mask,\n\tt: tag,\n\ta: attrs,\n\tc: children,\n\ts: null,\n\td: null,\n})\n\nvar selectorParser = /(?:(^|#|\\.)([^#\\.\\[\\]]+))|(\\[(.+?)(?:\\s*=\\s*(\"|'|)((?:\\\\[\"'\\]]|.)*?)\\5)?\\])/g\nvar selectorUnescape = /\\\\([\"'\\\\])/g\nvar selectorCache = /*@__PURE__*/ new Map()\n\nvar compileSelector = (selector) => {\n\tvar match, tag = \"div\", classes = [], attrs = {}, className, hasAttrs = false\n\n\twhile (match = selectorParser.exec(selector)) {\n\t\tvar type = match[1], value = match[2]\n\t\tif (type === \"\" && value !== \"\") {\n\t\t\ttag = value\n\t\t} else {\n\t\t\thasAttrs = true\n\t\t\tif (type === \"#\") {\n\t\t\t\tattrs.id = value\n\t\t\t} else if (type === \".\") {\n\t\t\t\tclasses.push(value)\n\t\t\t} else if (match[3][0] === \"[\") {\n\t\t\t\tvar attrValue = match[6]\n\t\t\t\tif (attrValue) attrValue = attrValue.replace(selectorUnescape, \"$1\")\n\t\t\t\tif (match[4] === \"class\" || match[4] === \"className\") classes.push(attrValue)\n\t\t\t\telse attrs[match[4]] = attrValue == null || attrValue\n\t\t\t}\n\t\t}\n\t}\n\n\tif (classes.length > 0) {\n\t\tclassName = classes.join(\" \")\n\t}\n\n\tvar state = {t: tag, a: hasAttrs ? attrs : null, c: className}\n\tselectorCache.set(selector, state)\n\treturn state\n}\n\n/*\nEdit this with caution and profile every change you make. This comprises about 4% of the total\nruntime overhead in benchmarks, and any reduction in performance here will immediately be felt.\n\nAlso, it's specially designed to only allocate the bare minimum it needs to build vnodes, as part\nof this optimization process. It doesn't allocate arguments except as needed to build children, it\ndoesn't allocate attributes except to replace them for modifications, among other things.\n*/\nvar m = function (selector, attrs) {\n\tvar type = TYPE_ELEMENT\n\tvar start = 1\n\tvar children\n\n\tif (typeof selector !== \"string\") {\n\t\tif (typeof selector !== \"function\") {\n\t\t\tthrow new Error(\"The selector must be either a string or a component.\");\n\t\t}\n\t\ttype = selector === m.Fragment ? TYPE_FRAGMENT : TYPE_COMPONENT\n\t}\n\n\n\tif (attrs == null || typeof attrs === \"object\" && typeof attrs.m !== \"number\" && !Array.isArray(attrs)) {\n\t\tstart = 2\n\t\tif (arguments.length < 3 && attrs && Array.isArray(attrs.children)) {\n\t\t\tchildren = attrs.children.slice()\n\t\t}\n\t} else {\n\t\tattrs = null\n\t}\n\n\tif (children == null) {\n\t\tif (arguments.length === start + 1 && Array.isArray(arguments[start])) {\n\t\t\tchildren = arguments[start].slice()\n\t\t} else {\n\t\t\tchildren = []\n\t\t\twhile (start < arguments.length) children.push(arguments[start++])\n\t\t}\n\t}\n\n\t// It may seem expensive to inline elements handling, but it's less expensive than you'd think.\n\t// DOM nodes are about as commonly constructed as vnodes, but fragments are only constructed\n\t// from JSX code (and even then, they aren't common).\n\n\tif (type === TYPE_ELEMENT) {\n\t\tattrs = attrs || {}\n\t\tvar hasClassName = hasOwn.call(attrs, \"className\")\n\t\tvar dynamicClass = hasClassName ? attrs.className : attrs.class\n\t\tvar state = selectorCache.get(selector)\n\t\tvar original = attrs\n\n\t\tif (state == null) {\n\t\t\tstate = /*@__NOINLINE__*/compileSelector(selector)\n\t\t}\n\n\t\tif (state.a != null) {\n\t\t\tattrs = {...state.a, ...attrs}\n\t\t}\n\n\t\tif (dynamicClass != null || state.c != null) {\n\t\t\tif (attrs !== original) attrs = {...attrs}\n\t\t\tattrs.class = dynamicClass != null\n\t\t\t\t? state.c != null ? `${state.c} ${dynamicClass}` : dynamicClass\n\t\t\t\t: state.c\n\t\t\tif (hasClassName) attrs.className = null\n\t\t}\n\t}\n\n\tif (type === TYPE_COMPONENT) {\n\t\tattrs = {children, ...attrs}\n\t\tchildren = null\n\t} else {\n\t\tfor (var i = 0; i < children.length; i++) children[i] = m.normalize(children[i])\n\t}\n\n\treturn Vnode(type, selector, attrs, children)\n}\n\nm.TYPE_MASK = TYPE_MASK\nm.TYPE_RETAIN = TYPE_RETAIN\nm.TYPE_FRAGMENT = TYPE_FRAGMENT\nm.TYPE_KEYED = TYPE_KEYED\nm.TYPE_TEXT = TYPE_TEXT\nm.TYPE_ELEMENT = TYPE_ELEMENT\nm.TYPE_COMPONENT = TYPE_COMPONENT\nm.TYPE_LAYOUT = TYPE_LAYOUT\nm.TYPE_REMOVE = TYPE_REMOVE\nm.TYPE_SET_CONTEXT = TYPE_SET_CONTEXT\nm.TYPE_USE = TYPE_USE\nm.TYPE_INLINE = TYPE_INLINE\n\n// Simple and sweet. Also useful for idioms like `onfoo: m.capture` to completely drop events while\n// otherwise ignoring them.\nm.capture = (ev) => {\n\tev.preventDefault()\n\tev.stopPropagation()\n\treturn \"skip-redraw\"\n}\n\nm.retain = () => Vnode(TYPE_RETAIN, null, null, null)\nm.inline = (view) => Vnode(TYPE_INLINE, null, checkCallback(view, false, \"view\"), null)\nm.layout = (callback) => Vnode(TYPE_LAYOUT, null, checkCallback(callback), null)\nm.remove = (callback) => Vnode(TYPE_REMOVE, null, checkCallback(callback), null)\n\nm.Fragment = (attrs) => attrs.children\n\nm.keyed = (values, view) => {\n\tview = checkCallback(view, true, \"view\")\n\tvar map = new Map()\n\tfor (var value of values) {\n\t\tif (typeof view === \"function\") value = view(value)\n\t\tif (value != null && typeof value !== \"boolean\") {\n\t\t\tif (!Array.isArray(value) || value.length < 1) {\n\t\t\t\tthrow new TypeError(\"Returned value must be a `[key, value]` array\")\n\t\t\t}\n\t\t\tif (map.has(value[0])) {\n\t\t\t\t// Coerce to string so symbols don't throw\n\t\t\t\tthrow new TypeError(`Duplicate key detected: ${String(value[0])}`)\n\t\t\t}\n\t\t\tmap.set(value[0], m.normalize(value[1]))\n\t\t}\n\t}\n\treturn Vnode(TYPE_KEYED, null, map, null)\n}\n\nm.set = (entries, ...children) => resolveSpecialFragment(TYPE_SET_CONTEXT, entries, ...children)\nm.use = (deps, ...children) => resolveSpecialFragment(TYPE_USE, [...deps], ...children)\n\nm.normalize = (node) => {\n\tif (node == null || typeof node === \"boolean\") return null\n\tif (typeof node !== \"object\") return Vnode(TYPE_TEXT, null, String(node), null)\n\tif (Array.isArray(node)) return Vnode(TYPE_FRAGMENT, null, null, node.map(m.normalize))\n\treturn node\n}\n\nvar resolveSpecialFragment = (type, attrs, ...children) => {\n\tvar resolved = children.length === 1 && Array.isArray(children[0]) ? [...children[0]] : [...children]\n\tfor (var i = 0; i < resolved.length; i++) resolved[i] = m.normalize(resolved[i])\n\treturn Vnode(type, null, attrs, resolved)\n}\n\nvar xlinkNs = \"http://www.w3.org/1999/xlink\"\nvar htmlNs = \"http://www.w3.org/1999/xhtml\"\nvar nameSpace = {\n\tsvg: \"http://www.w3.org/2000/svg\",\n\tmath: \"http://www.w3.org/1998/Math/MathML\"\n}\n\nvar currentHooks\nvar currentRedraw\nvar currentParent\nvar currentRefNode\nvar currentNamespace\nvar currentDocument\nvar currentContext\nvar currentRemoveOnThrow\n\nvar insertAfterCurrentRefNode = (child) => {\n\tif (currentRefNode) {\n\t\tcurrentRefNode.after(currentRefNode = child)\n\t} else {\n\t\tcurrentParent.prepend(currentRefNode = child)\n\t}\n}\n\n//update\nvar moveToPosition = (vnode) => {\n\tvar type\n\twhile ((1 << TYPE_COMPONENT | 1 << TYPE_INLINE) & 1 << (type = vnode.m & TYPE_MASK)) {\n\t\tif (!(vnode = vnode.c)) return\n\t}\n\tif ((1 << TYPE_FRAGMENT | 1 << TYPE_USE | 1 << TYPE_SET_CONTEXT) & 1 << type) {\n\t\tvnode.c.forEach(moveToPosition)\n\t} else if ((1 << TYPE_TEXT | 1 << TYPE_ELEMENT) & 1 << type) {\n\t\tinsertAfterCurrentRefNode(vnode.d)\n\t} else if (type === TYPE_KEYED) {\n\t\tvnode.a.forEach(moveToPosition)\n\t}\n}\n\nvar updateFragment = (old, vnode) => {\n\t// Patch the common prefix, remove the extra in the old, and create the extra in the new.\n\t//\n\t// Can't just take the max of both, because out-of-bounds accesses both disrupts\n\t// optimizations and is just generally slower.\n\t//\n\t// Note: if either `vnode` or `old` is `null`, the common length and its own length are\n\t// both zero, so it can't actually throw.\n\tvar newLength = vnode != null ? vnode.c.length : 0\n\tvar oldLength = old != null ? old.c.length : 0\n\tvar commonLength = oldLength < newLength ? oldLength : newLength\n\ttry {\n\t\tfor (var i = 0; i < commonLength; i++) updateNode(old.c[i], vnode.c[i])\n\t\tfor (var i = commonLength; i < newLength; i++) updateNode(null, vnode.c[i])\n\t} catch (e) {\n\t\tcommonLength = i\n\t\tfor (var i = 0; i < commonLength; i++) updateNode(vnode.c[i], null)\n\t\tfor (var i = commonLength; i < oldLength; i++) updateNode(old.c[i], null)\n\t\tthrow e\n\t}\n\tfor (var i = commonLength; i < oldLength; i++) updateNode(old.c[i], null)\n}\n\nvar updateUse = (old, vnode) => {\n\tif (\n\t\told != null && old.length !== 0 &&\n\t\tvnode != null && vnode.length !== 0 &&\n\t\t(\n\t\t\tvnode.a.length !== old.a.length ||\n\t\t\tvnode.a.some((b, i) => !Object.is(b, old.a[i]))\n\t\t)\n\t) {\n\t\tupdateFragment(old, null)\n\t\told = null\n\t}\n\tupdateFragment(old, vnode)\n}\n\nvar updateKeyed = (old, vnode) => {\n\t// I take a pretty straightforward approach here to keep it simple:\n\t// 1. Build a map from old map to old vnode.\n\t// 2. Walk the new vnodes, adding what's missing and patching what's in the old.\n\t// 3. Remove from the old map the keys in the new vnodes, leaving only the keys that\n\t//    were removed this run.\n\t// 4. Remove the remaining nodes in the old map that aren't in the new map. Since the\n\t//    new keys were already deleted, this is just a simple map iteration.\n\n\t// Note: if either `vnode` or `old` is `null`, they won't get here. The default mask is\n\t// zero, and that causes keyed state to differ and thus a forced linear diff per above.\n\n\tvar added = 0\n\t// It's a value that 1. isn't user-providable and 2. isn't likely to go away in future changes.\n\t// Works well enough as a sentinel.\n\tvar error = selectorCache\n\ttry {\n\t\t// Iterate the map. I get keys for free that way, and insertion order is guaranteed to be\n\t\t// preserved in any spec-conformant engine.\n\t\tvnode.a.forEach((n, k) => {\n\t\t\tvar p = old != null ? old.a.get(k) : null\n\t\t\tif (p == null) {\n\t\t\t\tupdateNode(null, n)\n\t\t\t} else {\n\t\t\t\tvar prev = currentRefNode\n\t\t\t\tmoveToPosition(p)\n\t\t\t\tcurrentRefNode = prev\n\t\t\t\tupdateNode(p, n)\n\t\t\t\t// Delete from the state set, but only after it's been successfully moved. This\n\t\t\t\t// avoids needing to specially remove `p` on failure.\n\t\t\t\told.a.delete(k)\n\t\t\t}\n\t\t\tadded++\n\t\t})\n\t\tadded = -1\n\t} catch (e) {\n\t\terror = e\n\t}\n\tif (old != null) removeKeyed(old)\n\t// Either `added === 0` from the `catch` block or `added === -1` from completing the loop.\n\tif (error !== selectorCache) {\n\t\tfor (var n of vnode.a.values()) {\n\t\t\tif (--added) break\n\t\t\tupdateNode(n, null)\n\t\t}\n\t\tthrow error\n\t}\n}\n\nvar updateNode = (old, vnode) => {\n\t// This is important. Declarative state bindings that rely on dependency tracking, like\n\t// https://github.com/tc39/proposal-signals and related, memoize their results, but that's the\n\t// absolute extent of what they necessarily reuse. They don't pool anything. That means all I\n\t// need to do to support components based on them is just add this neat single line of code\n\t// here.\n\t//\n\t// Code based on streams (see this repo here) will also potentially need this depending on how\n\t// they do their combinators.\n\tif (old === vnode) return\n\n\tvar type\n\tif (old == null) {\n\t\tif (vnode == null) return\n\t\tif (vnode.m < 0) return\n\t\tif (vnode.m & FLAG_USED) {\n\t\t\tthrow new TypeError(\"Vnodes must not be reused\")\n\t\t}\n\t\ttype = vnode.m & TYPE_MASK\n\t\tvnode.m |= FLAG_USED\n\t} else {\n\t\ttype = old.m & TYPE_MASK\n\n\t\tif (vnode == null) {\n\t\t\ttry {\n\t\t\t\tif (type !== (TYPE_RETAIN & TYPE_MASK)) removeNodeDispatch[type](old)\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(e)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tif (vnode.m < 0) {\n\t\t\t// If it's a retain node, transmute it into the node it's retaining. Makes it much easier\n\t\t\t// to implement and work with.\n\t\t\t//\n\t\t\t// Note: this key list *must* be complete.\n\t\t\tvnode.m = old.m\n\t\t\tvnode.t = old.t\n\t\t\tvnode.s = old.s\n\t\t\tvnode.a = old.a\n\t\t\tvnode.c = old.c\n\t\t\tvnode.d = old.d\n\t\t\treturn\n\t\t}\n\n\t\tif (vnode.m & FLAG_USED) {\n\t\t\tthrow new TypeError(\"Vnodes must not be reused\")\n\t\t}\n\n\t\tif (type === (vnode.m & TYPE_MASK) && vnode.t === old.t) {\n\t\t\tvnode.m = old.m\n\t\t} else {\n\t\t\tupdateNode(old, null)\n\t\t\told = null\n\t\t}\n\t\ttype = vnode.m & TYPE_MASK\n\t}\n\n\ttry {\n\t\tupdateNodeDispatch[type](old, vnode)\n\t} catch (e) {\n\t\tupdateNode(old, null)\n\t\tthrow e\n\t}\n}\n\nvar updateLayout = (_, vnode) => {\n\tvnode.d = currentParent\n\tcurrentHooks.push(vnode)\n}\n\nvar updateRemove = (_, vnode) => {\n\tvnode.d = currentParent\n}\n\nvar emptyObject = {}\n\nvar updateSet = (old, vnode) => {\n\tvar descs = Object.getOwnPropertyDescriptors(vnode.a)\n\tfor (var key of Reflect.ownKeys(descs)) {\n\t\t// Drop the descriptor entirely if it's not enumerable. Setting it to an empty object\n\t\t// avoids changing its shape, which is useful.\n\t\tif (!descs[key].enumerable) descs[key] = emptyObject\n\t\t// Drop the setter if one is present, to keep it read-only.\n\t\telse if (\"set\" in descs[key]) descs[key].set = undefined\n\t}\n\tvar prevContext = currentContext\n\tcurrentContext = Object.freeze(Object.create(prevContext, descs))\n\tupdateFragment(old, vnode)\n\tcurrentContext = prevContext\n}\n\nvar updateText = (old, vnode) => {\n\tif (old == null) {\n\t\tinsertAfterCurrentRefNode(vnode.d = currentDocument.createTextNode(vnode.a))\n\t} else {\n\t\tif (`${old.a}` !== `${vnode.a}`) old.d.nodeValue = vnode.a\n\t\tvnode.d = currentRefNode = old.d\n\t}\n}\n\nvar handleAttributeError = (old, e, force) => {\n\tif (currentRemoveOnThrow || force) {\n\t\tif (old) removeElement(old)\n\t\tthrow e\n\t}\n\tconsole.error(e)\n}\n\nvar updateElement = (old, vnode) => {\n\tvar prevParent = currentParent\n\tvar prevRefNode = currentRefNode\n\tvar prevNamespace = currentNamespace\n\tvar mask = vnode.m\n\tvar attrs = vnode.a\n\tvar element, oldAttrs\n\n\tif (old == null) {\n\t\tvar entry = selectorCache.get(vnode.t)\n\t\tvar tag = entry ? entry.t : vnode.t\n\t\tvar customTag = tag.includes(\"-\")\n\t\tvar is = !customTag && attrs && attrs.is\n\t\tvar ns = attrs && attrs.xmlns || nameSpace[tag] || prevNamespace\n\t\tvar opts = is ? {is} : null\n\n\t\telement = (\n\t\t\tns\n\t\t\t\t? currentDocument.createElementNS(ns, tag, opts)\n\t\t\t\t: currentDocument.createElement(tag, opts)\n\t\t)\n\n\t\tif (ns == null) {\n\t\t\t// Doing it this way since it doesn't seem Terser is smart enough to optimize the `if` with\n\t\t\t// every branch doing `a |= value` for differing `value`s to a ternary. It *is* smart\n\t\t\t// enough to inline the constants, and the following pass optimizes the rest to just\n\t\t\t// integers.\n\t\t\t//\n\t\t\t// Doing a simple constant-returning ternary also makes it easier for engines to emit the\n\t\t\t// right code.\n\t\t\t/* eslint-disable indent */\n\t\t\tvnode.m = mask |= (\n\t\t\t\tis || customTag\n\t\t\t\t\t? FLAG_HTML_ELEMENT | FLAG_CUSTOM_ELEMENT\n\t\t\t\t\t: (tag = tag.toUpperCase(), (\n\t\t\t\t\t\ttag === \"INPUT\" ? FLAG_HTML_ELEMENT | FLAG_INPUT_ELEMENT\n\t\t\t\t\t\t: tag === \"SELECT\" ? FLAG_HTML_ELEMENT | FLAG_SELECT_ELEMENT\n\t\t\t\t\t\t: tag === \"OPTION\" ? FLAG_HTML_ELEMENT | FLAG_OPTION_ELEMENT\n\t\t\t\t\t\t: tag === \"TEXTAREA\" ? FLAG_HTML_ELEMENT | FLAG_TEXTAREA_ELEMENT\n\t\t\t\t\t\t: FLAG_HTML_ELEMENT\n\t\t\t\t\t))\n\t\t\t)\n\t\t\t/* eslint-enable indent */\n\n\t\t\tif (is) element.setAttribute(\"is\", is)\n\t\t}\n\n\t\tcurrentParent = element\n\t\tcurrentNamespace = ns\n\t} else {\n\t\tvnode.s = old.s\n\t\toldAttrs = old.a\n\t\tcurrentNamespace = (currentParent = element = vnode.d = old.d).namespaceURI\n\t\tif (currentNamespace === htmlNs) currentNamespace = null\n\t}\n\n\tcurrentRefNode = null\n\n\ttry {\n\t\tif (oldAttrs != null && oldAttrs === attrs) {\n\t\t\tthrow new Error(\"Attributes object cannot be reused.\")\n\t\t}\n\n\t\tif (attrs != null) {\n\t\t\t// The DOM does things to inputs based on the value, so it needs set first.\n\t\t\t// See: https://github.com/MithrilJS/mithril.js/issues/2622\n\t\t\tif (mask & FLAG_INPUT_ELEMENT && attrs.type != null) {\n\t\t\t\tif (attrs.type === \"file\") mask |= FLAG_IS_FILE_INPUT\n\t\t\t\telement.type = attrs.type\n\t\t\t}\n\n\t\t\tfor (var key in attrs) {\n\t\t\t\tsetAttr(vnode, element, mask, key, oldAttrs, attrs)\n\t\t\t}\n\t\t}\n\n\t\tfor (var key in oldAttrs) {\n\t\t\tmask |= FLAG_IS_REMOVE\n\t\t\tsetAttr(vnode, element, mask, key, oldAttrs, attrs)\n\t\t}\n\t} catch (e) {\n\t\treturn handleAttributeError(old, e, true)\n\t}\n\n\tupdateFragment(old, vnode)\n\n\tif (mask & FLAG_SELECT_ELEMENT && old == null) {\n\t\ttry {\n\t\t\t// This does exactly what I want, so I'm reusing it to save some code\n\t\t\tvar normalized = getStyleKey(attrs, \"value\")\n\t\t\tif (\"value\" in attrs) {\n\t\t\t\tif (normalized === null) {\n\t\t\t\t\tif (element.selectedIndex >= 0) {\n\t\t\t\t\t\telement.value = null\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (element.selectedIndex < 0 || element.value !== normalized) {\n\t\t\t\t\t\telement.value = normalized\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\thandleAttributeError(old, e, false)\n\t\t}\n\n\t\ttry {\n\t\t\t// This does exactly what I want, so I'm reusing it to save some code\n\t\t\tvar normalized = getPropKey(attrs, \"selectedIndex\")\n\t\t\tif (normalized !== null) {\n\t\t\t\telement.selectedIndex = normalized\n\t\t\t}\n\t\t} catch (e) {\n\t\t\thandleAttributeError(old, e, false)\n\t\t}\n\t}\n\n\tcurrentParent = prevParent\n\tcurrentRefNode = prevRefNode\n\tcurrentNamespace = prevNamespace\n\n\t// Do this as late as possible to reduce how much work browsers have to do to reduce style\n\t// recalcs during initial (sub)tree construction. Also will defer `adoptNode` callbacks in\n\t// custom elements until the last possible point (which will help accelerate some of them).\n\tif (old == null) {\n\t\tinsertAfterCurrentRefNode(vnode.d = element)\n\t}\n\n\tcurrentRefNode = element\n}\n\nvar updateComponent = (old, vnode) => {\n\ttry {\n\t\tvar attrs = vnode.a\n\t\tvar tree, oldInstance, oldAttrs\n\t\trendered: {\n\t\t\tif (old != null) {\n\t\t\t\ttree = old.s\n\t\t\t\toldInstance = old.c\n\t\t\t\toldAttrs = old.a\n\t\t\t} else if (typeof (tree = (vnode.s = vnode.t).call(currentContext, attrs, oldAttrs)) !== \"function\") {\n\t\t\t\tbreak rendered\n\t\t\t}\n\t\t\ttree = (vnode.s = tree).call(currentContext, attrs, oldAttrs)\n\t\t}\n\t\tupdateNode(oldInstance, vnode.c = m.normalize(tree))\n\t} catch (e) {\n\t\tif (currentRemoveOnThrow) throw e\n\t\tconsole.error(e)\n\t}\n}\n\nvar updateInline = (old, vnode) => {\n\ttry {\n\t\tupdateNode(old != null ? old.c : null, vnode.c = m.normalize(vnode.a.call(currentContext, currentContext)))\n\t} catch (e) {\n\t\tif (currentRemoveOnThrow) throw e\n\t\tconsole.error(e)\n\t}\n}\n\nvar removeFragment = (old) => updateFragment(old, null)\n\nvar removeKeyed = (old) => old.a.forEach((p) => updateNode(p, null))\n\nvar removeNode = (old) => {\n\ttry {\n\t\tif (!old.d) return\n\t\told.d.remove()\n\t\told.d = null\n\t} catch (e) {\n\t\tconsole.error(e)\n\t}\n}\n\nvar removeElement = (old) => {\n\tremoveNode(old)\n\tupdateFragment(old, null)\n}\n\nvar removeInstance = (old) => updateNode(old.c, null)\n\n// Replaces an otherwise necessary `switch`.\nvar updateNodeDispatch = [\n\tupdateFragment,\n\tupdateKeyed,\n\tupdateText,\n\tupdateElement,\n\tupdateComponent,\n\tupdateLayout,\n\tupdateRemove,\n\tupdateSet,\n\tupdateUse,\n\tupdateInline,\n]\n\nvar removeNodeDispatch = [\n\tremoveFragment,\n\tremoveKeyed,\n\tremoveNode,\n\tremoveElement,\n\tremoveInstance,\n\tnoop,\n\t(old) => currentHooks.push(old),\n\tremoveFragment,\n\tremoveFragment,\n\tremoveInstance,\n]\n\n//attrs\n\n/* eslint-disable no-unused-vars */\nvar ASCII_HYPHEN = 0x2D\nvar ASCII_COLON = 0x3A\nvar ASCII_LOWER_A = 0x61\nvar ASCII_LOWER_B = 0x62\nvar ASCII_LOWER_C = 0x63\nvar ASCII_LOWER_D = 0x64\nvar ASCII_LOWER_E = 0x65\nvar ASCII_LOWER_F = 0x66\nvar ASCII_LOWER_G = 0x67\nvar ASCII_LOWER_H = 0x68\nvar ASCII_LOWER_I = 0x69\nvar ASCII_LOWER_J = 0x6A\nvar ASCII_LOWER_K = 0x6B\nvar ASCII_LOWER_L = 0x6C\nvar ASCII_LOWER_M = 0x6D\nvar ASCII_LOWER_N = 0x6E\nvar ASCII_LOWER_O = 0x6F\nvar ASCII_LOWER_P = 0x70\nvar ASCII_LOWER_Q = 0x71\nvar ASCII_LOWER_R = 0x72\nvar ASCII_LOWER_S = 0x73\nvar ASCII_LOWER_T = 0x74\nvar ASCII_LOWER_U = 0x75\nvar ASCII_LOWER_V = 0x76\nvar ASCII_LOWER_W = 0x77\nvar ASCII_LOWER_X = 0x78\nvar ASCII_LOWER_Y = 0x79\nvar ASCII_LOWER_Z = 0x7A\n/* eslint-enable no-unused-vars */\n\nvar getPropKey = (host, key) => {\n\tif (host != null && hasOwn.call(host, key)) {\n\t\tvar value = host[key]\n\t\tif (value !== false && value != null) return value\n\t}\n\treturn null\n}\n\nvar getStyleKey = (host, key) => {\n\tif (host != null && hasOwn.call(host, key)) {\n\t\tvar value = host[key]\n\t\tif (value !== false && value != null) return `${value}`\n\t}\n\treturn null\n}\n\nvar setStyle = (style, old, value, add) => {\n\tfor (var propName in value) {\n\t\tvar preferSetter = propName.charCodeAt(0) === ASCII_HYPHEN\n\t\tvar propValue = getStyleKey(value, propName)\n\t\tif (propValue !== null) {\n\t\t\tvar oldValue = getStyleKey(old, propName)\n\t\t\tif (add) {\n\t\t\t\tif (propValue !== oldValue) {\n\t\t\t\t\tif (preferSetter) {\n\t\t\t\t\t\tstyle[propName] = propValue\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstyle.setProperty(propName, propValue)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (oldValue === null) {\n\t\t\t\t\tif (preferSetter) {\n\t\t\t\t\t\tstyle[propName] = \"\"\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstyle.removeProperty(propName)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\nEdit this with extreme caution, and profile any change you make.\n\nNot only is this itself a hot spot (it comprises about 3-5% of runtime overhead), but the way it's\ncompiled can even sometimes have knock-on performance impacts elsewhere. Per some Turbolizer\nexperiments, this will generate around 10-15 KiB of assembly in its final optimized form.\n\nSome of the optimizations it does:\n\n- For pairs of attributes, I pack them into two integers so I can compare them in\n  parallel.\n- I reuse the same character loads for `xlink:*` and `on*` to check for other nodes. I do not reuse\n  the last load, as the first 2 characters is usually enough just on its own to know if a special\n  attribute name is matchable.\n- For small attribute names (4 characters or less), the code handles them in full, with no full\n  string comparison.\n- I fuse all the conditions, `hasOwn` and existence checks, and all the add/remove logic into just\n  this, to reduce startup overhead and keep outer loop code size down.\n- I use a lot of labels to reuse as much code as possible, and thus more ICs, to make optimization\n  easier and better-informed.\n- Bit flags are used extensively here to merge as many comparisons as possible. This function is\n  actually the real reason why I'm using bit flags for stuff like `<input type=\"file\">` in the\n  first place - it moves the check to just the create flow where it's only done once.\n*/\nvar setAttr = (vnode, element, mask, key, old, attrs) => {\n\ttry {\n\t\tvar newValue = getPropKey(attrs, key)\n\t\tvar oldValue = getPropKey(old, key)\n\n\t\tif (mask & FLAG_IS_REMOVE && newValue !== null) return\n\n\t\tforceSetAttribute: {\n\t\t\tforceTryProperty: {\n\t\t\t\tskipValueDiff: {\n\t\t\t\t\tif (key.length > 1) {\n\t\t\t\t\t\tvar pair1 = key.charCodeAt(0) | key.charCodeAt(1) << 16\n\n\t\t\t\t\t\tif (key.length === 2 && pair1 === (ASCII_LOWER_I | ASCII_LOWER_S << 16)) {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else if (pair1 === (ASCII_LOWER_O | ASCII_LOWER_N << 16)) {\n\t\t\t\t\t\t\tif (newValue === oldValue) return\n\t\t\t\t\t\t\t// Update the event\n\t\t\t\t\t\t\tif (typeof newValue === \"function\") {\n\t\t\t\t\t\t\t\tif (typeof oldValue !== \"function\") {\n\t\t\t\t\t\t\t\t\tif (vnode.s == null) vnode.s = new EventDict()\n\t\t\t\t\t\t\t\t\telement.addEventListener(key.slice(2), vnode.s)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Save this, so the current redraw is correctly tracked.\n\t\t\t\t\t\t\t\tvnode.s._ = currentRedraw\n\t\t\t\t\t\t\t\tvnode.s.set(key, newValue)\n\t\t\t\t\t\t\t} else if (typeof oldValue === \"function\") {\n\t\t\t\t\t\t\t\telement.removeEventListener(key.slice(2), vnode.s)\n\t\t\t\t\t\t\t\tvnode.s.delete(key)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else if (key.length > 3) {\n\t\t\t\t\t\t\tvar pair2 = key.charCodeAt(2) | key.charCodeAt(3) << 16\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tkey.length > 6 &&\n\t\t\t\t\t\t\t\tpair1 === (ASCII_LOWER_X | ASCII_LOWER_L << 16) &&\n\t\t\t\t\t\t\t\tpair2 === (ASCII_LOWER_I | ASCII_LOWER_N << 16) &&\n\t\t\t\t\t\t\t\t(key.charCodeAt(4) | key.charCodeAt(5) << 16) === (ASCII_LOWER_K | ASCII_COLON << 16)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tkey = key.slice(6)\n\t\t\t\t\t\t\t\tif (newValue !== null) {\n\t\t\t\t\t\t\t\t\telement.setAttributeNS(xlinkNs, key, newValue)\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\telement.removeAttributeNS(xlinkNs, key)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t} else if (key.length === 4) {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tpair1 === (ASCII_LOWER_T | ASCII_LOWER_Y << 16) &&\n\t\t\t\t\t\t\t\t\tpair2 === (ASCII_LOWER_P | ASCII_LOWER_E << 16)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tif (!(mask & FLAG_INPUT_ELEMENT)) break skipValueDiff\n\t\t\t\t\t\t\t\t\tif (newValue === null) break forceSetAttribute\n\t\t\t\t\t\t\t\t\tbreak forceTryProperty\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\t// Try to avoid a few browser bugs on normal elements.\n\t\t\t\t\t\t\t\t\tpair1 === (ASCII_LOWER_H | ASCII_LOWER_R << 16) && pair2 === (ASCII_LOWER_E | ASCII_LOWER_F << 16) ||\n\t\t\t\t\t\t\t\t\tpair1 === (ASCII_LOWER_L | ASCII_LOWER_I << 16) && pair2 === (ASCII_LOWER_S | ASCII_LOWER_T << 16) ||\n\t\t\t\t\t\t\t\t\tpair1 === (ASCII_LOWER_F | ASCII_LOWER_O << 16) && pair2 === (ASCII_LOWER_R | ASCII_LOWER_M << 16)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t// If it's a custom element, just keep it. Otherwise, force the attribute\n\t\t\t\t\t\t\t\t\t// to be set.\n\t\t\t\t\t\t\t\t\tif (!(mask & FLAG_CUSTOM_ELEMENT)) {\n\t\t\t\t\t\t\t\t\t\tbreak forceSetAttribute\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (key.length > 4) {\n\t\t\t\t\t\t\t\tswitch (key) {\n\t\t\t\t\t\t\t\t\tcase \"children\":\n\t\t\t\t\t\t\t\t\t\treturn\n\n\t\t\t\t\t\t\t\t\tcase \"class\":\n\t\t\t\t\t\t\t\t\tcase \"className\":\n\t\t\t\t\t\t\t\t\tcase \"title\":\n\t\t\t\t\t\t\t\t\t\tif (newValue === null) break forceSetAttribute\n\t\t\t\t\t\t\t\t\t\tbreak forceTryProperty\n\n\t\t\t\t\t\t\t\t\tcase \"value\":\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t// Filter out non-HTML keys and custom elements\n\t\t\t\t\t\t\t\t\t\t\t(mask & (FLAG_HTML_ELEMENT | FLAG_CUSTOM_ELEMENT)) !== FLAG_HTML_ELEMENT ||\n\t\t\t\t\t\t\t\t\t\t\t!(key in element)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (newValue === null) {\n\t\t\t\t\t\t\t\t\t\t\tif (mask & (FLAG_OPTION_ELEMENT | FLAG_SELECT_ELEMENT)) {\n\t\t\t\t\t\t\t\t\t\t\t\tbreak forceSetAttribute\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tbreak forceTryProperty\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (!(mask & (FLAG_INPUT_ELEMENT | FLAG_TEXTAREA_ELEMENT | FLAG_SELECT_ELEMENT | FLAG_OPTION_ELEMENT))) {\n\t\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// It's always stringified, so it's okay to always coerce\n\t\t\t\t\t\t\t\t\t\tif (element.value === (newValue = `${newValue}`)) {\n\t\t\t\t\t\t\t\t\t\t\t// Setting `<input type=\"file\" value=\"...\">` to the same value causes an\n\t\t\t\t\t\t\t\t\t\t\t// error to be generated if it's non-empty\n\t\t\t\t\t\t\t\t\t\t\tif (mask & FLAG_IS_FILE_INPUT) return\n\t\t\t\t\t\t\t\t\t\t\t// Setting `<input value=\"...\">` to the same value by typing on focused\n\t\t\t\t\t\t\t\t\t\t\t// element moves cursor to end in Chrome\n\t\t\t\t\t\t\t\t\t\t\tif (mask & (FLAG_INPUT_ELEMENT | FLAG_TEXTAREA_ELEMENT)) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (element === currentDocument.activeElement) return\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tif (oldValue != null && oldValue !== false) return\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (mask & FLAG_IS_FILE_INPUT) {\n\t\t\t\t\t\t\t\t\t\t\t//setting input[type=file][value] to different value is an error if it's non-empty\n\t\t\t\t\t\t\t\t\t\t\t// Not ideal, but it at least works around the most common source of uncaught exceptions for now.\n\t\t\t\t\t\t\t\t\t\t\tif (newValue !== \"\") {\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.error(\"File input `value` attributes must either mirror the current value or be set to the empty string (to reset).\")\n\t\t\t\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tbreak forceTryProperty\n\n\t\t\t\t\t\t\t\t\tcase \"style\":\n\t\t\t\t\t\t\t\t\t\tif (oldValue === newValue) {\n\t\t\t\t\t\t\t\t\t\t\t// Styles are equivalent, do nothing.\n\t\t\t\t\t\t\t\t\t\t} else if (newValue === null) {\n\t\t\t\t\t\t\t\t\t\t\t// New style is missing, just clear it.\n\t\t\t\t\t\t\t\t\t\t\telement.style = \"\"\n\t\t\t\t\t\t\t\t\t\t} else if (typeof newValue !== \"object\") {\n\t\t\t\t\t\t\t\t\t\t\t// New style is a string, let engine deal with patching.\n\t\t\t\t\t\t\t\t\t\t\telement.style = newValue\n\t\t\t\t\t\t\t\t\t\t} else if (oldValue === null || typeof oldValue !== \"object\") {\n\t\t\t\t\t\t\t\t\t\t\t// `old` is missing or a string, `style` is an object.\n\t\t\t\t\t\t\t\t\t\t\telement.style = \"\"\n\t\t\t\t\t\t\t\t\t\t\t// Add new style properties\n\t\t\t\t\t\t\t\t\t\t\tsetStyle(element.style, null, newValue, true)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t// Both old & new are (different) objects, or `old` is missing.\n\t\t\t\t\t\t\t\t\t\t\t// Update style properties that have changed, or add new style properties\n\t\t\t\t\t\t\t\t\t\t\tsetStyle(element.style, oldValue, newValue, true)\n\t\t\t\t\t\t\t\t\t\t\t// Remove style properties that no longer exist\n\t\t\t\t\t\t\t\t\t\t\tsetStyle(element.style, newValue, oldValue, false)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn\n\n\t\t\t\t\t\t\t\t\tcase \"selected\":\n\t\t\t\t\t\t\t\t\t\tvar active = currentDocument.activeElement\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\telement === active ||\n\t\t\t\t\t\t\t\t\t\t\tmask & FLAG_OPTION_ELEMENT && element.parentNode === active\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// falls through\n\n\t\t\t\t\t\t\t\t\tcase \"checked\":\n\t\t\t\t\t\t\t\t\tcase \"selectedIndex\":\n\t\t\t\t\t\t\t\t\t\tbreak skipValueDiff\n\n\t\t\t\t\t\t\t\t\t// Try to avoid a few browser bugs on normal elements.\n\t\t\t\t\t\t\t\t\tcase \"width\":\n\t\t\t\t\t\t\t\t\tcase \"height\":\n\t\t\t\t\t\t\t\t\t\t// If it's a custom element, just keep it. Otherwise, force the attribute\n\t\t\t\t\t\t\t\t\t\t// to be set.\n\t\t\t\t\t\t\t\t\t\tif (!(mask & FLAG_CUSTOM_ELEMENT)) {\n\t\t\t\t\t\t\t\t\t\t\tbreak forceSetAttribute\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (newValue !== null && typeof newValue !== \"object\" && oldValue === newValue) return\n\t\t\t\t}\n\n\t\t\t\t// Filter out namespaced keys\n\t\t\t\tif (!(mask & FLAG_HTML_ELEMENT)) {\n\t\t\t\t\tbreak forceSetAttribute\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Filter out namespaced keys\n\t\t\t// Defer the property check until *after* we check everything.\n\t\t\tif (key in element) {\n\t\t\t\telement[key] = newValue\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif (newValue === null) {\n\t\t\tif (oldValue !== null) element.removeAttribute(key)\n\t\t} else {\n\t\t\telement.setAttribute(key, newValue === true ? \"\" : newValue)\n\t\t}\n\t} catch (e) {\n\t\thandleAttributeError(old, e, false)\n\t}\n}\n\n// Here's an explanation of how this works:\n// 1. The event names are always (by design) prefixed by `on`.\n// 2. The EventListener interface accepts either a function or an object with a `handleEvent` method.\n// 3. The object inherits from `Map`, to avoid hitting global setters.\n// 4. The event name is remapped to the handler before calling it.\n// 5. In function-based event handlers, `ev.currentTarget === this`. We replicate that below.\n// 6. In function-based event handlers, `return false` prevents the default action and stops event\n//    propagation. Instead of that, we hijack the return value, so we can have it auto-redraw if\n//    the user returns `\"skip-redraw\"` or a promise that resolves to it.\nclass EventDict extends Map {\n\tasync handleEvent(ev) {\n\t\tinvokeRedrawable(this._, this.get(`on${ev.type}`), ev.currentTarget, ev)\n\t}\n}\n\nvar currentlyRendering = []\n\nm.render = (dom, vnode, {redraw, removeOnThrow} = {}) => {\n\tif (!dom) {\n\t\tthrow new TypeError(\"DOM element being rendered to does not exist.\")\n\t}\n\n\tcheckCallback(redraw, true, \"redraw\")\n\n\tfor (var root of currentlyRendering) {\n\t\tif (dom.contains(root)) {\n\t\t\tthrow new TypeError(\"Node is currently being rendered to and thus is locked.\")\n\t\t}\n\t}\n\n\tvar active = dom.ownerDocument.activeElement\n\tvar namespace = dom.namespaceURI\n\n\tvar prevHooks = currentHooks\n\tvar prevRedraw = currentRedraw\n\tvar prevParent = currentParent\n\tvar prevRefNode = currentRefNode\n\tvar prevNamespace = currentNamespace\n\tvar prevDocument = currentDocument\n\tvar prevContext = currentContext\n\tvar prevRemoveOnThrow = currentRemoveOnThrow\n\tvar hooks = currentHooks = []\n\n\ttry {\n\t\tcurrentlyRendering.push(currentParent = dom)\n\t\tcurrentRedraw = typeof redraw === \"function\" ? redraw : null\n\t\tcurrentRefNode = null\n\t\tcurrentNamespace = namespace === htmlNs ? null : namespace\n\t\tcurrentDocument = dom.ownerDocument\n\t\tcurrentContext = {redraw}\n\t\t// eslint-disable-next-line no-implicit-coercion\n\t\tcurrentRemoveOnThrow = !!removeOnThrow\n\n\t\t// First time rendering into a node clears it out\n\t\tif (dom.vnodes == null) dom.textContent = \"\"\n\t\tupdateNode(dom.vnodes, vnode = m.normalize(vnode))\n\t\tdom.vnodes = vnode\n\t\t// `document.activeElement` can return null: https://html.spec.whatwg.org/multipage/interaction.html#dom-document-activeelement\n\t\tif (active != null && currentDocument.activeElement !== active && typeof active.focus === \"function\") {\n\t\t\tactive.focus()\n\t\t}\n\t\tfor (var {a, d} of hooks) {\n\t\t\ttry {\n\t\t\t\ta(d)\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(e)\n\t\t\t}\n\t\t}\n\t} finally {\n\t\tcurrentRedraw = prevRedraw\n\t\tcurrentHooks = prevHooks\n\t\tcurrentParent = prevParent\n\t\tcurrentRefNode = prevRefNode\n\t\tcurrentNamespace = prevNamespace\n\t\tcurrentDocument = prevDocument\n\t\tcurrentContext = prevContext\n\t\tcurrentRemoveOnThrow = prevRemoveOnThrow\n\t\tcurrentlyRendering.pop()\n\t}\n}\n\nm.mount = (root, view) => {\n\tif (!root) throw new TypeError(\"Root must be an element\")\n\n\tif (typeof view !== \"function\") {\n\t\tthrow new TypeError(\"View must be a function\")\n\t}\n\n\tvar window = root.ownerDocument.defaultView\n\tvar id = 0\n\tvar unschedule = () => {\n\t\tif (id) {\n\t\t\twindow.cancelAnimationFrame(id)\n\t\t\tid = 0\n\t\t}\n\t}\n\tvar redraw = () => { if (!id) id = window.requestAnimationFrame(redraw.sync) }\n\t// Cheating with context access for a minor bundle size win.\n\tvar Mount = (_, old) => [m.remove(unschedule), view.call(currentContext, !old)]\n\tredraw.sync = () => {\n\t\tunschedule()\n\t\tm.render(root, m(Mount), {redraw})\n\t}\n\n\tm.render(root, null)\n\tredraw.sync()\n\n\treturn redraw\n}\n","/* global performance, setTimeout, clearTimeout */\n\nimport {noop} from \"../util.js\"\n\nvar validateDelay = (delay) => {\n\tif (!Number.isFinite(delay) || delay <= 0) {\n\t\tthrow new RangeError(\"Timer delay must be finite and positive\")\n\t}\n}\n\nvar rateLimiterImpl = (delay = 500, isThrottler) => {\n\tvalidateDelay(delay)\n\n\tvar closed = false\n\tvar start = 0\n\tvar timer = 0\n\tvar resolveNext = noop\n\n\tvar callback = () => {\n\t\ttimer = undefined\n\t\tresolveNext(false)\n\t\tresolveNext = noop\n\t}\n\n\tvar rateLimiter = async (ignoreLeading) => {\n\t\tif (closed) {\n\t\t\treturn true\n\t\t}\n\n\t\tresolveNext(true)\n\t\tresolveNext = noop\n\n\t\tif (timer) {\n\t\t\tif (isThrottler) {\n\t\t\t\treturn new Promise((resolve) => resolveNext = resolve)\n\t\t\t}\n\n\t\t\tclearTimeout(timer)\n\t\t\tignoreLeading = true\n\t\t}\n\n\t\tstart = performance.now()\n\t\ttimer = setTimeout(callback, delay)\n\n\t\tif (!ignoreLeading) {\n\t\t\treturn\n\t\t}\n\n\t\treturn new Promise((resolve) => resolveNext = resolve)\n\t}\n\n\trateLimiter.update = (newDelay) => {\n\t\tvalidateDelay(newDelay)\n\t\tdelay = newDelay\n\n\t\tif (closed) return\n\t\tif (timer) {\n\t\t\tclearTimeout(timer)\n\t\t\ttimer = setTimeout(callback, (start - performance.now()) + delay)\n\t\t}\n\t}\n\n\trateLimiter.dispose = () => {\n\t\tif (closed) return\n\t\tclosed = true\n\t\tclearTimeout(timer)\n\t\tresolveNext(true)\n\t\tresolveNext = noop\n\t}\n\n\treturn rateLimiter\n}\n\n/**\n * A general-purpose bi-edge throttler, with a dynamically configurable limit. It's much better\n * than your typical `throttle(f, ms)` because it lets you easily separate the trigger and reaction\n * using a single shared, encapsulated state object. That same separation is also used to make the\n * rate limit dynamically reconfigurable on hit.\n *\n * Create as `throttled = m.throttler(ms)` and do `if (await throttled()) return` to rate-limit\n * the code that follows. The result is one of three values, to allow you to identify edges:\n *\n * - Leading edge: `undefined`\n * - Trailing edge: `false`, returned only if a second call was made\n * - No edge: `true`\n *\n * Call `throttled.update(ms)` to update the interval. This not only impacts future delays, but also any current one.\n *\n * To dispose, like on component removal, call `throttled.dispose()`.\n *\n * If you don't sepecify a delay, it defaults to 500ms on creation, which works well enough for\n * most needs. There is no default for `throttled.update(...)` - you must specify one explicitly.\n *\n * Example usage:\n *\n * ```js\n * const throttled = m.throttler()\n * let results, error\n * return function () {\n *     return [\n *         m.remove(throttled.dispose),\n *         m(\"input[type=search]\", {\n *             oninput: async (ev) => {\n *                 // Skip redraw if rate limited - it's pointless\n *                 if (await throttled()) return false\n *                 error = results = null\n *                 this.redraw()\n *                 try {\n *                     const response = await fetch(m.p(\"/search\", {q: ev.target.value}))\n *                     if (response.ok) {\n *                         results = await response.json()\n *                     } else {\n *                         error = await response.text()\n *                     }\n *                 } catch (e) {\n *                     error = e.message\n *                 }\n *             },\n *         }),\n *         results.map((result) => m(SearchResult, {result})),\n *         !error || m(ErrorDisplay, {error})),\n *     ]\n * }\n * ```\n *\n * Important note: due to the way this is implemented in basically all runtimes, the throttler's\n * clock might not tick during sleep, so if you do `await throttled()` and immediately sleep in a\n * low-power state for 5 minutes, you might have to wait another 10 minutes after resuming to a\n * high-power state.\n */\nvar throttler = (delay) => rateLimiterImpl(delay, 1)\n\n/**\n * A general-purpose bi-edge debouncer, with a dynamically configurable limit. It's much better\n * than your typical `debounce(f, ms)` because it lets you easily separate the trigger and reaction\n * using a single shared, encapsulated state object. That same separation is also used to make the\n * rate limit dynamically reconfigurable on hit.\n *\n * Create as `debounced = m.debouncer(ms)` and do `if (await debounced()) return` to rate-limit\n * the code that follows. The result is one of three values, to allow you to identify edges:\n *\n * - Leading edge: `undefined`\n * - Trailing edge: `false`, returned only if a second call was made\n * - No edge: `true`\n *\n * Call `debounced.update(ms)` to update the interval. This not only impacts future delays, but also any current one.\n *\n * To dispose, like on component removal, call `debounced.dispose()`.\n *\n * If you don't sepecify a delay, it defaults to 500ms on creation, which works well enough for\n * most needs. There is no default for `debounced.update(...)` - you must specify one explicitly.\n *\n * Example usage:\n *\n * ```js\n * const debounced = m.debouncer()\n * let results, error\n * return (attrs) => [\n *     m.remove(debounced.dispose),\n *     m(\"input[type=text].value\", {\n *         async oninput(ev) {\n *             // Skip redraw if rate limited - it's pointless\n *             if ((await debounced()) !== false) return false\n *             try {\n *                 const response = await fetch(m.p(\"/save/:id\", {id: attrs.id}), {\n *                     body: JSON.stringify({value: ev.target.value}),\n *                 })\n *                 if (!response.ok) {\n *                     error = await response.text()\n *                 }\n *             } catch (e) {\n *                 error = e.message\n *             }\n *         },\n *     }),\n *     results.map((result) => m(SearchResult, {result})),\n *     !error || m(ErrorDisplay, {error})),\n * ]\n * ```\n *\n * Important note: due to the way this is implemented in basically all runtimes, the debouncer's\n * clock might not tick during sleep, so if you do `await debounced()` and immediately sleep in a\n * low-power state for 5 minutes, you might have to wait another 10 minutes after resuming to a\n * high-power state.\n */\nvar debouncer = (delay) => rateLimiterImpl(delay, 0)\n\nexport {throttler, debouncer}\n","/* global window: false */\nimport m from \"../core.js\"\n\nimport {checkCallback} from \"../util.js\"\n\nvar Route = function ({p: prefix}) {\n\tvar href = this.href\n\tvar mustReplace, redraw, currentParsedHref\n\tvar currentRoute\n\n\tvar updateRouteWithHref = () => {\n\t\tvar url = new URL(href)\n\t\tvar urlPath = url.pathname + url.search + url.hash\n\t\tvar decodedPrefix = prefix\n\t\tvar index = urlPath.indexOf(decodedPrefix)\n\t\tif (index < 0) index = urlPath.indexOf(decodedPrefix = encodeURI(decodedPrefix))\n\t\tif (index >= 0) urlPath = urlPath.slice(index + decodedPrefix.length)\n\t\tif (urlPath[0] !== \"/\") urlPath = `/${urlPath}`\n\n\t\tvar parsedUrl = new URL(urlPath, href)\n\t\tvar path = decodeURI(parsedUrl.pathname)\n\t\tmustReplace = false\n\t\tcurrentRoute = {\n\t\t\tprefix,\n\t\t\tpath,\n\t\t\tparams: parsedUrl.searchParams,\n\t\t\tcurrent: path + parsedUrl.search + parsedUrl.hash,\n\t\t\tset,\n\t\t\tmatch,\n\t\t}\n\t\treturn currentParsedHref = parsedUrl.href\n\t}\n\n\tvar updateRoute = () => {\n\t\tif (href === window.location.href) return\n\t\thref = window.location.href\n\t\tif (currentParsedHref !== updateRouteWithHref()) redraw()\n\t}\n\n\tvar set = (path, {replace, state} = {}) => {\n\t\tif (mustReplace) replace = true\n\t\tmustReplace = true\n\t\tqueueMicrotask(updateRoute)\n\t\tredraw()\n\t\tif (typeof window === \"object\") {\n\t\t\twindow.history[replace ? \"replaceState\" : \"pushState\"](state, \"\", prefix + path)\n\t\t}\n\t}\n\n\tvar match = (path) => m.match(currentRoute, path)\n\n\tif (!href) {\n\t\tif (typeof window !== \"object\") {\n\t\t\tthrow new TypeError(\"Outside the DOM, `href` must be set\")\n\t\t}\n\t\thref = window.location.href\n\t\twindow.addEventListener(\"popstate\", updateRoute)\n\t} else if (typeof href !== \"string\") {\n\t\tthrow new TypeError(\"The initial route href must be a string if given\")\n\t}\n\n\tupdateRouteWithHref()\n\n\treturn function ({v: view}) {\n\t\tredraw = checkCallback(this.redraw, false, \"context.redraw\")\n\n\t\treturn [\n\t\t\tm.remove(() => window.removeEventListener(\"popstate\", updateRoute)),\n\t\t\tm.set({route: currentRoute}, m.inline(view)),\n\t\t]\n\t}\n}\n\nexport var route = (prefix, view) => {\n\tif (typeof prefix !== \"string\") {\n\t\tthrow new TypeError(\"The route prefix must be a string\")\n\t}\n\n\treturn m(Route, {v: checkCallback(view, false, \"view\"), p: prefix})\n}\n\n// Let's provide a *right* way to manage a route link, rather than letting people screw up\n// accessibility on accident.\n//\n// Note: this does *not* support disabling. Instead, consider more accessible alternatives like not\n// showing the link in the first place. If you absolutely have to disable the link, disable it by\n// removing this component (like via `m(\"div\", {disabled}, !disabled && m(Link))`). There's\n// friction here for a reason.\nvar Link = () => {\n\tvar href, opts, setRoute\n\tvar listener = (ev) => {\n\t\t// Adapted from React Router's implementation:\n\t\t// https://github.com/ReactTraining/react-router/blob/520a0acd48ae1b066eb0b07d6d4d1790a1d02482/packages/react-router-dom/modules/Link.js\n\t\t//\n\t\t// Try to be flexible and intuitive in how we handle links.\n\t\t// Fun fact: links aren't as obvious to get right as you\n\t\t// would expect. There's a lot more valid ways to click a\n\t\t// link than this, and one might want to not simply click a\n\t\t// link, but right click or command-click it to copy the\n\t\t// link target, etc. Nope, this isn't just for blind people.\n\t\tif (\n\t\t\t// Skip if `onclick` prevented default\n\t\t\t!ev.defaultPrevented &&\n\t\t\t// Ignore everything but left clicks\n\t\t\t(ev.button === 0 || ev.which === 0 || ev.which === 1) &&\n\t\t\t// Let the browser handle `target=_blank`, etc.\n\t\t\t(!ev.currentTarget.target || ev.currentTarget.target === \"_self\") &&\n\t\t\t// No modifier keys\n\t\t\t!ev.ctrlKey && !ev.metaKey && !ev.shiftKey && !ev.altKey\n\t\t) {\n\t\t\tsetRoute(href, opts)\n\t\t\t// Capture the event, and don't double-call `redraw`.\n\t\t\treturn m.capture(ev)\n\t\t}\n\t}\n\n\treturn function (attrs, old) {\n\t\tsetRoute = this.route.set\n\t\thref = attrs.h\n\t\topts = attrs.o\n\t\treturn [\n\t\t\tm.layout((dom) => {\n\t\t\t\tdom.href = this.route.prefix + href\n\t\t\t\tif (!old) dom.addEventListener(\"click\", listener)\n\t\t\t}),\n\t\t\tm.remove((dom) => {\n\t\t\t\tdom.removeEventListener(\"click\", listener)\n\t\t\t}),\n\t\t]\n\t}\n}\n\nexport var link = (href, opts) => m(Link, {h: `${href}`, o: opts})\n","/*\nCaution: `m.p` and the failure path of `m.match` are both perf-sensitive. More so than you might\nthink. And unfortunately, string indexing is incredibly slow.\n\nSuppose we're in a large CRUD app with 20 resources and 10 pages for each resource, for a total of\n200 routes. And further, suppose we're on a complicated management page (like a domain management\npage) with a grid of 50 rows and 8 routed icon links each. Each link has its URL constructed via\n`m.p(...)`, for a total of 400 calls. (This is high, but still realistic. At the time of writing,\nNamesilo's UI for selecting domains and performing batch operations on them is designed as a table\nwith about that many icon links and up to 100 domains per page.)\n\nTo meet 60 FPS, we generally have to have the whole page rendered in under 10ms for the browser to\nnot skip frames. To give the user some buffer for view inefficiency, let's aim for 2ms of overhead\nfor all the `m.match` and `m.p` calls. From some local benchmarking, the failure path of `m.match`\nrequires about 1us/op, so 200 routes would come out to about 0.2ms. (The success path is well under\n0.1ms, so its overhead is negligible.) That leaves us about 1.8ms for 400 calls to `m.p(...)`. Do\nthe math, and that comes out to a whopping 4.5 us/call for us to meet our deadline.\n\nI've tried the following for `m.p`, and most of them ended up being too slow. Times are for calls\nwith two string interpolation parameters (the slow path), measured on an older laptop. The laptop\nexperiences a roughly 30-60% perf boost when charging over when running from battery. The lower end\nis while charging, the higher end is while on battery.\n\n- A direct port of v2's `m.buildPathname`: 15-25 us\n\t- This provides headroom for up to about 70 calls per frame.\n- Replace its inner `template.replace` with a `re.exec(template)` loop: 12-18 microseconds\n\t- This provides headroom for up to about 100 calls per frame.\n- Switch from using match strings to computing positions from `exec.index`: 6.5-12 microseconds\n\t- This provides headroom for up to about 150 calls per frame.\n- Switch from using match strings to computing positions from `exec.index`: 6.5-12 microseconds\n\t- This provides headroom for up to about 150 calls per frame.\n- Iterate string directly: 2-3.5 microseconds\n\t- This provides headroom for up to about 500 calls per frame.\n\nI've tried optimizing it further, but I'm running into the limits of string performance at this\npoint. And the computing positions from `exec.index` is about the fastest I could get any\nregexp-based solution to go.\n\nAlso, I tried at first restricting parameters to JS identifiers (like `m.match` parameters are, as\nI use named groups to generate the properties), but that, just on the regexp side, cut performance\nin more than half. The `exec.match` form, the ideal one for regexp-based solutions, slowed down\nfrom 12 microseconds to about 35-40 microseconds. And that would reduce headroom down to only about\n45-50 calls per frame. This rate is simply too slow to even be viable for some smaller apps.\n*/\n\n// Allowed terminators for `m.match`:\n// - `.` for `:file.:ext`\n// - `-` for `:lang-:locale`\n// - `/` for `/:some/:path/`\n// - end for `/:some/:path`\n// Escape with `\\\\`\n// Use `*rest` for rest\n\nimport {hasOwn} from \"../util.js\"\n\nvar toString = {}.toString\n\nvar invalidMatchTemplate = /\\/\\/|[:*][^$_\\p{IDS}]|[:*].[$\\p{IDC}]*[:*]|\\*.*?[^$\\p{IDC}]|:([$_\\p{IDS}][$\\p{IDC}]*)[^$\\p{IDC}].*?[:*]\\1(?![$\\p{IDC}])/u\n// I escape literal text so people can use things like `:file.:ext` or `:lang-:locale` in routes.\n// This is all merged into one pass so I don't also accidentally escape `-` and make it harder to\n// detect it to ban it from template parameters.\nvar matcherCompile = /([:*])([$_\\p{IDS}][$\\p{IDC}]*)|\\\\\\\\|\\\\?([$^*+.()|[\\]{}])|\\\\(.)/ug\n\nvar serializeQueryValue = (pq, result, prefix, value) => {\n\tvar proto\n\n\tif (value != null && value !== false) {\n\t\tif (Array.isArray(value)) {\n\t\t\tfor (var i of value) {\n\t\t\t\tresult = serializeQueryValue(pq, result, `${prefix}[]`, i)\n\t\t\t}\n\t\t} else if (\n\t\t\ttypeof value === \"object\" &&\n\t\t\t((proto = Object.getPrototypeOf(value)) == null || proto === Object.prototype || toString.call(value) === \"[object Object]\")\n\t\t) {\n\t\t\tfor (var k in value) {\n\t\t\t\tif (hasOwn.call(value, k)) {\n\t\t\t\t\tresult = serializeQueryValue(pq, result, `${prefix}[${k}]`, value[k])\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvar sep = pq.s\n\t\t\tpq.s = \"&\"\n\t\t\tresult += sep + encodeURIComponent(prefix) + (value === true ? \"\" : `=${\n\t\t\t\ttypeof value === \"number\" || typeof value === \"bigint\"\n\t\t\t\t\t? value\n\t\t\t\t\t: encodeURIComponent(value)\n\t\t\t}`)\n\t\t}\n\t}\n\n\treturn result\n}\n\nvar serializeQueryParams = (sep, value, exclude, params) => {\n\tvar pq = {s: sep}\n\tfor (var key in params) {\n\t\tif (hasOwn.call(params, key) && !exclude.includes(key)) {\n\t\t\tvalue = serializeQueryValue(pq, value, key, params[key])\n\t\t}\n\t}\n\treturn value\n}\n\nvar query = (params) => serializeQueryParams(\"\", \"\", [], params)\n\nvar QUERY = 0\nvar ESCAPE = 1\nvar CHAR = 2\n// Structure:\n// Bit 0: is raw\n// Bit 1: is next\n// Bit 2: always set\nvar VAR_START = 4\n// var RAW_VAR_START = 5\nvar VAR_NEXT = 6\n// var RAW_VAR_NEXT = 7\nvar STATE_IS_RAW = 1\nvar STATE_IS_NEXT = 2\n\n\n// Returns `path` from `template` + `params`\n/**\n * @param {string} template\n * @param {undefined | null | Record<string, any>} params\n */\nvar p = (template, params) => {\n\t// This carefully only iterates the template once.\n\tvar prev = 0\n\tvar start = 0\n\tvar state = CHAR\n\t// An array is fine. It's almost never large enough for the overhead of hashing to pay off.\n\tvar inTemplate = []\n\t// Used for later.\n\tvar hash = \"\"\n\tvar queryIndex = -1\n\tvar hashIndex = -1\n\tvar result = \"\"\n\tvar sep = \"?\"\n\n\tvar NOT_VAR_NEXT = VAR_NEXT - 1\n\n\t// Using `for ... of` so the engine can do bounds check elimination more easily.\n\tfor (var i = 0;; i++) {\n\t\tvar ch = template.charAt(i)\n\n\t\tif (\n\t\t\tstate > NOT_VAR_NEXT &&\n\t\t\t(ch === \"\" || ch === \"#\" || ch === \"?\" || ch === \"\\\\\" || ch === \"/\" || ch === \".\" || ch === \"-\")\n\t\t) {\n\t\t\tvar segment = template.slice(start + 1, i)\n\n\t\t\t// If no such parameter exists, don't interpolate it.\n\t\t\tif (params != null && params[segment] != null) {\n\t\t\t\tinTemplate.push(segment)\n\t\t\t\tsegment = `${params[segment]}`\n\n\t\t\t\t// Escape normal parameters, but not variadic ones.\n\t\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t\tif (state & STATE_IS_RAW) {\n\t\t\t\t\tvar newHashIndex = segment.indexOf(\"#\")\n\t\t\t\t\tvar newQueryIndex = (newHashIndex < 0 ? segment : segment.slice(0, newHashIndex)).indexOf(\"?\")\n\t\t\t\t\tif (newQueryIndex >= 0) {\n\t\t\t\t\t\tsep = \"&\"\n\t\t\t\t\t\tqueryIndex = result.length + (prev - start) + newQueryIndex\n\t\t\t\t\t}\n\t\t\t\t\tif (newHashIndex >= 0) {\n\t\t\t\t\t\thashIndex = result.length + (prev - start) + newHashIndex\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsegment = encodeURIComponent(segment)\n\t\t\t\t}\n\n\t\t\t\t// Drop the preceding `:`/`*`/`\\` character from the appended segment\n\t\t\t\tif (prev !== start) {\n\t\t\t\t\tresult += template.slice(prev, start)\n\t\t\t\t}\n\n\t\t\t\tresult += segment\n\n\t\t\t\t// Start from the next end\n\t\t\t\tprev = i\n\t\t\t}\n\t\t}\n\n\t\tif (ch === \"#\") {\n\t\t\tif (hashIndex < 0) hashIndex = i\n\t\t} else if (ch !== \"\") {\n\t\t\tif (state === QUERY) {\n\t\t\t\t// do nothing\n\t\t\t} else if (ch === \"?\") {\n\t\t\t\t// The query start cannot be escaped. It's a proper URL delimiter.\n\t\t\t\tif (queryIndex < 0) {\n\t\t\t\t\tqueryIndex = i\n\t\t\t\t\tsep = \"&\"\n\t\t\t\t} else {\n\t\t\t\t\t// Inject an `&` in place of a `?`. Note that `sep === \"&\"`\n\t\t\t\t\tif (prev !== i) result += template.slice(prev, i)\n\t\t\t\t\tresult += \"&\"\n\t\t\t\t\tprev = i + 1\n\t\t\t\t}\n\t\t\t\tstate = QUERY\n\t\t\t} else if (state === ESCAPE) {\n\t\t\t\t// Drop the preceding `\\` character from the appended segment\n\t\t\t\tif (prev !== start) {\n\t\t\t\t\tresult += template.slice(prev, start)\n\t\t\t\t}\n\n\t\t\t\tstate = CHAR\n\t\t\t\tstart = prev = i\n\t\t\t} else if (ch === \"\\\\\") {\n\t\t\t\tstart = i\n\t\t\t\tstate = ESCAPE\n\t\t\t} else if (ch === \":\" || ch === \"*\") {\n\t\t\t\tif (state > CHAR) {\n\t\t\t\t\tthrow new SyntaxError(\"Template parameter names must be separated by either a '/', '-', or '.'.\")\n\t\t\t\t}\n\t\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t\tstate = VAR_START | (ch === \"*\")\n\t\t\t\tstart = i\n\t\t\t} else if (ch === \"/\" || ch === \".\" || ch === \"-\") {\n\t\t\t\tstate = CHAR\n\t\t\t} else if (state > CHAR) {\n\t\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t\tstate |= STATE_IS_NEXT\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\tif (prev === 0 && params == null) {\n\t\t\treturn template\n\t\t}\n\n\t\tif (prev < template.length) {\n\t\t\tresult += template.slice(prev)\n\t\t}\n\n\t\tif (hashIndex >= 0) {\n\t\t\thash = result.slice(hashIndex)\n\t\t\tresult = result.slice(0, hashIndex)\n\t\t}\n\n\t\treturn serializeQueryParams(sep, result, inTemplate, params) + hash\n\t}\n}\n\n/** @typedef {RegExp & {r: number, p: URLSearchParams}} Matcher */\n\n/** @type {Map<string, Matcher>} */\nvar cache = new Map()\n\n/** @param {string} pattern @returns {Matcher} */\nvar compile = (pattern) => {\n\tif (invalidMatchTemplate.test(pattern)) {\n\t\tthrow new SyntaxError(\"Invalid pattern\")\n\t}\n\n\tvar queryIndex = pattern.indexOf(\"?\")\n\tvar hashIndex = pattern.indexOf(\"#\")\n\tvar index = queryIndex < hashIndex ? queryIndex : hashIndex\n\tvar rest\n\tvar re = new RegExp(`^${pattern.slice(0, index < 0 ? undefined : index).replace(\n\t\tmatcherCompile,\n\t\t(_, p, name, esc1, esc2) => {\n\t\t\tif (p === \"*\") {\n\t\t\t\trest = name\n\t\t\t\treturn `(?<${name}>.*)`\n\t\t\t} else if (p === \":\") {\n\t\t\t\treturn `(?<${name}>[^/]+)`\n\t\t\t} else {\n\t\t\t\treturn esc2 || `\\\\${esc1 || \"\\\\\"}`\n\t\t\t}\n\t\t}\n\t)}$`, \"u\")\n\tcache.set(pattern, re)\n\tre.r = rest\n\tre.p = new URLSearchParams(index < 0 ? \"\" : pattern.slice(index, hashIndex < 0 ? undefined : hashIndex))\n\treturn re\n}\n\n/** @param {{path: string, params: URLSearchParams}} route */\nvar match = ({path, params}, pattern) => {\n\tvar re = cache.get(pattern)\n\tif (!re) {\n\t\tre = /*@__NOINLINE__*/compile(pattern)\n\t}\n\n\tvar exec = re.exec(path)\n\tvar restIndex = re.r\n\tif (!exec) return\n\n\tfor (var [k, v] of re.p) {\n\t\tif (params.get(k) !== v) return\n\t}\n\n\t// Taking advantage of guaranteed insertion order and group iteration order here to reduce the\n\t// condition to a simple numeric comparison.\n\tfor (var k in exec.groups) {\n\t\tif (restIndex--) {\n\t\t\texec.groups[k] = decodeURIComponent(exec.groups[k])\n\t\t}\n\t}\n\n\treturn {...exec.groups}\n}\n\nexport {p, query, match}\n","/*\nHere's the intent.\n- Usage in model:\n\t- List\n\t- Get\n\t- Track\n\t- Delete\n\t- Replace (equivalent to delete + track)\n- Usage in view:\n\t- Iterate live handles\n\t- Release aborted live handles that no longer needed\n\nModels can do basic CRUD operations on the collection.\n- They can list what's currently there.\n- They can get a current value.\n- They can set the current value.\n- They can delete the current value.\n- They can replace the current value, deleting a value that's already there.\n\nIn the view, they use handles to abstract over the concept of a key. Duplicates are theoretically\npossible, so they should use the handle itself as the key for `m.keyed(...)`. It might look\nsomething like this:\n\n```js\nreturn m.keyed(t.live(), (handle) => (\n\t[handle.key, m(Entry, {\n\t\tname: handle.key,\n\t\tvalue: handle.value,\n\t\tremoved: handle.signal.aborted,\n\t\tonremovaltransitionended: () => handle.release(),\n\t})]\n))\n```\n\nThere used to be an in-renderer way to manage this transparently, but there's a couple big reasons\nwhy that was removed in favor of this:\n\n1. It's very complicated to get right. Like, the majority of the removal code was related to it. In\n   fact, this module is considerably smaller than the code that'd have to go into the renderer to\n   support it, as this isn't nearly as perf-sensitive as that.\n2. When you need to remove something asynchronously, there's multiple ways you may want to manage\n   transitions. You might want to stagger them. You might want to do them all at once. You might\n   want to clear some state and not other state. You might want to preserve some elements of a\n   sibling's state. Embedding it in the renderer would force an opinion on you, and in order to\n   work around it, you'd have to do something like this anyways.\n\nAs for the difference between `m.trackedList()` and `m.tracked()`, the first is for tracking lists\n(and is explained above), and `m.tracked()` is for single values (but uses `m.trackedList()`\ninternally to avoid a ton of code duplication).\n*/\n\nimport m from \"../core.js\"\n\nimport {checkCallback, noop} from \"../util.js\"\n\n/**\n * @template K, V\n * @typedef TrackedHandle\n *\n * @property {K} key\n * @property {V} value\n * @property {AbortSignal} signal\n * @property {() => void} release\n * @property {() => void} remove\n */\n\n/**\n * @template K, V\n * @typedef Tracked\n *\n * @property {() => Array<TrackedHandle<K, V>>} live\n * @property {() => Array<[K, V]>} list\n * @property {(key: K) => boolean} has\n * @property {(key: K) => undefined | V} get\n * @property {(key: K, value: V) => void} set\n * @property {(key: K, value: V) => void} replace\n * @property {(key: K) => boolean} delete\n */\n\nvar trackedState = (redraw) => {\n\tcheckCallback(redraw, false, \"redraw\")\n\t/** @type {Map<K, AbortController & TrackedHandle<K, V>>} */\n\tvar state = new Map()\n\tvar removed = new WeakSet()\n\t/** @type {Set<TrackedHandle<K, V>>} */ var live = new Set()\n\n\t/** @param {null | AbortController & TrackedHandle<K, V>} prev */\n\tvar abort = (prev) => {\n\t\ttry {\n\t\t\tif (prev) {\n\t\t\t\tif (removed.has(prev)) {\n\t\t\t\t\tlive.delete(prev)\n\t\t\t\t} else {\n\t\t\t\t\tprev.abort()\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(e)\n\t\t}\n\t}\n\n\t/** @param {K} k */\n\tvar remove = (k, r) => {\n\t\tvar prev = state.get(k)\n\t\tvar result = state.delete(k)\n\t\tabort(prev)\n\t\tif (r) redraw()\n\t\treturn result\n\t}\n\n\t/**\n\t * @param {K} k\n\t * @param {V} v\n\t * @param {number} bits\n\t * Bit 1 forcibly releases the old handle, and bit 2 causes an update notification to be sent\n\t * (something that's unwanted during initialization).\n\t */\n\tvar setHandle = (k, v, bits) => {\n\t\tvar prev = state.get(k)\n\t\t// Note: it extending `AbortController` is an implementation detail. It exposing a `signal`\n\t\t// property is *not*.\n\t\tvar handle = /** @type {AbortController & TrackedHandle<K, V>} */ (new AbortController())\n\t\thandle.key = k\n\t\thandle.value = v\n\t\thandle.release = (ev) => {\n\t\t\tif (ev) m.capture(ev)\n\t\t\tif (!handle) return\n\t\t\tif (state.get(handle.key) === handle) {\n\t\t\t\tremoved.add(handle)\n\t\t\t\thandle = null\n\t\t\t} else if (live.delete(handle)) {\n\t\t\t\tredraw()\n\t\t\t}\n\t\t}\n\t\thandle.remove = (ev) => {\n\t\t\tif (ev) m.capture(ev)\n\t\t\tremove(handle.key, 0)\n\t\t}\n\t\tstate.set(k, handle)\n\t\tlive.add(handle)\n\t\t// eslint-disable-next-line no-bitwise\n\t\tif (bits & 1) live.delete(prev)\n\t\tabort(prev)\n\t\t// eslint-disable-next-line no-bitwise\n\t\tif (bits & 2) redraw()\n\t}\n\n\treturn {s: state, l: live, h: setHandle, r: remove}\n}\n\n/**\n * @template K, V\n * @param {Iterable<[K, V]>} [initial]\n * @param {() => void} redraw\n * @returns {TrackedList<K, V>}\n */\nvar trackedList = (redraw, initial) => {\n\tvar {s: state, l: live, h: setHandle, r: remove} = trackedState(redraw)\n\n\tfor (var [k, v] of initial || []) setHandle(k, v, 1)\n\n\treturn {\n\t\tlive: () => [...live],\n\t\tlist: () => Array.from(state.values(), (h) => [h.key, h.value]),\n\t\thas: (k) => state.has(k),\n\t\tget: (k) => (k = state.get(k)) && k.value,\n\t\tset: (k, v) => setHandle(k, v, 3),\n\t\treplace: (k, v) => setHandle(k, v, 2),\n\t\tdelete: (k) => remove(k, 1),\n\t\tforget: (k) => (k = state.get(k)) && k.release(),\n\t}\n}\n\nvar tracked = (redraw) => {\n\tvar {l: live, h: setHandle, r: remove} = trackedState(redraw)\n\tvar initial = noop\n\tvar id = -1\n\treturn (state) => {\n\t\tif (!Object.is(initial, initial = state)) {\n\t\t\tremove(id++, 0)\n\t\t\tsetHandle(id, state, 1)\n\t\t}\n\t\treturn [...live]\n\t}\n}\n\nexport {tracked, trackedList}\n","import m from \"../core.js\"\n\nimport {checkCallback, invokeRedrawable} from \"../util.js\"\n\nfunction Init({f}, old) {\n\tif (old) return m.retain()\n\tvar ctrl = new AbortController()\n\tqueueMicrotask(() => invokeRedrawable(this.redraw, f, undefined, ctrl.signal))\n\treturn m.remove(() => ctrl.abort())\n}\n\nvar init = (f) => m(Init, {f: checkCallback(f)})\n\nexport {init as default}\n","import m from \"../core.js\"\n\nimport {debouncer, throttler} from \"../std/rate-limit.js\"\nimport {link, route} from \"../std/router.js\"\nimport {match, p, query} from \"../std/path-query.js\"\nimport {tracked, trackedList} from \"../std/tracked.js\"\nimport fetch from \"../std/fetch.js\"\nimport init from \"../std/init.js\"\nimport lazy from \"../std/lazy.js\"\n\nm.route = route\nm.link = link\nm.p = p\nm.query = query\nm.match = match\nm.fetch = fetch\nm.lazy = lazy\nm.init = init\nm.tracked = tracked\nm.trackedList = trackedList\nm.throttler = throttler\nm.debouncer = debouncer\n\nexport default m\n","/* global fetch */\n\nimport {checkCallback} from \"../util.js\"\n\nvar mfetch = async (url, opts = {}) => {\n\tcheckCallback(opts.onprogress, true, \"opts.onprogress\")\n\tcheckCallback(opts.extract, true, \"opts.extract\")\n\n\ttry {\n\t\tvar response = await fetch(url, opts)\n\n\t\tif (opts.onprogress && response.body) {\n\t\t\tvar reader = response.body.getReader()\n\t\t\tvar rawLength = response.headers.get(\"content-length\") || \"\"\n\t\t\t// This is explicit coercion, but ESLint is frequently too dumb to detect it correctly.\n\t\t\t// Another example: https://github.com/eslint/eslint/issues/14623\n\t\t\t// eslint-disable-next-line no-implicit-coercion\n\t\t\tvar total = (/^\\d+$/).test(rawLength) ? +rawLength : -1\n\t\t\tvar current = 0\n\n\t\t\tresponse = new Response(new ReadableStream({\n\t\t\t\ttype: \"bytes\",\n\t\t\t\tstart: (ctrl) => reader || ctrl.close(),\n\t\t\t\tcancel: (reason) => reader.cancel(reason),\n\t\t\t\tasync pull(ctrl) {\n\t\t\t\t\tvar result = await reader.read()\n\t\t\t\t\tif (result.done) {\n\t\t\t\t\t\tctrl.close()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrent += result.value.length\n\t\t\t\t\t\tctrl.enqueue(result.value)\n\t\t\t\t\t\topts.onprogress(current, total)\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t}), response)\n\t\t}\n\n\t\tif (response.ok) {\n\t\t\tif (opts.extract) {\n\t\t\t\treturn await opts.extract(response)\n\t\t\t}\n\n\t\t\tswitch (opts.responseType || \"json\") {\n\t\t\t\tcase \"json\": return await response.json()\n\t\t\t\tcase \"formdata\": return await response.formData()\n\t\t\t\tcase \"arraybuffer\": return await response.arrayBuffer()\n\t\t\t\tcase \"blob\": return await response.blob()\n\t\t\t\tcase \"text\": return await response.text()\n\t\t\t\tcase \"document\":\n\t\t\t\t\t// eslint-disable-next-line no-undef\n\t\t\t\t\treturn new DOMParser()\n\t\t\t\t\t\t.parseFromString(await response.text(), response.headers.get(\"content-type\") || \"text/html\")\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new TypeError(`Unknown response type: ${opts.responseType}`)\n\t\t\t}\n\t\t}\n\n\t\tvar message = (await response.text()) || response.statusText\n\t} catch (e) {\n\t\tvar cause = e\n\t\tvar message = e.message\n\t}\n\n\tvar e = new Error(message)\n\te.status = response ? response.status : 0\n\te.response = response\n\te.cause = cause\n\tthrow e\n}\n\nexport {mfetch as default}\n","import m from \"../core.js\"\n\nimport {checkCallback, noop} from \"../util.js\"\n\nvar lazy = (opts) => {\n\tcheckCallback(opts.fetch, false, \"opts.fetch\")\n\tcheckCallback(opts.pending, true, \"opts.pending\")\n\tcheckCallback(opts.error, true, \"opts.error\")\n\n\t// Capture the error here so stack traces make more sense\n\tvar error = new ReferenceError(\"Component not found\")\n\tvar redraws = new Set()\n\tvar Comp = function () {\n\t\tredraws.add(checkCallback(this.redraw, false, \"context.redraw\"))\n\t\treturn opts.pending && opts.pending()\n\t}\n\tvar init = async () => {\n\t\tinit = noop\n\t\ttry {\n\t\t\tComp = await opts.fetch()\n\t\t\tif (typeof Comp !== \"function\") {\n\t\t\t\tComp = Comp.default\n\t\t\t\tif (typeof Comp !== \"function\") throw error\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(e)\n\t\t\tComp = () => opts.error && opts.error(e)\n\t\t}\n\t\tvar r = redraws\n\t\tredraws = null\n\t\tfor (var f of r) f()\n\t}\n\n\treturn (attrs) => {\n\t\tinit()\n\t\treturn m(Comp, attrs)\n\t}\n}\n\nexport {lazy as default}\n","/* global module: false, window: false */\nimport m from \"./mithril.esm.js\"\n\nif (typeof module !== \"undefined\") module.exports = m\nelse window.m = m\n"],"names":["hasOwn","hasOwnProperty","invokeRedrawable","async","redraw","fn","thisValue","args","Reflect","apply","then","checkCallback","callback","allowNull","label","TypeError","noop","TYPE_MASK","FLAG_IS_FILE_INPUT","Vnode","mask","tag","attrs","children","m","t","a","c","s","d","selectorParser","selectorUnescape","selectorCache","Map","compileSelector","selector","match","className","classes","hasAttrs","exec","type","value","id","push","attrValue","replace","length","join","state","set","start","Error","Fragment","Array","isArray","arguments","slice","hasClassName","call","dynamicClass","class","get","original","i","normalize","TYPE_RETAIN","TYPE_FRAGMENT","TYPE_KEYED","TYPE_TEXT","TYPE_ELEMENT","TYPE_COMPONENT","TYPE_LAYOUT","TYPE_REMOVE","TYPE_SET_CONTEXT","TYPE_USE","TYPE_INLINE","capture","ev","preventDefault","stopPropagation","retain","inline","view","layout","remove","keyed","values","map","has","String","entries","resolveSpecialFragment","use","deps","node","currentHooks","currentRedraw","currentParent","currentRefNode","currentNamespace","currentDocument","currentContext","currentRemoveOnThrow","resolved","xlinkNs","htmlNs","nameSpace","svg","math","insertAfterCurrentRefNode","child","after","prepend","moveToPosition","vnode","forEach","updateFragment","old","newLength","oldLength","commonLength","updateNode","e","removeNodeDispatch","console","error","updateNodeDispatch","emptyObject","handleAttributeError","force","removeElement","removeFragment","removeKeyed","p","removeNode","removeInstance","added","n","k","prev","delete","createTextNode","nodeValue","element","oldAttrs","prevParent","prevRefNode","prevNamespace","entry","customTag","includes","is","ns","xmlns","opts","createElementNS","createElement","FLAG_HTML_ELEMENT","toUpperCase","setAttribute","namespaceURI","key","setAttr","normalized","getStyleKey","selectedIndex","getPropKey","tree","oldInstance","rendered","_","descs","Object","getOwnPropertyDescriptors","ownKeys","enumerable","undefined","prevContext","freeze","create","some","b","host","setStyle","style","add","propName","preferSetter","charCodeAt","propValue","oldValue","setProperty","removeProperty","newValue","forceSetAttribute","forceTryProperty","skipValueDiff","pair1","EventDict","addEventListener","removeEventListener","pair2","setAttributeNS","removeAttributeNS","activeElement","active","parentNode","removeAttribute","handleEvent","this","currentTarget","currentlyRendering","render","dom","removeOnThrow","root","contains","ownerDocument","namespace","prevHooks","prevRedraw","prevDocument","prevRemoveOnThrow","hooks","vnodes","textContent","focus","pop","mount","window","defaultView","unschedule","cancelAnimationFrame","requestAnimationFrame","sync","Mount","validateDelay","delay","Number","isFinite","RangeError","rateLimiterImpl","isThrottler","closed","timer","resolveNext","rateLimiter","ignoreLeading","Promise","resolve","clearTimeout","performance","now","setTimeout","update","newDelay","dispose","Route","prefix","mustReplace","currentParsedHref","currentRoute","href","updateRouteWithHref","url","URL","urlPath","pathname","search","hash","decodedPrefix","index","indexOf","encodeURI","parsedUrl","path","decodeURI","params","searchParams","current","updateRoute","location","queueMicrotask","history","v","route","Link","setRoute","listener","defaultPrevented","button","which","target","ctrlKey","metaKey","shiftKey","altKey","h","o","toString","invalidMatchTemplate","matcherCompile","serializeQueryValue","pq","result","proto","getPrototypeOf","prototype","sep","encodeURIComponent","serializeQueryParams","exclude","cache","compile","pattern","test","SyntaxError","rest","queryIndex","hashIndex","re","RegExp","name","esc1","esc2","r","URLSearchParams","trackedState","removed","WeakSet","live","Set","abort","l","bits","handle","AbortController","release","Init","f","ctrl","signal","link","template","inTemplate","ch","charAt","VAR_NEXT","segment","newHashIndex","newQueryIndex","query","restIndex","groups","decodeURIComponent","fetch","onprogress","extract","response","body","reader","getReader","rawLength","headers","total","Response","ReadableStream","close","cancel","reason","pull","read","done","enqueue","ok","responseType","json","formData","arrayBuffer","blob","text","DOMParser","parseFromString","message","statusText","cause","status","lazy","pending","ReferenceError","redraws","Comp","init","default","tracked","setHandle","initial","trackedList","list","from","forget","throttler","debouncer","module","exports"],"mappings":"yBAAO,IAAIA,EAAS,CAAE,EAACC,eAEZC,EAAmBC,MAAOC,EAAQC,EAAIC,KAAcC,KAC9D,GAAkB,mBAAPF,EAAmB,CAE7B,GAAkB,iBADlBC,EAAYE,QAAQC,MAAMJ,EAAIC,EAAWC,IACR,OACjC,GAAID,GAAuC,mBAAnBA,EAAUI,MAA6C,sBAAfJ,EAA8B,OAC9FF,GACA,GAGSO,EAAgB,CAACC,EAAUC,EAAWC,EAAQ,cACxD,GAAID,GAAyB,MAAZD,GAAwC,mBAAbA,EAC3C,OAAOA,EAGR,MAAM,IAAIG,UAAU,KAAKD,yBAA6BD,EAAY,gBAAkB,MAAK,EAG/EG,EAAO,OC6GdC,EAAY,GAsBZC,EAAqB,KAIrBC,EAAQ,CAACC,EAAMC,EAAKC,EAAOC,KAAc,CAC5CC,EAAGJ,EACHK,EAAGJ,EACHK,EAAGJ,EACHK,EAAGJ,EACHK,EAAG,KACHC,EAAG,OAGAC,EAAiB,+EACjBC,EAAmB,cACnBC,EAA8B,IAAIC,IAElCC,EAAmBC,IAGtB,IAFA,IAAIC,EAA8CC,EAAvChB,EAAM,MAAOiB,EAAU,GAAIhB,EAAQ,CAAE,EAAaiB,GAAW,EAEjEH,EAAQN,EAAeU,KAAKL,IAAW,CAC7C,IAAIM,EAAOL,EAAM,GAAIM,EAAQN,EAAM,GACnC,GAAa,KAATK,GAAyB,KAAVC,EAClBrB,EAAMqB,OAGN,GADAH,GAAW,EACE,MAATE,EACHnB,EAAMqB,GAAKD,OACL,GAAa,MAATD,EACVH,EAAQM,KAAKF,QACP,GAAoB,MAAhBN,EAAM,GAAG,GAAY,CAC/B,IAAIS,EAAYT,EAAM,GAClBS,IAAWA,EAAYA,EAAUC,QAAQf,EAAkB,OAC9C,UAAbK,EAAM,IAA+B,cAAbA,EAAM,GAAoBE,EAAQM,KAAKC,GAC9DvB,EAAMc,EAAM,IAAmB,MAAbS,GAAqBA,CAC5C,CAEF,CAEGP,EAAQS,OAAS,IACpBV,EAAYC,EAAQU,KAAK,MAG1B,IAAIC,EAAQ,CAACxB,EAAGJ,EAAKK,EAAGa,EAAWjB,EAAQ,KAAMK,EAAGU,GAEpD,OADAL,EAAckB,IAAIf,EAAUc,GACrBA,GAWJzB,EAAI,SAAUW,EAAUb,GAC3B,IAEIC,EAFAkB,EA1Ec,EA2EdU,EAAQ,EAGZ,GAAwB,iBAAbhB,EAAuB,CACjC,GAAwB,mBAAbA,EACV,MAAM,IAAIiB,MAAM,wDAEjBX,EAAON,IAAaX,EAAE6B,SArFJ,EAIC,CAkFnB,CAYD,GATa,MAAT/B,GAAkC,iBAAVA,GAAyC,iBAAZA,EAAME,IAAmB8B,MAAMC,QAAQjC,IAC/F6B,EAAQ,EACJK,UAAUT,OAAS,GAAKzB,GAASgC,MAAMC,QAAQjC,EAAMC,YACxDA,EAAWD,EAAMC,SAASkC,UAG3BnC,EAAQ,KAGO,MAAZC,EACH,GAAIiC,UAAUT,SAAWI,EAAQ,GAAKG,MAAMC,QAAQC,UAAUL,IAC7D5B,EAAWiC,UAAUL,GAAOM,aAG5B,IADAlC,EAAW,GACJ4B,EAAQK,UAAUT,QAAQxB,EAASqB,KAAKY,UAAUL,MAQ3D,GA5GkB,IA4GdV,EAAuB,CAC1BnB,EAAQA,GAAS,CAAE,EACnB,IAAIoC,EAAe1D,EAAO2D,KAAKrC,EAAO,aAClCsC,EAAeF,EAAepC,EAAMe,UAAYf,EAAMuC,MACtDZ,EAAQjB,EAAc8B,IAAI3B,GAC1B4B,EAAWzC,EAEF,MAAT2B,IACHA,EAAyBf,EAAgBC,IAG3B,MAAXc,EAAMvB,IACTJ,EAAQ,IAAI2B,EAAMvB,KAAMJ,IAGL,MAAhBsC,GAAmC,MAAXX,EAAMtB,IAC7BL,IAAUyC,IAAUzC,EAAQ,IAAIA,IACpCA,EAAMuC,MAAwB,MAAhBD,EACA,MAAXX,EAAMtB,EAAY,GAAGsB,EAAMtB,KAAKiC,IAAiBA,EACjDX,EAAMtB,EACL+B,IAAcpC,EAAMe,UAAY,MAErC,CAED,GAnIoB,IAmIhBI,EACHnB,EAAQ,CAACC,cAAaD,GACtBC,EAAW,UAEX,IAAK,IAAIyC,EAAI,EAAGA,EAAIzC,EAASwB,OAAQiB,IAAKzC,EAASyC,GAAKxC,EAAEyC,UAAU1C,EAASyC,IAG9E,OAAO7C,EAAMsB,EAAMN,EAAUb,EAAOC,EACrC,EAEAC,EAAEP,UAAYA,EACdO,EAAE0C,aAnJgB,EAoJlB1C,EAAE2C,cAnJkB,EAoJpB3C,EAAE4C,WAnJe,EAoJjB5C,EAAE6C,UAnJc,EAoJhB7C,EAAE8C,aAnJiB,EAoJnB9C,EAAE+C,eAnJmB,EAoJrB/C,EAAEgD,YAnJgB,EAoJlBhD,EAAEiD,YAnJgB,EAoJlBjD,EAAEkD,iBAnJqB,EAoJvBlD,EAAEmD,SAnJa,EAoJfnD,EAAEoD,YAnJgB,EAuJlBpD,EAAEqD,QAAWC,IACZA,EAAGC,iBACHD,EAAGE,kBACI,eAGRxD,EAAEyD,OAAS,IAAM9D,GAvKC,EAuKkB,KAAM,KAAM,MAChDK,EAAE0D,OAAUC,GAAShE,EA9JH,EA8JsB,KAAMR,EAAcwE,GAAM,EAAO,QAAS,MAClF3D,EAAE4D,OAAUxE,GAAaO,EAnKP,EAmK0B,KAAMR,EAAcC,GAAW,MAC3EY,EAAE6D,OAAUzE,GAAaO,EAnKP,EAmK0B,KAAMR,EAAcC,GAAW,MAE3EY,EAAE6B,SAAY/B,GAAUA,EAAMC,SAE9BC,EAAE8D,MAAQ,CAACC,EAAQJ,KAClBA,EAAOxE,EAAcwE,GAAM,EAAM,QACjC,IAAIK,EAAM,IAAIvD,IACd,IAAK,IAAIS,KAAS6C,EAEjB,GADoB,mBAATJ,IAAqBzC,EAAQyC,EAAKzC,IAChC,MAATA,GAAkC,kBAAVA,EAAqB,CAChD,IAAKY,MAAMC,QAAQb,IAAUA,EAAMK,OAAS,EAC3C,MAAM,IAAIhC,UAAU,iDAErB,GAAIyE,EAAIC,IAAI/C,EAAM,IAEjB,MAAM,IAAI3B,UAAU,2BAA2B2E,OAAOhD,EAAM,OAE7D8C,EAAItC,IAAIR,EAAM,GAAIlB,EAAEyC,UAAUvB,EAAM,IACpC,CAEF,OAAOvB,EA5LS,EA4LS,KAAMqE,EAAK,KAAI,EAGzChE,EAAE0B,IAAM,CAACyC,KAAYpE,IAAaqE,EAzLX,EAyLoDD,KAAYpE,GACvFC,EAAEqE,IAAM,CAACC,KAASvE,IAAaqE,EAzLhB,EAyLiD,IAAIE,MAAUvE,GAE9EC,EAAEyC,UAAa8B,GACF,MAARA,GAAgC,kBAATA,EAA2B,KAClC,iBAATA,EAA0B5E,EAnMtB,EAmMuC,KAAMuE,OAAOK,GAAO,MACtEzC,MAAMC,QAAQwC,GAAc5E,EAtMb,EAsMkC,KAAM,KAAM4E,EAAKP,IAAIhE,EAAEyC,YACrE8B,EAGR,IAaIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EApBAX,EAAyB,CAACnD,EAAMnB,KAAUC,KAE7C,IADA,IAAIiF,EAA+B,IAApBjF,EAASwB,QAAgBO,MAAMC,QAAQhC,EAAS,IAAM,IAAIA,EAAS,IAAM,IAAIA,GACnFyC,EAAI,EAAGA,EAAIwC,EAASzD,OAAQiB,IAAKwC,EAASxC,GAAKxC,EAAEyC,UAAUuC,EAASxC,IAC7E,OAAO7C,EAAMsB,EAAM,KAAMnB,EAAOkF,EAAQ,EAGrCC,EAAU,+BACVC,EAAS,+BACTC,EAAY,CACfC,IAAK,6BACLC,KAAM,sCAYHC,EAA6BC,IAC5BZ,EACHA,EAAea,MAAMb,EAAiBY,GAEtCb,EAAce,QAAQd,EAAiBY,EACvC,EAIEG,EAAkBC,IAErB,IADA,IAAI1E,EACG,IAA2C,IAAMA,EAAO0E,EAAM3F,EAAIP,IACxE,KAAMkG,EAAQA,EAAMxF,GAAI,OAErB,IAA+D,GAAKc,EACvE0E,EAAMxF,EAAEyF,QAAQF,GACN,GAAuC,GAAKzE,EACtDqE,EAA0BK,EAAMtF,GAhPjB,IAiPLY,GACV0E,EAAMzF,EAAE0F,QAAQF,EAChB,EAGEG,EAAiB,CAACC,EAAKH,KAQ1B,IAAII,EAAqB,MAATJ,EAAgBA,EAAMxF,EAAEoB,OAAS,EAC7CyE,EAAmB,MAAPF,EAAcA,EAAI3F,EAAEoB,OAAS,EACzC0E,EAAeD,EAAYD,EAAYC,EAAYD,EACvD,IACC,IAAK,IAAIvD,EAAI,EAAGA,EAAIyD,EAAczD,IAAK0D,EAAWJ,EAAI3F,EAAEqC,GAAImD,EAAMxF,EAAEqC,IACpE,IAASA,EAAIyD,EAAczD,EAAIuD,EAAWvD,IAAK0D,EAAW,KAAMP,EAAMxF,EAAEqC,GACxE,CAAC,MAAO2D,GAER,IADAF,EAAezD,EACNA,EAAI,EAAGA,EAAIyD,EAAczD,IAAK0D,EAAWP,EAAMxF,EAAEqC,GAAI,MAC9D,IAASA,EAAIyD,EAAczD,EAAIwD,EAAWxD,IAAK0D,EAAWJ,EAAI3F,EAAEqC,GAAI,MACpE,MAAM2D,CACN,CACD,IAAS3D,EAAIyD,EAAczD,EAAIwD,EAAWxD,IAAK0D,EAAWJ,EAAI3F,EAAEqC,GAAI,KAAK,EAmEtE0D,EAAa,CAACJ,EAAKH,KAStB,GAAIG,IAAQH,EAAZ,CAEA,IAAI1E,EACJ,GAAW,MAAP6E,EAAa,CAChB,GAAa,MAATH,EAAe,OACnB,GAAIA,EAAM3F,EAAI,EAAG,OACjB,GAjVc,GAiVV2F,EAAM3F,EACT,MAAM,IAAIT,UAAU,6BAErB0B,EAAO0E,EAAM3F,EAAIP,EACjBkG,EAAM3F,GArVQ,EAsVhB,KAAQ,CAGN,GAFAiB,EAAO6E,EAAI9F,EAAIP,EAEF,MAATkG,EAAe,CAClB,IACe,KAAV1E,GAAoCmF,EAAmBnF,GAAM6E,EACjE,CAAC,MAAOK,GACRE,QAAQC,MAAMH,EACd,CACD,MACA,CAED,GAAIR,EAAM3F,EAAI,EAWb,OANA2F,EAAM3F,EAAI8F,EAAI9F,EACd2F,EAAM1F,EAAI6F,EAAI7F,EACd0F,EAAMvF,EAAI0F,EAAI1F,EACduF,EAAMzF,EAAI4F,EAAI5F,EACdyF,EAAMxF,EAAI2F,EAAI3F,OACdwF,EAAMtF,EAAIyF,EAAIzF,GAIf,GAhXc,GAgXVsF,EAAM3F,EACT,MAAM,IAAIT,UAAU,6BAGjB0B,KAAU0E,EAAM3F,EAAIP,IAAckG,EAAM1F,IAAM6F,EAAI7F,EACrD0F,EAAM3F,EAAI8F,EAAI9F,GAEdkG,EAAWJ,EAAK,MAChBA,EAAM,MAEP7E,EAAO0E,EAAM3F,EAAIP,CACjB,CAED,IACC8G,EAAmBtF,GAAM6E,EAAKH,EAC9B,CAAC,MAAOQ,GAER,MADAD,EAAWJ,EAAK,MACVK,CACN,CAvDkB,CAuDlB,EAYEK,EAAc,CAAE,EA0BhBC,EAAuB,CAACX,EAAKK,EAAGO,KACnC,GAAI3B,GAAwB2B,EAE3B,MADIZ,GAAKa,EAAcb,GACjBK,EAEPE,QAAQC,MAAMH,EAAE,EAmKbS,EAAkBd,GAAQD,EAAeC,EAAK,MAE9Ce,EAAef,GAAQA,EAAI5F,EAAE0F,QAASkB,GAAMZ,EAAWY,EAAG,OAE1DC,EAAcjB,IACjB,IACC,IAAKA,EAAIzF,EAAG,OACZyF,EAAIzF,EAAEwD,SACNiC,EAAIzF,EAAI,IACR,CAAC,MAAO8F,GACRE,QAAQC,MAAMH,EACd,GAGEQ,EAAiBb,IACpBiB,EAAWjB,GACXD,EAAeC,EAAK,KAAK,EAGtBkB,EAAkBlB,GAAQI,EAAWJ,EAAI3F,EAAG,MAG5CoG,EAAqB,CACxBV,EAtViB,CAACC,EAAKH,KAYvB,IAAIsB,EAAQ,EAGRX,EAAQ9F,EACZ,IAGCmF,EAAMzF,EAAE0F,QAAQ,CAACsB,EAAGC,KACnB,IAAIL,EAAW,MAAPhB,EAAcA,EAAI5F,EAAEoC,IAAI6E,GAAK,KACrC,GAAS,MAALL,EACHZ,EAAW,KAAMgB,OACX,CACN,IAAIE,EAAOzC,EACXe,EAAeoB,GACfnC,EAAiByC,EACjBlB,EAAWY,EAAGI,GAGdpB,EAAI5F,EAAEmH,OAAOF,EACb,CACDF,GAAO,GAERA,GAAS,CACT,CAAC,MAAOd,GACRG,EAAQH,CACR,CAGD,GAFW,MAAPL,GAAae,EAAYf,GAEzBQ,IAAU9F,EAAe,CAC5B,IAAK,IAAI0G,KAAKvB,EAAMzF,EAAE6D,SAAU,CAC/B,KAAMkD,EAAO,MACbf,EAAWgB,EAAG,KACd,CACD,MAAMZ,CACN,GAgGe,CAACR,EAAKH,KACX,MAAPG,EACHR,EAA0BK,EAAMtF,EAAIwE,EAAgByC,eAAe3B,EAAMzF,KAErE,GAAG4F,EAAI5F,KAAQ,GAAGyF,EAAMzF,MAAK4F,EAAIzF,EAAEkH,UAAY5B,EAAMzF,GACzDyF,EAAMtF,EAAIsE,EAAiBmB,EAAIzF,EAC/B,EAWkB,CAACyF,EAAKH,KACzB,IAKI6B,EAASC,EALTC,EAAahD,EACbiD,EAAchD,EACdiD,EAAgBhD,EAChBhF,EAAO+F,EAAM3F,EACbF,EAAQ6F,EAAMzF,EAGlB,GAAW,MAAP4F,EAAa,CAChB,IAAI+B,EAAQrH,EAAc8B,IAAIqD,EAAM1F,GAChCJ,EAAMgI,EAAQA,EAAM5H,EAAI0F,EAAM1F,EAC9B6H,EAAYjI,EAAIkI,SAAS,KACzBC,GAAMF,GAAahI,GAASA,EAAMkI,GAClCC,EAAKnI,GAASA,EAAMoI,OAAS/C,EAAUtF,IAAQ+H,EAC/CO,EAAOH,EAAK,CAACA,MAAM,KAEvBR,EACCS,EACGpD,EAAgBuD,gBAAgBH,EAAIpI,EAAKsI,GACzCtD,EAAgBwD,cAAcxI,EAAKsI,GAG7B,MAANF,IASHtC,EAAM3F,EAAIJ,GACToI,GAAMF,EACHQ,IAEO,WADNzI,EAAMA,EAAI0I,eACMD,IACR,WAARzI,EAAmByI,IACX,WAARzI,EAAmByI,KACX,aAARzI,EAAqByI,KApdL,GA0djBN,GAAIR,EAAQgB,aAAa,KAAMR,IAGpCtD,EAAgB8C,EAChB5C,EAAmBqD,CACrB,MACEtC,EAAMvF,EAAI0F,EAAI1F,EACdqH,EAAW3B,EAAI5F,GACf0E,GAAoBF,EAAgB8C,EAAU7B,EAAMtF,EAAIyF,EAAIzF,GAAGoI,gBACtCvD,IAAQN,EAAmB,MAGrDD,EAAiB,KAEjB,IACC,GAAgB,MAAZ8C,GAAoBA,IAAa3H,EACpC,MAAM,IAAI8B,MAAM,uCAGjB,GAAa,MAAT9B,EAQH,IAAK,IAAI4I,KAnfa,IA8elB9I,GAA2C,MAAdE,EAAMmB,OACnB,SAAfnB,EAAMmB,OAAiBrB,GAAQF,GACnC8H,EAAQvG,KAAOnB,EAAMmB,MAGNnB,EACf6I,EAAQhD,EAAO6B,EAAS5H,EAAM8I,EAAKjB,EAAU3H,GAI/C,IAAK,IAAI4I,KAAOjB,EAEfkB,EAAQhD,EAAO6B,EADf5H,GA5fkB,GA6fY8I,EAAKjB,EAAU3H,EAE9C,CAAC,MAAOqG,GACR,OAAOM,EAAqBX,EAAKK,GAAG,EACpC,CAID,GAFAN,EAAeC,EAAKH,GA/fK,IAigBrB/F,GAAqC,MAAPkG,EAAa,CAC9C,IAEC,IAAI8C,EAAaC,EAAY/I,EAAO,SAChC,UAAWA,IACK,OAAf8I,EACCpB,EAAQsB,eAAiB,IAC5BtB,EAAQtG,MAAQ,OAGbsG,EAAQsB,cAAgB,GAAKtB,EAAQtG,QAAU0H,KAClDpB,EAAQtG,MAAQ0H,GAInB,CAAC,MAAOzC,GACRM,EAAqBX,EAAKK,GAAG,EAC7B,CAED,IAGoB,QADfyC,EAAaG,EAAWjJ,EAAO,oBAElC0H,EAAQsB,cAAgBF,EAEzB,CAAC,MAAOzC,GACRM,EAAqBX,EAAKK,GAAG,EAC7B,CACD,CAEDzB,EAAgBgD,EAChB/C,EAAiBgD,EACjB/C,EAAmBgD,EAKR,MAAP9B,GACHR,EAA0BK,EAAMtF,EAAImH,GAGrC7C,EAAiB6C,CAAO,EAGH,CAAC1B,EAAKH,KAC3B,IACC,IACIqD,EAAMC,EAAaxB,EADnB3H,EAAQ6F,EAAMzF,EAElBgJ,EAAU,CACT,GAAW,MAAPpD,EACHkD,EAAOlD,EAAI1F,EACX6I,EAAcnD,EAAI3F,EAClBsH,EAAW3B,EAAI5F,OACT,GAAkF,mBAAtE8I,GAAQrD,EAAMvF,EAAIuF,EAAM1F,GAAGkC,KAAK2C,EAAgBhF,EAAO2H,IACzE,MAAMyB,EAEPF,GAAQrD,EAAMvF,EAAI4I,GAAM7G,KAAK2C,EAAgBhF,EAAO2H,EACpD,CACDvB,EAAW+C,EAAatD,EAAMxF,EAAIH,EAAEyC,UAAUuG,GAC9C,CAAC,MAAO7C,GACR,GAAIpB,EAAsB,MAAMoB,EAChCE,QAAQC,MAAMH,EACd,GA/LiB,CAACgD,EAAGxD,KACtBA,EAAMtF,EAAIqE,EACVF,EAAapD,KAAKuE,EAAM,EAGN,CAACwD,EAAGxD,KACtBA,EAAMtF,EAAIqE,CAAa,EAKR,CAACoB,EAAKH,KACrB,IAAIyD,EAAQC,OAAOC,0BAA0B3D,EAAMzF,GACnD,IAAK,IAAIwI,KAAO1J,QAAQuK,QAAQH,GAG1BA,EAAMV,GAAKc,WAEP,QAASJ,EAAMV,KAAMU,EAAMV,GAAKhH,SAAM+H,GAFnBL,EAAMV,GAAOlC,EAI1C,IAAIkD,EAAc5E,EAClBA,EAAiBuE,OAAOM,OAAON,OAAOO,OAAOF,EAAaN,IAC1DvD,EAAeC,EAAKH,GACpBb,EAAiB4E,CAAW,EA1Jb,CAAC5D,EAAKH,KAEb,MAAPG,GAA8B,IAAfA,EAAIvE,QACV,MAAToE,GAAkC,IAAjBA,EAAMpE,QAEtBoE,EAAMzF,EAAEqB,SAAWuE,EAAI5F,EAAEqB,SACzBoE,EAAMzF,EAAE2J,KAAK,CAACC,EAAGtH,KAAO6G,OAAOrB,GAAG8B,EAAGhE,EAAI5F,EAAEsC,OAG5CqD,EAAeC,EAAK,MACpBA,EAAM,MAEPD,EAAeC,EAAKH,EAAM,EAyTR,CAACG,EAAKH,KACxB,IACCO,EAAkB,MAAPJ,EAAcA,EAAI3F,EAAI,KAAMwF,EAAMxF,EAAIH,EAAEyC,UAAUkD,EAAMzF,EAAEiC,KAAK2C,EAAgBA,IAC1F,CAAC,MAAOqB,GACR,GAAIpB,EAAsB,MAAMoB,EAChCE,QAAQC,MAAMH,EACd,IAsCEC,EAAqB,CACxBQ,EACAC,EACAE,EACAJ,EACAK,EACAxH,EACCsG,GAAQtB,EAAapD,KAAK0E,GAC3Bc,EACAA,EACAI,GAoCG+B,EAAa,CAACgB,EAAMrB,KACvB,GAAY,MAARqB,GAAgBvL,EAAO2D,KAAK4H,EAAMrB,GAAM,CAC3C,IAAIxH,EAAQ6I,EAAKrB,GACjB,IAAc,IAAVxH,GAA4B,MAATA,EAAe,OAAOA,CAC7C,CACD,OAAO,MAGJ2H,EAAc,CAACkB,EAAMrB,KACxB,GAAY,MAARqB,GAAgBvL,EAAO2D,KAAK4H,EAAMrB,GAAM,CAC3C,IAAIxH,EAAQ6I,EAAKrB,GACjB,IAAc,IAAVxH,GAA4B,MAATA,EAAe,MAAO,GAAGA,GAChD,CACD,OAAO,MAGJ8I,EAAW,CAACC,EAAOnE,EAAK5E,EAAOgJ,KAClC,IAAK,IAAIC,KAAYjJ,EAAO,CAC3B,IAAIkJ,EAhDa,KAgDED,EAASE,WAAW,GACnCC,EAAYzB,EAAY3H,EAAOiJ,GACnC,GAAkB,OAAdG,EAAoB,CACvB,IAAIC,EAAW1B,EAAY/C,EAAKqE,GAC5BD,EACCI,IAAcC,IACbH,EACHH,EAAME,GAAYG,EAElBL,EAAMO,YAAYL,EAAUG,IAIb,OAAbC,IACCH,EACHH,EAAME,GAAY,GAElBF,EAAMQ,eAAeN,GAIxB,CACD,GA2BExB,EAAU,CAAChD,EAAO6B,EAAS5H,EAAM8I,EAAK5C,EAAKhG,KAC9C,IACC,IAAI4K,EAAW3B,EAAWjJ,EAAO4I,GAC7B6B,EAAWxB,EAAWjD,EAAK4C,GAE/B,GAxuBmB,GAwuBf9I,GAAsC,OAAb8K,EAAmB,OAEhDC,EAAmB,CAClBC,EAAkB,CACjBC,EAAe,CACd,GAAInC,EAAInH,OAAS,EAAG,CACnB,IAAIuJ,EAAQpC,EAAI2B,WAAW,GAAK3B,EAAI2B,WAAW,IAAM,GAErD,GAAmB,IAAf3B,EAAInH,QAAqB,UAALuJ,EACvB,OACM,GAAe,UAAXA,EAAiD,CAC3D,GAAIJ,IAAaH,EAAU,OAc3B,YAZwB,mBAAbG,GACc,mBAAbH,IACK,MAAX5E,EAAMvF,IAAWuF,EAAMvF,EAAI,IAAI2K,GACnCvD,EAAQwD,iBAAiBtC,EAAIzG,MAAM,GAAI0D,EAAMvF,IAG9CuF,EAAMvF,EAAE+I,EAAI1E,EACZkB,EAAMvF,EAAEsB,IAAIgH,EAAKgC,IACa,mBAAbH,IACjB/C,EAAQyD,oBAAoBvC,EAAIzG,MAAM,GAAI0D,EAAMvF,GAChDuF,EAAMvF,EAAEiH,OAAOqB,IAGvB,CAAa,GAAIA,EAAInH,OAAS,EAAG,CAC1B,IAAI2J,EAAQxC,EAAI2B,WAAW,GAAK3B,EAAI2B,WAAW,IAAM,GACrD,GACC3B,EAAInH,OAAS,GACF,UAAXuJ,GACW,UAAXI,GAC4C,UAA3CxC,EAAI2B,WAAW,GAAK3B,EAAI2B,WAAW,IAAM,IAQ1C,OANA3B,EAAMA,EAAIzG,MAAM,QACC,OAAbyI,EACHlD,EAAQ2D,eAAelG,EAASyD,EAAKgC,GAErClD,EAAQ4D,kBAAkBnG,EAASyD,IAG9B,GAAmB,IAAfA,EAAInH,OAAc,CAC5B,GACY,UAAXuJ,GACW,UAAXI,EACC,CACD,KAnxBgB,IAmxBVtL,GAA4B,MAAMiL,EACxC,GAAiB,OAAbH,EAAmB,MAAMC,EAC7B,MAAMC,CACf,CAAe,IAEK,UAAXE,aAAmDI,GACxC,UAAXJ,aAAmDI,GACxC,UAAXJ,aAAmDI,MA3xBlC,IA+xBXtL,GACL,MAAM+K,CAGhB,MAAc,GAAIjC,EAAInH,OAAS,EACvB,OAAQmH,GACP,IAAK,WACJ,OAED,IAAK,QACL,IAAK,YACL,IAAK,QACJ,GAAiB,OAAbgC,EAAmB,MAAMC,EAC7B,MAAMC,EAEP,IAAK,QACJ,GAhzBc,KAkzBJ,IAARhL,MACC8I,KAAOlB,GAET,MAGD,GAAiB,OAAbkD,EAAmB,CACtB,GAAQ,KAAJ9K,EACH,MAAM+K,EAEN,MAAMC,CAEP,CAED,KAAU,KAAJhL,GACL,MAID,GAAI4H,EAAQtG,SAAWwJ,EAAW,GAAGA,KAAa,CAGjD,GAAI9K,EAAOF,EAAoB,OAG/B,GAAQ,KAAJE,GACH,GAAI4H,IAAY3C,EAAgBwG,cAAe,YAE/C,GAAgB,MAAZd,IAAiC,IAAbA,EAAoB,MAE7C,CAED,GAAI3K,EAAOF,GAGO,KAAbgL,EAEH,YADArE,QAAQC,MAAM,gHAKhB,MAAMsE,EAEP,IAAK,QAqBJ,YApBIL,IAAaG,IAEO,OAAbA,EAEVlD,EAAQyC,MAAQ,GACc,iBAAbS,EAEjBlD,EAAQyC,MAAQS,EACO,OAAbH,GAAyC,iBAAbA,GAEtC/C,EAAQyC,MAAQ,GAEhBD,EAASxC,EAAQyC,MAAO,KAAMS,GAAU,KAIxCV,EAASxC,EAAQyC,MAAOM,EAAUG,GAAU,GAE5CV,EAASxC,EAAQyC,MAAOS,EAAUH,GAAU,MAI9C,IAAK,WACJ,IAAIe,EAASzG,EAAgBwG,cAC7B,GACC7D,IAAY8D,GAn3BG,KAo3Bf1L,GAA8B4H,EAAQ+D,aAAeD,EAErD,MAIF,IAAK,UACL,IAAK,gBACJ,MAAMT,EAGP,IAAK,QACL,IAAK,SAGJ,KAt4BgB,IAs4BVjL,GACL,MAAM+K,EAIV,CACD,CAED,GAAiB,OAAbD,GAAyC,iBAAbA,GAAyBH,IAAaG,EAAU,MAChF,CAGD,KAn5BoB,GAm5Bd9K,GACL,MAAM+K,CAEP,CAID,GAAIjC,KAAOlB,EAEV,YADAA,EAAQkB,GAAOgC,EAGhB,CAEgB,OAAbA,EACc,OAAbH,GAAmB/C,EAAQgE,gBAAgB9C,GAE/ClB,EAAQgB,aAAaE,GAAkB,IAAbgC,EAAoB,GAAKA,EAEpD,CAAC,MAAOvE,GACRM,EAAqBX,EAAKK,GAAG,EAC7B,GAYF,MAAM4E,UAAkBtK,IACvB,iBAAMgL,CAAYnI,GACjB5E,EAAiBgN,KAAKvC,EAAGuC,KAAKpJ,IAAI,KAAKgB,EAAGrC,QAASqC,EAAGqI,cAAerI,EACrE,EAGF,IAAIsI,EAAqB,GAEzB5L,EAAE6L,OAAS,CAACC,EAAKnG,GAAQ/G,SAAQmN,iBAAiB,MACjD,IAAKD,EACJ,MAAM,IAAIvM,UAAU,iDAKrB,IAAK,IAAIyM,KAFT7M,EAAcP,GAAQ,EAAM,UAEXgN,GAChB,GAAIE,EAAIG,SAASD,GAChB,MAAM,IAAIzM,UAAU,2DAItB,IAAI+L,EAASQ,EAAII,cAAcb,cAC3Bc,EAAYL,EAAIrD,aAEhB2D,EAAY5H,EACZ6H,EAAa5H,EACbiD,EAAahD,EACbiD,EAAchD,EACdiD,EAAgBhD,EAChB0H,EAAezH,EACf6E,EAAc5E,EACdyH,EAAoBxH,EACpByH,EAAQhI,EAAe,GAE3B,IAkBC,IAAK,IAAItE,EAACA,EAACG,EAAEA,KAjBbuL,EAAmBxK,KAAKsD,EAAgBoH,GACxCrH,EAAkC,mBAAX7F,EAAwBA,EAAS,KACxD+F,EAAiB,KACjBC,EAAmBuH,IAAcjH,EAAS,KAAOiH,EACjDtH,EAAkBiH,EAAII,cACtBpH,EAAiB,CAAClG,UAElBmG,IAAyBgH,EAGP,MAAdD,EAAIW,SAAgBX,EAAIY,YAAc,IAC1CxG,EAAW4F,EAAIW,OAAQ9G,EAAQ3F,EAAEyC,UAAUkD,IAC3CmG,EAAIW,OAAS9G,EAEC,MAAV2F,GAAkBzG,EAAgBwG,gBAAkBC,GAAkC,mBAAjBA,EAAOqB,OAC/ErB,EAAOqB,QAEWH,GAClB,IACCtM,EAAEG,EACF,CAAC,MAAO8F,GACRE,QAAQC,MAAMH,EACd,CAEJ,CAAW,QACT1B,EAAgB4H,EAChB7H,EAAe4H,EACf1H,EAAgBgD,EAChB/C,EAAiBgD,EACjB/C,EAAmBgD,EACnB/C,EAAkByH,EAClBxH,EAAiB4E,EACjB3E,EAAuBwH,EACvBX,EAAmBgB,KACnB,GAGF5M,EAAE6M,MAAQ,CAACb,EAAMrI,KAChB,IAAKqI,EAAM,MAAM,IAAIzM,UAAU,2BAE/B,GAAoB,mBAAToE,EACV,MAAM,IAAIpE,UAAU,2BAGrB,IAAIuN,EAASd,EAAKE,cAAca,YAC5B5L,EAAK,EACL6L,EAAa,KACZ7L,IACH2L,EAAOG,qBAAqB9L,GAC5BA,EAAK,EACL,EAEEvC,EAAS,KAAauC,IAAIA,EAAK2L,EAAOI,sBAAsBtO,EAAOuO,QAEnEC,EAAQ,CAACjE,EAAGrD,IAAQ,CAAC9F,EAAE6D,OAAOmJ,GAAarJ,EAAKxB,KAAK2C,GAAiBgB,IAS1E,OARAlH,EAAOuO,KAAO,KACbH,IACAhN,EAAE6L,OAAOG,EAAMhM,EAAEoN,GAAQ,CAACxO,UAAQ,EAGnCoB,EAAE6L,OAAOG,EAAM,MACfpN,EAAOuO,OAEAvO,GCjqCR,IAAIyO,EAAiBC,IACpB,IAAKC,OAAOC,SAASF,IAAUA,GAAS,EACvC,MAAM,IAAIG,WAAW,0CACrB,EAGEC,EAAkB,CAACJ,EAAQ,IAAKK,KACnCN,EAAcC,GAEd,IAAIM,GAAS,EACTjM,EAAQ,EACRkM,EAAQ,EACRC,EAActO,EAEdJ,EAAW,KACdyO,OAAQpE,EACRqE,GAAY,GACZA,EAActO,CAAI,EAGfuO,EAAcpP,MAAOqP,IACxB,GAAIJ,EACH,OAAO,EAMR,GAHAE,GAAY,GACZA,EAActO,EAEVqO,EAAO,CACV,GAAIF,EACH,OAAO,IAAIM,QAASC,GAAYJ,EAAcI,GAG/CC,aAAaN,GACbG,GAAgB,CAChB,CAKD,OAHArM,EAAQyM,YAAYC,MACpBR,EAAQS,WAAWlP,EAAUkO,GAExBU,EAIE,IAAIC,QAASC,GAAYJ,EAAcI,QAJ9C,CAIqD,EAsBtD,OAnBAH,EAAYQ,OAAUC,IACrBnB,EAAcmB,GACdlB,EAAQkB,EAEJZ,GACAC,IACHM,aAAaN,GACbA,EAAQS,WAAWlP,EAAWuC,EAAQyM,YAAYC,MAASf,GAC3D,EAGFS,EAAYU,QAAU,KACjBb,IACJA,GAAS,EACTO,aAAaN,GACbC,GAAY,GACZA,EAActO,EAAI,EAGZuO,GCjEJW,EAAQ,UAAW5H,EAAG6H,IACzB,IACIC,EAAahQ,EAAQiQ,EACrBC,EAFAC,EAAOrD,KAAKqD,KAIZC,EAAsB,KACzB,IAAIC,EAAM,IAAIC,IAAIH,GACdI,EAAUF,EAAIG,SAAWH,EAAII,OAASJ,EAAIK,KAC1CC,EAAgBZ,EAChBa,EAAQL,EAAQM,QAAQF,GACxBC,EAAQ,IAAGA,EAAQL,EAAQM,QAAQF,EAAgBG,UAAUH,KAC7DC,GAAS,IAAGL,EAAUA,EAAQlN,MAAMuN,EAAQD,EAAchO,SAC3C,MAAf4N,EAAQ,KAAYA,EAAU,IAAIA,KAEtC,IAAIQ,EAAY,IAAIT,IAAIC,EAASJ,GAC7Ba,EAAOC,UAAUF,EAAUP,UAU/B,OATAR,GAAc,EACdE,EAAe,CACdH,SACAiB,OACAE,OAAQH,EAAUI,aAClBC,QAASJ,EAAOD,EAAUN,OAASM,EAAUL,KAC7C5N,MACAd,SAEMiO,EAAoBc,EAAUZ,MAGlCkB,EAAc,KACblB,IAASjC,OAAOoD,SAASnB,OAC7BA,EAAOjC,OAAOoD,SAASnB,KACnBF,IAAsBG,KAAuBpQ,IAAQ,EAGtD8C,EAAM,CAACkO,GAAOtO,UAASG,SAAS,MAC/BmN,IAAatN,GAAU,GAC3BsN,GAAc,EACduB,eAAeF,GACfrR,IACsB,iBAAXkO,QACVA,OAAOsD,QAAQ9O,EAAU,eAAiB,aAAaG,EAAO,GAAIkN,EAASiB,EAC3E,EAGEhP,EAASgP,GAAS5P,EAAEY,MAAMkO,EAAcc,GAE5C,GAAKb,GAME,GAAoB,iBAATA,EACjB,MAAM,IAAIxP,UAAU,wDAPV,CACV,GAAsB,iBAAXuN,OACV,MAAM,IAAIvN,UAAU,uCAErBwP,EAAOjC,OAAOoD,SAASnB,KACvBjC,OAAO9B,iBAAiB,WAAYiF,EACtC,CAMC,OAFAjB,IAEO,UAAWqB,EAAG1M,IAGpB,OAFA/E,EAASO,EAAcuM,KAAK9M,QAAQ,EAAO,kBAEpC,CACNoB,EAAE6D,OAAO,IAAMiJ,OAAO7B,oBAAoB,WAAYgF,IACtDjQ,EAAE0B,IAAI,CAAC4O,MAAOxB,GAAe9O,EAAE0D,OAAOC,IAEvC,CACF,EAiBI4M,EAAO,KACV,IAAIxB,EAAM5G,EAAMqI,EACZC,EAAYnN,IAUf,KAEEA,EAAGoN,kBAEW,IAAdpN,EAAGqN,QAA6B,IAAbrN,EAAGsN,OAA4B,IAAbtN,EAAGsN,OAEvCtN,EAAGqI,cAAckF,QAAsC,UAA5BvN,EAAGqI,cAAckF,QAE7CvN,EAAGwN,SAAYxN,EAAGyN,SAAYzN,EAAG0N,UAAa1N,EAAG2N,QAIlD,OAFAT,EAASzB,EAAM5G,GAERnI,EAAEqD,QAAQC,EACjB,EAGF,OAAO,SAAUxD,EAAOgG,GAIvB,OAHA0K,EAAW9E,KAAK4E,MAAM5O,IACtBqN,EAAOjP,EAAMoR,EACb/I,EAAOrI,EAAMqR,EACN,CACNnR,EAAE4D,OAAQkI,IACTA,EAAIiD,KAAOrD,KAAK4E,MAAM3B,OAASI,EAC1BjJ,GAAKgG,EAAId,iBAAiB,QAASyF,EAAS,GAElDzQ,EAAE6D,OAAQiI,IACTA,EAAIb,oBAAoB,QAASwF,EAAS,GAG5C,GC1EEW,EAAW,CAAE,EAACA,SAEdC,EAAuB,2HAIvBC,EAAiB,mEAEjBC,EAAsB,CAACC,EAAIC,EAAQ9C,EAAQzN,KAC9C,IAAIwQ,EAEJ,GAAa,MAATxQ,IAA2B,IAAVA,EACpB,GAAIY,MAAMC,QAAQb,GACjB,IAAK,IAAIsB,KAAKtB,EACbuQ,EAASF,EAAoBC,EAAIC,EAAQ,GAAG9C,MAAYnM,QAEnD,GACW,iBAAVtB,GACoC,OAAzCwQ,EAAQrI,OAAOsI,eAAezQ,KAAmBwQ,IAAUrI,OAAOuI,WAAsC,oBAAzBR,EAASjP,KAAKjB,GAOzF,CACN,IAAI2Q,EAAML,EAAGpR,EACboR,EAAGpR,EAAI,IACPqR,GAAUI,EAAMC,mBAAmBnD,KAAqB,IAAVzN,EAAiB,GAAK,IAClD,iBAAVA,GAAuC,iBAAVA,EACjCA,EACA4Q,mBAAmB5Q,KAEvB,MAbA,IAAK,IAAIiG,KAAKjG,EACT1C,EAAO2D,KAAKjB,EAAOiG,KACtBsK,EAASF,EAAoBC,EAAIC,EAAQ,GAAG9C,KAAUxH,KAAMjG,EAAMiG,KActE,OAAOsK,GAGJM,EAAuB,CAACF,EAAK3Q,EAAO8Q,EAASlC,KAChD,IAAI0B,EAAK,CAACpR,EAAGyR,GACb,IAAK,IAAInJ,KAAOoH,EACXtR,EAAO2D,KAAK2N,EAAQpH,KAASsJ,EAAQjK,SAASW,KACjDxH,EAAQqQ,EAAoBC,EAAItQ,EAAOwH,EAAKoH,EAAOpH,KAGrD,OAAOxH,GAqJJ+Q,EAAQ,IAAIxR,IAGZyR,EAAWC,IACd,GAAId,EAAqBe,KAAKD,GAC7B,MAAM,IAAIE,YAAY,mBAGvB,IAGIC,EAHAC,EAAaJ,EAAQ1C,QAAQ,KAC7B+C,EAAYL,EAAQ1C,QAAQ,KAC5BD,EAAQ+C,EAAaC,EAAYD,EAAaC,EAE9CC,EAAK,IAAIC,OAAO,IAAIP,EAAQlQ,MAAM,EAAGuN,EAAQ,OAAI/F,EAAY+F,GAAOlO,QACvEgQ,EACA,CAACnI,EAAGrC,EAAG6L,EAAMC,EAAMC,IACR,MAAN/L,GACHwL,EAAOK,EACA,MAAMA,SACG,MAAN7L,EACH,MAAM6L,WAENE,GAAQ,KAAKD,GAAQ,WAGzB,KAIN,OAHAX,EAAMvQ,IAAIyQ,EAASM,GACnBA,EAAGK,EAAIR,EACPG,EAAG3L,EAAI,IAAIiM,gBAAgBvD,EAAQ,EAAI,GAAK2C,EAAQlQ,MAAMuN,EAAOgD,EAAY,OAAI/I,EAAY+I,IACtFC,GCvMJO,GAAgBpU,IACnBO,EAAcP,GAAQ,EAAO,UAE7B,IAAI6C,EAAQ,IAAIhB,IACZwS,EAAU,IAAIC,QAC0BC,EAAO,IAAIC,IAGnDC,EAASjM,IACZ,IACKA,IACC6L,EAAQhP,IAAImD,GACf+L,EAAK9L,OAAOD,GAEZA,EAAKiM,QAGP,CAAC,MAAOlN,GACRE,QAAQC,MAAMH,EACd,GAIEtC,EAAS,CAACsD,EAAG2L,KAChB,IAAI1L,EAAO3F,EAAMa,IAAI6E,GACjBsK,EAAShQ,EAAM4F,OAAOF,GAG1B,OAFAkM,EAAMjM,GACF0L,GAAGlU,IACA6S,GAwCR,MAAO,CAACrR,EAAGqB,EAAO6R,EAAGH,EAAMjC,EA9BX,CAAC/J,EAAGkJ,EAAGkD,KACtB,IAAInM,EAAO3F,EAAMa,IAAI6E,GAGjBqM,EAAM,IAA6DC,gBACvED,EAAO9K,IAAMvB,EACbqM,EAAOtS,MAAQmP,EACfmD,EAAOE,QAAWpQ,IACbA,GAAItD,EAAEqD,QAAQC,GACbkQ,IACD/R,EAAMa,IAAIkR,EAAO9K,OAAS8K,GAC7BP,EAAQ/I,IAAIsJ,GACZA,EAAS,MACCL,EAAK9L,OAAOmM,IACtB5U,IACA,EAEF4U,EAAO3P,OAAUP,IACZA,GAAItD,EAAEqD,QAAQC,GAClBO,EAAO2P,EAAO9K,IAAK,EAAE,EAEtBjH,EAAMC,IAAIyF,EAAGqM,GACbL,EAAKjJ,IAAIsJ,GAEE,EAAPD,GAAUJ,EAAK9L,OAAOD,GAC1BiM,EAAMjM,GAEK,EAAPmM,GAAU3U,GAAQ,EAGkBkU,EAAGjP,EAAM,EC/InD,SAAS8P,IAAKC,EAACA,GAAI9N,GAClB,GAAIA,EAAK,OAAO9F,EAAEyD,SAClB,IAAIoQ,EAAO,IAAIJ,gBAEf,OADAtD,eAAe,IAAMzR,EAAiBgN,KAAK9M,OAAQgV,OAAGnK,EAAWoK,EAAKC,SAC/D9T,EAAE6D,OAAO,IAAMgQ,EAAKR,QAC5B,CCCArT,EAAEsQ,MJ+DiB,CAAC3B,EAAQhL,KAC3B,GAAsB,iBAAXgL,EACV,MAAM,IAAIpP,UAAU,qCAGrB,OAAOS,EAAE0O,EAAO,CAAC2B,EAAGlR,EAAcwE,GAAM,EAAO,QAASmD,EAAG6H,GAAO,EInEnE3O,EAAE+T,KJyHgB,CAAChF,EAAM5G,IAASnI,EAAEuQ,EAAM,CAACW,EAAG,GAAGnC,IAAQoC,EAAGhJ,IIxH5DnI,EAAE8G,EHkHM,CAACkN,EAAUlE,KAiBlB,IAfA,IAAI1I,EAAO,EACPzF,EAAQ,EACRF,EAtBM,EAwBNwS,EAAa,GAEb3E,EAAO,GACPiD,GAAc,EACdC,GAAa,EACbf,EAAS,GACTI,EAAM,IAKDrP,EAAI,GAAIA,IAAK,CACrB,IAAI0R,EAAKF,EAASG,OAAO3R,GAEzB,GACCf,EAPiB2S,IAQT,KAAPF,GAAoB,MAAPA,GAAqB,MAAPA,GAAqB,OAAPA,GAAsB,MAAPA,GAAqB,MAAPA,GAAqB,MAAPA,GACpF,CACD,IAAIG,EAAUL,EAAS/R,MAAMN,EAAQ,EAAGa,GAGxC,GAAc,MAAVsN,GAAqC,MAAnBA,EAAOuE,GAAkB,CAM9C,GALAJ,EAAW7S,KAAKiT,GAChBA,EAAU,GAAGvE,EAAOuE,KAtCL,EA0CX5S,EAAsB,CACzB,IAAI6S,EAAeD,EAAQ5E,QAAQ,KAC/B8E,GAAiBD,EAAe,EAAID,EAAUA,EAAQpS,MAAM,EAAGqS,IAAe7E,QAAQ,KACtF8E,GAAiB,IACpB1C,EAAM,IACNU,EAAad,EAAOlQ,QAAU6F,EAAOzF,GAAS4S,GAE3CD,GAAgB,IACnB9B,EAAYf,EAAOlQ,QAAU6F,EAAOzF,GAAS2S,EAEnD,MACKD,EAAUvC,mBAAmBuC,GAI1BjN,IAASzF,IACZ8P,GAAUuC,EAAS/R,MAAMmF,EAAMzF,IAGhC8P,GAAU4C,EAGVjN,EAAO5E,CACP,CACD,CAED,GAAW,MAAP0R,EACC1B,EAAY,IAAGA,EAAYhQ,QACzB,GAAW,KAAP0R,EAAW,CACrB,GAlFS,IAkFLzS,QAEG,GAAW,MAAPyS,EAEN3B,EAAa,GAChBA,EAAa/P,EACbqP,EAAM,MAGFzK,IAAS5E,IAAGiP,GAAUuC,EAAS/R,MAAMmF,EAAM5E,IAC/CiP,GAAU,IACVrK,EAAO5E,EAAI,GAEZf,EA/FQ,OAgGF,GA/FG,IA+FCA,EAEN2F,IAASzF,IACZ8P,GAAUuC,EAAS/R,MAAMmF,EAAMzF,IAGhCF,EApGO,EAqGPE,EAAQyF,EAAO5E,OACT,GAAW,OAAP0R,EACVvS,EAAQa,EACRf,EAzGS,OA0GH,GAAW,MAAPyS,GAAqB,MAAPA,EAAY,CACpC,GAAIzS,EA1GG,EA2GN,MAAM,IAAI4Q,YAAY,4EAGvB5Q,EAzGY,EAyGgB,MAAPyS,EACrBvS,EAAQa,CACZ,KAAqB,MAAP0R,GAAqB,MAAPA,GAAqB,MAAPA,EACtCzS,EAjHO,EAkHGA,EAlHH,IAoHPA,GA1GgB,GA6GjB,QACA,CAED,OAAa,IAAT2F,GAAwB,MAAV0I,EACVkE,GAGJ5M,EAAO4M,EAASzS,SACnBkQ,GAAUuC,EAAS/R,MAAMmF,IAGtBoL,GAAa,IAChBlD,EAAOmC,EAAOxP,MAAMuQ,GACpBf,EAASA,EAAOxP,MAAM,EAAGuQ,IAGnBT,EAAqBF,EAAKJ,EAAQwC,EAAYnE,GAAUR,EAC/D,GGvOFtP,EAAEwU,MH2FW1E,GAAWiC,EAAqB,GAAI,GAAI,GAAIjC,GG1FzD9P,EAAEY,MH4QU,EAAEgP,OAAME,UAASqC,KAC5B,IAAIM,EAAKR,EAAM3P,IAAI6P,GACdM,IACJA,EAAsBP,EAAQC,IAG/B,IAAInR,EAAOyR,EAAGzR,KAAK4O,GACf6E,EAAYhC,EAAGK,EACnB,GAAK9R,EAAL,CAEA,IAAK,IAAKmG,EAAGkJ,KAAMoC,EAAG3L,EACrB,GAAIgJ,EAAOxN,IAAI6E,KAAOkJ,EAAG,OAK1B,IAAK,IAAIlJ,KAAKnG,EAAK0T,OACdD,MACHzT,EAAK0T,OAAOvN,GAAKwN,mBAAmB3T,EAAK0T,OAAOvN,KAIlD,MAAO,IAAInG,EAAK0T,OAdL,CAcW,EGjSvB1U,EAAE4U,MCXWjW,MAAOsQ,EAAK9G,EAAO,MAC/BhJ,EAAcgJ,EAAK0M,YAAY,EAAM,mBACrC1V,EAAcgJ,EAAK2M,SAAS,EAAM,gBAElC,IACC,IAAIC,QAAiBH,MAAM3F,EAAK9G,GAEhC,GAAIA,EAAK0M,YAAcE,EAASC,KAAM,CACrC,IAAIC,EAASF,EAASC,KAAKE,YACvBC,EAAYJ,EAASK,QAAQ9S,IAAI,mBAAqB,GAItD+S,EAAQ,QAAUjD,KAAK+C,IAAcA,GAAa,EAClDnF,EAAU,EAEd+E,EAAW,IAAIO,SAAS,IAAIC,eAAe,CAC1CtU,KAAM,QACNU,MAAQkS,GAASoB,GAAUpB,EAAK2B,QAChCC,OAASC,GAAWT,EAAOQ,OAAOC,GAClC,UAAMC,CAAK9B,GACV,IAAIpC,QAAewD,EAAOW,OACtBnE,EAAOoE,KACVhC,EAAK2B,SAELxF,GAAWyB,EAAOvQ,MAAMK,OACxBsS,EAAKiC,QAAQrE,EAAOvQ,OACpBiH,EAAK0M,WAAW7E,EAASqF,GAE1B,IACEN,EACJ,CAED,GAAIA,EAASgB,GAAI,CAChB,GAAI5N,EAAK2M,QACR,aAAa3M,EAAK2M,QAAQC,GAG3B,OAAQ5M,EAAK6N,cAAgB,QAC5B,IAAK,OAAQ,aAAajB,EAASkB,OACnC,IAAK,WAAY,aAAalB,EAASmB,WACvC,IAAK,cAAe,aAAanB,EAASoB,cAC1C,IAAK,OAAQ,aAAapB,EAASqB,OACnC,IAAK,OAAQ,aAAarB,EAASsB,OACnC,IAAK,WAEJ,OAAO,IAAIC,WACTC,sBAAsBxB,EAASsB,OAAQtB,EAASK,QAAQ9S,IAAI,iBAAmB,aAClF,QACC,MAAM,IAAI/C,UAAU,0BAA0B4I,EAAK6N,gBAErD,CAED,IAAIQ,QAAiBzB,EAASsB,QAAWtB,EAAS0B,UAClD,CAAC,MAAOtQ,GACR,IAAIuQ,EAAQvQ,EACRqQ,EAAUrQ,EAAEqQ,OAChB,CAED,IAAIrQ,EAAI,IAAIvE,MAAM4U,GAIlB,MAHArQ,EAAEwQ,OAAS5B,EAAWA,EAAS4B,OAAS,EACxCxQ,EAAE4O,SAAWA,EACb5O,EAAEuQ,MAAQA,EACJvQ,GDnDPnG,EAAE4W,KEZUzO,IACXhJ,EAAcgJ,EAAKyM,OAAO,EAAO,cACjCzV,EAAcgJ,EAAK0O,SAAS,EAAM,gBAClC1X,EAAcgJ,EAAK7B,OAAO,EAAM,cAGhC,IAAIA,EAAQ,IAAIwQ,eAAe,uBAC3BC,EAAU,IAAI3D,IACd4D,EAAO,WAEV,OADAD,EAAQ7M,IAAI/K,EAAcuM,KAAK9M,QAAQ,EAAO,mBACvCuJ,EAAK0O,SAAW1O,EAAK0O,SAC5B,EACGI,EAAOtY,UACVsY,EAAOzX,EACP,IAEC,GAAoB,mBADpBwX,QAAa7O,EAAKyM,UAGG,mBADpBoC,EAAOA,EAAKE,SACoB,MAAM5Q,CAEvC,CAAC,MAAOH,GACRE,QAAQC,MAAMH,GACd6Q,EAAO,IAAM7O,EAAK7B,OAAS6B,EAAK7B,MAAMH,EACtC,CACD,IAAI2M,EAAIiE,EAER,IAAK,IAAInD,KADTmD,EAAU,KACIjE,GAAGc,GAAG,EAGrB,OAAQ9T,IACPmX,IACOjX,EAAEgX,EAAMlX,GACf,EFnBFE,EAAEiX,KDNUrD,GAAM5T,EAAE2T,GAAM,CAACC,EAAGzU,EAAcyU,KCO5C5T,EAAEmX,QF2JavY,IACd,IAAK0U,EAAGH,EAAMjC,EAAGkG,EAAWtE,EAAGjP,GAAUmP,GAAapU,GAClDyY,EAAU7X,EACV2B,GAAM,EACV,OAAQM,IACF4H,OAAOrB,GAAGqP,EAASA,EAAU5V,KACjCoC,EAAO1C,IAAM,GACbiW,EAAUjW,EAAIM,EAAO,IAEf,IAAI0R,GACX,EEpKFnT,EAAEsX,YFyIgB,CAAC1Y,EAAQyY,KAC1B,IAAKjX,EAAGqB,EAAO6R,EAAGH,EAAMjC,EAAGkG,EAAWtE,EAAGjP,GAAUmP,GAAapU,GAEhE,IAAK,IAAKuI,EAAGkJ,KAAMgH,GAAW,GAAID,EAAUjQ,EAAGkJ,EAAG,GAElD,MAAO,CACN8C,KAAM,IAAM,IAAIA,GAChBoE,KAAM,IAAMzV,MAAM0V,KAAK/V,EAAMsC,SAAWmN,GAAM,CAACA,EAAExI,IAAKwI,EAAEhQ,QACxD+C,IAAMkD,GAAM1F,EAAMwC,IAAIkD,GACtB7E,IAAM6E,IAAOA,EAAI1F,EAAMa,IAAI6E,KAAOA,EAAEjG,MACpCQ,IAAK,CAACyF,EAAGkJ,IAAM+G,EAAUjQ,EAAGkJ,EAAG,GAC/B/O,QAAS,CAAC6F,EAAGkJ,IAAM+G,EAAUjQ,EAAGkJ,EAAG,GACnChJ,OAASF,GAAMtD,EAAOsD,EAAG,GACzBsQ,OAAStQ,IAAOA,EAAI1F,EAAMa,IAAI6E,KAAOA,EAAEuM,UACvC,EEtJF1T,EAAE0X,UL8GepK,GAAUI,EAAgBJ,EAAO,GK7GlDtN,EAAE2X,ULoKerK,GAAUI,EAAgBJ,EAAO,GQtL5B,oBAAXsK,OAAwBA,OAAOC,QAAU7X,EAC/C8M,OAAO9M,EAAIA"}