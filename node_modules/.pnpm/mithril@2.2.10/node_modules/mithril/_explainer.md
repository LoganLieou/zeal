<!--- Provide a general summary of your changes in the Title above -->

**I want your feedback. Please use it, abuse it, and tell me what issues you find. Bugs, ergonomic issues, weird slowdowns, I want to know it all. Feel free to drop a comment here on whatever's on your mind, so I can easily track it.**

Also, @MithrilJS/collaborators please don't merge this yet. I want feedback first. I also need to create a docs PR before this can get merged.

## Description
<!--- Describe your changes in detail -->
This is my v3 proposal. It's pretty detailed and represents a comprehensive overhaul of the API. It synthesizes much of my API research. And yes, all tests pass. ðŸ™‚

Preserved the commit history if you're curious how I got here. (Reviewers: you can ignore that. Focus on the file diff - you'll save yourself a lot of time.)

If you want to play around, you can find artifacts here: https://github.com/dead-claudia/mithril.js/releases/tag/v3.0.0-alpha.2

This is *not* published to npm, so you'll have to use a GitHub tag/commit link. If you just want to mess around in a code playground, [here's a link for you](https://flems.io/#0=N4IgzgpgNhDGAuEAmIBcIB0ArMIA0IAZgJYy6oDaoAdgIYC2EamAFvPVPiLAPbWL9mIAL54aDJunrF4LAE6kMAV3pJsuAr34RB6ABSEl1BMT4ACPQEozwADrVb8AORLIZsPAUInAbnv-4ADdaOTMWWjAAeQB3ajMAXhthDHCo2IAFOR4ABwg5eABPPwcHIJCzYmpAngBrCAAlZDlaaNoAIxgEswiC4ws5Jpa8M0JqYdliMAA1WiglCGGMJZCAczBreIA+GwDHYkILQtyeA9GE+MTbIiMTPivrO1LHRwnp2fmuxsIYBAxabOyUAKBjGZleMzmC26cjWlmKz3gewOenB7wg50u4BqxGyAFoBkhmtF7mYBvAlHISgikYcWJMIR8AGSMsEFY4HVGQjCyHQYsxXQzGeCmBwgMzMiwtWgyMF0t6QjYXflYnH4wbEkDWMkUqmIvUEolWeF64QBYTw0rBUKwFhwGoAYVmUDatFgNS6elgTpdbuGTp40QAckooFBhlB2tAulcvaGfTUSVsdk9hcj-UGQ1BxSzY87Xe6ldRM2YAD4l1nssy5+N8gU3YV3TXJ6meCDkylV7353bwU26l7yANmagQaJmAAqbIgAFE5Fk5HoAAa2WyLgAkwAjbWgptXZnorngZm33RG9ZFG-TwdDZgA-MqKgdsllAsQkMgMFczKhlZ+RIvLDNC1HCtYceByD0Nm2YBzX8UoAHoACozAgMAoEqeBcSQSZ2k6ageFxNoZGiSZ0UQ+C4McJCAkdJQG2oH8TzACl0XgHgq1tN1ZXRaRqH2YhkDMHg6OyOiMDMABJJxAnRfDhVgQTaDiSZmPREjZAnPJIFCTwCkqFYwXYyp0JHAIwH0mBcVcdFBVuagwG6ByJIkgAxacwD9agkFlSYzGfZBiAQXCCk7ayHNyOQDhU+YHPM4x0R0FZKlQswkD4Jwj0gCB6EMgIBnQ4KzCgAM8h8hzKhQmRbR021iFCNoCkQXh3zMFYdDyWh6LMRCeDkZCeTqoTsmFaQAC9BOaiBP11epOuq2UlL86VqEMUMQt0-TDNJZAlAUhajzY7o4gAWSme0ju8kgTIM2hjyUG6VmWjwKngYYpJyrBDwCYzKk2pTvN4ehGH4TaIBkuRGrpagVnEiSj1mMB2KSmSHMYU9t3gRBQjfCBbpObiwTkD5eGe-GrVMVwAls+iwGmgIJLiRd6EXN7UvY6zT3w3EfpHMIMIclFbTMRcAH0RcDSIJMDAAZKXpzFxcKjiRaefRDoeC4wHgYO6qIGsNiAn8mT+E0uRtJGLIcp5v6qx4KBLvPcwKtu8GQpYHgj0mpbZHGdjdK2sAAEd5ggcbT3QzGYACehevRCLCF6+glL24Sj3xnkLYkaJepqcTpeIOoSMgX3CfW9j-O0mSytlLJ7pYO7SG8sBYAUYaPICcctNKpS5M6kUHJCOOBkrwSKoz6cAGVjr8rIkF2rq2iMJBOj0RejzkgmAFVjoAETuryYEsOnSgAQSgRHhhPKUBh-CSzA5xG0aItOIr7vgHN18TAw9qGDOYiKRjJxCuhOoIxKhIFxCQM2mFICvTMJ9Dw0dlpAjMCfQMO8PJmEiPUTB-1Tx8AgLiE4BwAAa2CRi9SVhAYOswZAFDpvAcilF4DUVKBPeAnVZIewgKgZhEkDgDBjlXcwsgshjl8ouTw8xFZ4MWnkecQlYCwApGAXhpRcSoJvK+cyiBvKBHwu+MAThhyjjMODcy79oTokETwGSagAgaLPlmIw2iZCCX0TwQxxi7Z6K0v3Kx20hEfj4QI7Ktj0QiMHOIhyi5CAIwgDIryR0UJzkoRrZRZs1GOEcZjBQa8eKeP4l6Lq8jeoDwGEVHgKw2r2PUWYKYAlogOVkJ1GuQ4yTLQJkbCmDlzEigupUgyA1QilLkAwjRs55wOR-qVFpcQM7tHCaFNwGdWysXYieNiHY0qxEco+QJSzIliLMK0GJUiEkMKYbqVhjhxxyncBIdwUiEAsQqA5ayl1KGQHBrMMChjxIAAk8gQCcAPOIEAAAegJlqlQTiM109cjhTWYY0DhlQsmYWFszH8i5cQAEZlx1KcUJHkoRnw5DyMKFKg975FkgEgBxWDlLQ1QnAjOHiWoyEgFAKKDktDg10UrQ6qypxCQ5ELaA2UdBHhkKC7aaK+LQ3EncyYAQzBK1gHMQxHElJJWhi9ZpU5j6OBcs0FY2tVGMqZorZ+DkAAMuIADMOK7WEuycLeAi4fxGA+VasAXraW+rqYuWgAafX0qtbAANr58hKF+TvSI08bSNwGLqDRi4kBhrpcgZhABpCABRkAYvTczY8XKzAOudcLAlVrPXeuzQy4N-r61BvdSGgNdQy4cUbvuf4fpz7sXdvbPldJ7apsjVm1tmKM2TojbqTuEL4DFqxTa8tlacUACY3XTrrYGudbbm17pzcG0NP5ECLqeQoaGE6W37unZmn8iz8i234FkUMpUBiEGBfFZh9oeD0GyAQ-glrg2lttRWp1OLHXbvTbuwGgGRwm0-d+hSfro2NLPEKEUwwk4hSYo8iItsANAaPMh1NqGT0Bpjs9AYCl+AoNoxAYgdjui5OIPksAN6lYeGTuiDlEArUPqPY2gICbp6Sotcu61Zb4D2sg8LAALDBj1AaOEGToGjDwV6VhoZ-GDaVRVJgCFKthOyIQCjDH2EdEK+ngMnOBShcG20koeGBSJ6dp79w8Bo3AaVDHfPMcUmxjjXGY3knjYm7tY6dCCYDRJgzZGdAUYCNLWgBRU5SbA2u+Ti4ACsynJGzuPQerNXo66Ikoz+as+YA42h2lHYNUbb3FfvQG7Ig8TZie2l+8jUI4UoQiAJUIwcIDzH0iisJMlMurtkxBqti4ABsBXd3hpa+mw9q33Pps89Vrih1m62jng1ttTXhOxZ-O11NR4uuJfisMfruNzKlRG2N69uoJ5thfeepdVqsuzfXcLAA7MtorW3hYbYbVazzm3Qt1XC1mLrybotpuFkJmHupN5uHfLkLySWBIgbbX9uT82AAcIPmtg8XBDqd22A07wgDj98xgQohGaAUWHsaItJtHYSGLwa0eQ91AzEyPDfszeJzisntbQe6bO5VsxGHqYii45UHj8UzEGIE-zmX86hbSZINAbyvkEbs3pRQ0I5NhIDzANpGm4xwjw1TRlVKqEW7scEp-AIVyAigXHAATXSPLY6J8J65q6Hi3LxpfcB-lvUac44T5Sy6PiqP5R-eB5Fi5eoJ8ADix1pyBnHF0O1qfQjp-lrm6cfvpx70SHi0vE4Y8i3HNOEhRfEgbob+XkW05pbTnz4Xrojqu9N-tIm9IkRAwF-b2YBTI+M-SxPn7yIm8Z+R592npvcfjqRCmNOLoC35-ywnvHkWY-C+t5n4Do-ItN4n66CTm-UtZZT66AATmNPBeCZjN8Z7jwnpPOvXLZhUCFyRfHPW-E-WvMwPFMwAAHjgNnwbzANzxFgkgnhFm31333zr3gMQPX0tHKBQIgIBXHGOmlh7z7wHxn1gIQLMEPw31CGILPzv3HETUoP72n3DzwLMGv0YLMGYKlnSFXw4OoO4LoMf34OYJPz73tHHFEK4NwLoI-ykPAJFkiHSHHAkknwUMHyUMQLxRL1UNQJbzbxPjjxPl0JoJ4LxXr2MIgPQMzwkj7zQMDGEOsLoLxU7wCC-0kgA3QlgBkBQQ+T2UuzTgODqzdE2n6yZgwA6UqCsEXAYV8NALUMcP-0T0DHEMQMdTxRAPKCmE1w9CTjABqHGFoBWD9FyUwSR152oCggsEeARHoB-BKLKJ7CXTBAqLwB7FoEfWqJ6JTFgCqx51TUGIRFUWHEzHGL1CQB-CLFDBmOEDhHyNCG5TgC2XSBCHNkSHgj0FvFQD0AAD0SwABiEsFcDASwPQCgI404y4lcCgFcAAXWeIAGpLBLASw9BHi9AMA3jbxriDiVwwBEJ4gQTEIfiQASwnASxrj9jeEVxbAniQAnAXjniSwrjEJASVxctLBbwXjLB4IVgG91iEBepN4Rxm5-h0RdikTbAbirg0SkTniiSST+CyStlHQ6sugkIAABMWYQuPMWciExMcY6f4I0VYojbIUgCAD7H4LZD0Tk3qBopovUUCJOeAG0cogyTEbCQIK4YYTVCISAByRICgZ4qozwc0pIY0iMG3QMCQYYVIE+aoroOJc+CAYCPUaIUddEPQLUm0LoFUuQLYs2PIDASFOAPQUMz45sPUECcoJFLoIMlgCgPFK0n-SEVMzqG0CgDdZ440BEKzFEUVC4TEL8CUYIHMgAQiVCuBJHVJbDUy6BrPmGLJNBQi9ITJbFdPdMSHOU7JLORBTIrOVHuKbGbMTL1E6htIwDfDbLRGHK7OgDcFLLHIbMwCbJ7BbBNJt1QgwFEjABYD0HbL1hXMcGEG7PXORDTIoEdWeIoDtWeNrBABRIeF3JnNAjnLkAZFpN7W1PTIWyLK-JHMlFyX-OsF-P-K6BgrRDiIZwjAUljMlXJLkEpNdxpOGCuDXDyM1EvL1FLPvIU1fPHJjAdM4zFDLEAvzNIrfP3LACdMYBJEYsPOPNPPgoVEIscDXPRF-LAAoBIteLgsgrRHOCmJvBoq4o7LAt7C-L7AREUpTFLLYtphgGhg0m2DtU-JTEcEYuYoArUuwB4ASK-HuE7OUoRFAh40QC6GAE6LUz9B-H7JtLvFYzcvmOmKrCq0osMtghTFDO5NtAwFgVQsVN6mGFsovJ7G1A7GiqAmYRuXgGnGwh1l8nUnrjKy6jwXJSugSldh1RZTMHSyUF7TqGVXuXgwUDNO6DaFTlnwAFIxUCY2IOEoA8ojARoIlwZbRaAjc4htxjAWAk45AahcEkklIQoCR55+kKp45E5eMwgHMSIbxiAgYApOEUETwv0oB4BjV4Az4L4Xo5UwBchAinQQpDFiAVgRxvJDo+AUF-RilWIhYXQKleJ1qVAXoTFkBmkNklAe1+NcFwoQgKtHB057kcgRpiBRo344hyUFIbdYYjw0pUJqBndnrOFoQVgVBpUHJIUFJho9kRxkBBJDpF4e1aixiXoAg0awAMb4ZQwNZsbfz2M6IUpCaGcDp2IBhoU9oeQcp+sY5sISBil+4-QY59UZkap9JaYvcKJCDQgcpEgldzBwqNjIqPKzZdLrLkzyzG8M9e9ODC9OybKOFn068zbyhqadAfSaQyzKxQyzB6zMQtNxspyvyNypx8ZnbXblQ1bRRdaZyBxjkRwxxJleooS7l0RnaDxnoTwmNSVTx3bpbQhbp4MSM-wVi9L5Lc6xz3A0KlTxz6AMBTUKjtZ3Lu8s9c8xCfxu8x9joJ8p9TaewrKVK0wBzEgFiswaKkV8YBK3yeA2gsANiqyWR+6DgBKMAcp-argix6Btw5Bx6XaT45w0sFywA162c9ABL4zpzHAeNLazBvDc7SzVg8bgMMANKVgNIcjsxtaHIJRt6N7JgX7gRp7bb6jg69zRjeREhP6-7qBQqAiIApTc7FLVyeyD6OEBzJKoBLLmEHav6JKe6f6iK0wYRL7ZNr7EoNJxyj6jw3iYCH737N737d6sGLUKBCHWT0GEQUGAGqH8aaGLb4BniQHAowGc6Wxry+LeyZzGGzBLTCK-S5SLBCH4CcbsH1K8GWBrAv6jzXBOLmHgNWGwa3i3jWSVzIGrykGWFv84Ze0QosocpIUcdzIq5DpVZuypU7NwgD59JL46ITqHIyACaoUdBLHXrFpSqnB7qoZc4exfCutNdyl+L6qXHCMtZHqQotAtN55FJekwnnGjxCAzULUAlYmX0EmEAWsqJv90n-0zAAApCeEhW2FqXepJWzbiUEHkFnJ3T2f9KWo+fR723IPkbvY26g+h2BtygB90mimCFc0CVIe0Pyx5RIVIGIYB3MXegY5UAyiQCyr80CJAXoBgQKCZ00rocZyZtGe8T+g59Efo+cxi0Z8oaKkMou3qYKqaNqeADW9Cnh788oXqG6yoX5QZm0+2jBiR2B2k7uzMPpw+wF3kxCAU8WSWGWOWEU+CeDOUhUzWhcOMnR-Rh26Kv4F24F0MUF-ps2eypYUKwFv4RYZYaogK3hjF1MCwDZjTbZyinF+B0scsLF2AZltBgR8ChZty-2j5vVWYaCuB4AYlgSqlkOgl2mRiroelrZ2AHZm3TlzMOSxwe8dl5Vm8e8dcYAdl68jcOV6QBVyi4QRWH8Q1xl001Vzo9lwi0s-Z00wy4V85k5roHu9FlMKy-5x2oFxIBu8fSfafPpwexIYAL+8lv4SllcoR91tum89EGB-rM88oYgYvHwCoKRxRm+2QdN4gTRhRoBigYgMi-cDAfCOQJOdCcaT0Qt4t15vR-sVsdsOIQozxMBpFKK25uQa0s2Y0oBwCUoKl0oUu7vYPUPLoUdkPXNY0EdrfePTIidudgAwMGdjAau7PPPRQw2+WGuzd1u4dtdpvSvavaA7vY9mvVd7vUwmfK9y-S9pvHprd7pqg6fe9jPRu5up90fANlu8cN9+WRfZfVfRdhfJfFfP96OQ9v-fvbAkD2PGDvff9kWE-eQ8-a9uD5D0-NDu9yD7vO-HA7dyA6cJD5-OWDD0jqfH03wiedawEfipJMAaICANscSI603CAVac3CobCf9NxgudERcPgBOHgVojAL0YaFiRWQ6eDGARAFBQkCCWzWbMR47AxklaqIudEG68tzaQWhhUu8T9sACvQMGNUnsMGI8gYY2eAenOJEMJ5+txAQIElnITIHICo+G8BhEOKuIK4Uo1UA0FoRswdn00u+IuIRIKwBIbYVt98PQbvDIqWYYHu5L7ytB1dmxyL18UcBo2LsB7vCj6cVLxYjiO0R0OMfMM8xpe7eJHCkAbLjUSwYrqAV50uiMUqo8SL3bGoXLzXeLpvQD8D5rvtsrrsN0T0Mbnr5r1rxCoJD0br3rtt-r6DnfPfYb0rt0crvMcbhb6b0LsujJgzSLve6Lx+sToB-bztQSLLtETBBrszlMBrroSIh0Sbqr0ccYImKEK4Br1Zx78oJObIN10xCU7ILzvUJN0Cc8lq889Ybl2ln1smDDci64LDRsawaHxIBr5N7ir25EaH+slliUSe7Mj4OekAequ2XGIO+Hh22ssht+9e4Ec86wGi883BzS+uAw-F0OoccOicKcSOhcK4VFHUdxcS+Oo8K+YWCgTtYYc854mRJn+4OS3Rmc4i-4FICIHH+YZ8uh2nvUXwv9PIAW9iVOv+M3goReu2ByNKRmtpYkXOhEURPn0xScXIIXpcHeJQQEQKbGztF3JqXRH8DcdhbTHXiAPXywU1gdlsBtuP9gTXsK88vXnDMtxaqtsBlPzMz4j1pS2KtsHUepPrs9qvGvdbwH6bxK3UUu2BD0aVBQVCCNr+ho4eO2GSCec64gWYcu81aVZb4-LDyfa94YBv-HZv-t1djmSL7HTBYllv07tvqADvrvnvw7-gAfoj4YCgYl2frM+fyf5hUu8tyt2G4zzXB7nloowsYsPun2g4a-rcynmAJSEkHz+BnsDpiAfGIo8n4e0ehAG-0L4dg8um-EfvA2GBh99IegC-lXw7oWAGeW9JnjALbbxl3+oA9drXWnzrcUufyKaID0DLp8K2tCcaJ8QL7Ns8B1ffgkvxX5wBu+UAXvpXUi4dtH6E-FNDoEv4alygNA67lFjqIc9b69cccrAWfpM9yGyAr+lH3co78lgkgl8q+R-AyDzu7A6gKBRTCQ8U2abDNogR4FqBs2LAXNvm22iIxl+yAItiW2P4Z8z+egXQeYMc7oC+uLA3AQJWGC6DY+vYH0qBAhQmQaggYW0lcDYDwBsgqAL-NEDCEYBogjqDAL1BWDwQ8Ub+BIfBG8GVAEwIABvGwA4B+DowIAQIcENCHhDIh0QmEHEISFv4khGQjqmkP4IaZ5S7WPaKGx7BgBAgKwH8AEMxh5D4IYQ6IBEKiExD4IG6O1IMPghNCdM+AHsFqRYCtCch7QkIZ0IKG9Dih8Qt-CTnggSlZAqwuaOQWC5XlPBNtCkFdgBTgRxqDeDJFdkaCEgWgJw-YdKnDLSorhc4aVF8G-jvh7hV2QymdVdDel+Cpw6VDvA1jYNXh0qP9NoEXSAj+AjQIJJEGoB3IxEuw7GPZEpQnxCAWMe0NcPBEcdnhxnWopwOQZoj4ATw1AfDx+HojCAmIv4MiLyCeg8RBIlqIkGxGWV42RIvEbcP4CWcGcOgJAFSIeEkjMRz3HnI50gZDsCmPvJAJwn4JBJxwPAdIN5hkD9IsuF-U7tOVAhIpOyKnAMnoFoKIF-WTdQNoPnLCajCOhXawCyANE+s2ymuGeuKEI5jtc0+9PHhYFrJnlr+GuNtmJzQHADG2avUshqJ4KYC92RefUb6Kbz4dSwJDOgt3hQ5n5h+l+Y0WGMQJIo+m-GMThgDhTTgEUgZcJJKOlE6IRQAoxkd6ING3s28oYwsQ+xfaF5YxBohMfD1VyIiKRcgVEdyPxEYiluSYpAHmP4Zf8umR7MvjvETEWjaAKY3qGmJtAZiZIWYmUfRAFFUCla98bIKKMQCMCjuFgHxPLwVFJhpyvhLYkBQJgxMEan6YgBClcGTZXqCURdM0CVgExVxAyFuLjDsoZxIUngW6GPCFjh0GEBTYJt-kdD28EEB0WgKAgzhJwIULVeqj7GPBwBaAHMVOEQkICERhIXkAeEolQi1VQJ9cbCGACJhtxPxQ0GGnDRpgDJfIv41qO1GaBrR3AxUJjmMk-HYTv4iAH8FZiTrzRFw-GRWJQkE72xFYEiHuizF3EtNzA+ggibNgDBxABJg8bCahLMDjQsgUVIyJ7CUiY0Xkl1B3u+LKChBw60sORuaLbaassw94JMbAAEEaQfwRhf7qEB8QaTOeXQHxDpPco+JkxAk4ydbWtB8TqAFkwQVZPthuS76YpLyfXHvDmTNJ8xUcL5M7L+xE2lCZNtjC0GptECe4kKRUCMEijOEmIvQHZNgDmC1xro9KXWxXIaCopdIlyfFJik+S5Ghgj4nOIXEQAUpuA-SXYIZHFJgyJnPpnFM0mJBiAuUiKaBFTaJAS82gojFLSKmJT5xyU1sRaOylZl0uX5PKRmwKlAw+ARUqRgFM55lTrASUxAClLSkZT4GjnXnmOC1z591BnUzQbNIGmlS+pS0wQStIqkjS4um04tntxnFJlQga0iAJjmM7Xj+MOIhHl+WsmE8e6D9OyQJP9p2pswazX-riyzDVkLRQMpUCDOZBfkfiTvIIAOMMn1x+W9sP4KjNZZyUkxg4x+GA1XiWYGitZSICPQ2Kb1CZQkDGbQDsHuCEQdM+AH0xelLiN+14yabnWskQzEGKYZmevyeYfSL+xoIUapOumIB80habyJFwFmEiNx2Eu+BwlAS3R-ImMExk+JupsA4UrQOQN5H+DkoEUy1CpIdDqAM4fq5kfwqLhTC+E8U4kAAEKA17Yp4QHhbGKbWSnZD1B2UmOwkbpxIAAdVmDugM4-PYGn6CQDYR9UfpTqHKmkA24-oSSdrEBU2gRznA5UeZELDsnYSohZgCEUsiKY5QM4rs-4ATE7QpyCYQclJkVFxivhpa1AFBBnGLn7RsJ6qezBUhsQsZXgpIIwCpN8IKZxI2cqxkLEETLRNoYTS8fnIdluyHcVie3i+NkimJAe4kGjurh5CNz1U-PeuZRP4pQABg-VK6pKl0T25fIhEw8CnVo6dAnZbiZoPRAOoFMzAtEnhPskYmlRmJmuViaEHYmZo3kwsbifbgLQnJ0oR4R5gbKmgTghY74OzntV7SlE3k2EqSTwE8gBNWkZWWqldybjgtDootHrAMlkCuBTwcKBSN5BFzlAMFfkbuPVRkjXyRZ-Vd8JLIrSdlfCcMOVC7HEotIjw1st5Pb2shyBcQ5KV8KKI6D0dvI3s9hc7hATQAu0KwdiFKBCgVRDARnIqm1HlqWzv8PsnOA5CY43gdAwkFYPXEIy3RIAIMEcFABUmgRRkNzCKg2IRRfCUwYUr8vQqxjY1AJmvSSMRKPD1z+s6TZjvtBORpZ4F3GSlP0l6jvhsYDkXGiECUiIByaGyfaTOV8IVw8gLGZ2NQBMbnVcQWgOFEnBNiJRkoKkkCCjNTHpiYBwwHroqJxnlAgeiQX6RDNsnUyMAjzPQMUq8qhg7WyIcpRDJ57khhp60pbrgPqKEU+G0Da1qBCNjPdqRLYl4dawlFSjJxIoPQNkB2mCNRlpI7SYkCNg8UOllUlKdkGS7zKEQITPeTZEtgExrmsCVJkJBrks56xrjcCbyGYhISbcq0FBEEjUAgLVUSMm+bQGqBvgHIpNMOUMjN6r8yJrcgTtkFYlxA4kpAFiDkpnJ2TBx74WTmAx659K5KVC5AJox0bzKUVNClPHGwan1wmp8PUxYkCsUHSeWlS7aQchkjizkAqU+2I518LTgqoT8zFXyFdTOy85euXFTamKhcQ2JzK8cvikVi5yZSsnXTkLGKg5AVJpZUxf7SCqWK+m00uIGTBRmw8rA+LUsriFxCYrrAbQbeQmCRkvTqpD0iBl+Rd57TUky9T1o9JFkGrllK4+2JlPfBfTfCKqcqOVGIz5Bwl4kenCaUvmBYnk2NIiF5DlpeL8oIUcwNjg5FJZ1ozQKItDHDD8dsJuQ1RF-iSjYK2gYnf9PBG1KOoyh5KQDGAFmC4hzIt1BGAMnyicIkAOGMJGf24iDRh49nTBGvH2hypl5SiuqiYI5ooRF0BmfGEnO4ghQRwSNAtQoH8zWRKqv8u3s7kAx2xrMEwJVCAtaSMAlIA8G8BJGwk-KtoaUAOD70AzPpM6iGWbC6DNyRJson8oiVQurgjhWkcUFYJ0BFwtVJoia4FF3MVq7Kvx2ko9YJHMBaZcY9AAWFlGrh81B0wKawKtSzAm4-I3CEGEpI3XtyI1Qa6uWEADDYSGmbMWtc5MXpfMtkii0lQ7PHKfT5UOofRsqKnCdlSynMtpTWPx6P9yVPne0U6NdE5RECOlQjZSHo1JicoLIZgvhz7EG9TVYpAXh73NVQk8uqMY+RvBPADBfUmoBSiaoNocarRk7UPKMwtE5QSwiQbjVAQZH8MYGBdOyZxutFTs-mDtfjKgxBZ8aIYBvB2imX9qb9EuWRFkEpttFagTxmIneJMHjn5kkUzxGle2L6Wdgdx+KmBgw3fhU8oywmmKkjLV7ecPRsmxtiZtU1SMWNwWtTvwiuW3RwueAz7suoPB2UZQGEP2K+O0myoHI4XfSOJAlJ1ByoR4A8MGUexDY5KvhaxubMrp4Js4Y1E5FVChUfikZvhO+WenuQB90Iz0RCJL2QgngZObYZFEjIU0VKMZ9AQikmM65Uy1A8ARbRaNtJ2SwA6210bdDm1qBaAO298GJw8lqBYAR2qaDQrslIBCKdG41fFoR4KauNahHjfi343893eM4YTVcFE37hxNHscCdtGk0Mz4+Z9UcuWSVAMbjtBmpzcaJZBLa+QdkxmQb1m0raZ6OjRkSlptW3T7V20wipzPgZ58ZyBdJ7YZuU1t19GNi3OtjogDuaPhQFCgN5t80OrItSlALY1L1jw8adzOvHSaqiQoQKdIXaUi9NSwdcPQIsFnV9LbEjKmxLItbT2GJHwBDhtQWmBxSh2s6PBwuzpQ0BPHi7JdJSx7haJoWK65dQsuEShAAyFBSZAA5bSMy12VSPsy2nnQRtlmmSXczcW0tbvJmPNZmbnCKIUHpzNxW42G9XX8Ec7TSA++ML4IqWiGxBxZYAPQIYlgDrA+mITLIEDwzhJ7g9lCaVHVDEX7IStYEI8DoDxrNB+FC8tsMKH1QyhDociS3WGrJmADc6vhD5aZSQAjpdUm0ctCeWwonI6QwZXyNZFWhQrSytZJPYJU7QcMS9jAMvYfHd3J7ZeBaEttlGGgFAvdCAFcmnoggZxYEWMfZAQk-lxL+AJcY2UDxlDbyIEsTKFZ2ORB+c2wX4CqOPsX0FBWS8+ifUvtCqfZEgS8DjslBu2C69aZKKzsCO+wy6rsIBx8Z2UV0QGL0iQdfftQ8WhwwG8BsTtvMQCzLgDfAb7MMHH258ewvMiuv32lmOqoDeImA8tqNjkGzd9uzhAuid3EHOdru3DZLMo0wNax+QJESiMWUpTpddIvEX8OUTaxUDd4iAHQZ4MDi8DnrTHfRp1YwrTWOLRIDq1xkx80dagTXLBSx4DiVNro43dwdtXXbuZOw6Ug42XgQA3SngdmogCF4ehrxfWXqApC+mqVRlkI6Efzpop4LOdbB5ED4hc1BJpwMAbWL5vmX8bol8fPUPEzC2jImp1B3UKBBen+G7G9B3HS7ugg9ghlVnOXWAZuEdZ5dbuo2DSKMp6HxleRqzu8LqGFGmxZRz4U5MgUFgXR0OmoyG3qNTRDtaR8oPFmP0rbzDZsP5uRrw2sG1m7R19CFESCyq6stStsKHsZmXMdIFRLoA3xCj3gFj3Ib8M0e5AzGqwh4f9OODmODkKiC5YwFqlQhQlcQf3FsF1NtK1llEHgbY3MYlCD17j1RTehsfsiiU3Kjx+chCg4CvGaKNQzvp8MZ0VFXyNFI2FUYUgbHoatpXyPeGACTBryjShBjSw6NO65K9ka1veEV0CHsGwhzhAke1iBgJ4MAzBE5RwnrBrWVWfg-8KEO3jcTAR-viSchMg7pjNLUsq8Zv54sDeITUytXvSpqK0s7gSoHtBlD017epjU2ObF8hgBRqxe-CHXC2jQ11qNajOIuH2CKxMqjW7-Ppks06rk4aE7kwZBDSlgseaIQVZQgwV5BNozEk0-9VPBYw6AEMFGt1EmDIQpTYNDUyhFlPaKtoNjDOPEw4TAZfFGcBOMzRIj6p2sSrBU2NBSgZxh4PNeBF9F63f4MIEANqGbG60GN3Tfwm2GbLo45N-TmEHzrpzyD2mWcA6cqilBlD1bYUOe6GMlBtPZQa9tod0woG0XNNjtjW5CKhBMiYR0JuELTrjhNje5JWqOtokaYsDWtfINFa42xHoA7GdMbyvUPeGYKkFyCVhUMcwXtCsF2Cj7QvNa0cA-gUQuxrojDDYibwAQeQR0JACsDDBEZCfFsrsa3JCFV8X4Jc2oRXMUEdzAYgQmkTcIiFPze5vUGegfOYgZC04OQi+e-OoF3za58sNIWNpyErCAF-c8ebfIaEtCk+CC8ubIIfnyxX55gmhe0KBhELC5hEEBb1Jblr25hacCfEwtvnsLMFyCxAUosWFiLd5mcj+Cwurn-zJFxmUyccA7KWEnZtCBhFxA6A+zSsJnEeG9xIzSykwawMic-2HVgsHNKEqqnwBvJ5lXrBhsyJyPzG6T-AaNniLBMAV7I2mgZbnSTGbaMZ22n6fbG6NWWDthlyoxIA+H1CLAJu3S0Sv0vLbeDqho+DUNcuvT6gEkFck4ecuMBArfICoX4IUZGWXL5Rt1pmEMNDEijJlpK5Tss1eG7VSAeyzZIlA+Jcr45E7ilve2mJPeVwbo5YZSj-8NinYagBJusSjZ6U2dOLfRsHp-TzNKW51ULC6z00fI0MG05UFEiHqIgX61OXxjRAySfqPy2KJ9igQeB0z1HZji5XaHJriSVUJQOmsBirCqoI6spvBGkCiJFAOAeCNFFQj9CFsG6DdHJQ15QLntqBJ8-IU-MP1p6NmgYwufPpPHNymIfKiSFHPqbGLaBDAi5GcLyxHrayhSwXVeukbVeNLRwBHt-nOxqi7S2BN0fV2j9vLOGCIGUTMBy8ujizPekivu1TSjpoQAPhVAKvI2De-1jTWkQwJYFEOclVG7knRu2NtYWN0okUoLTDBKbNpHtusCJ1Xl2deKzw1+Xf4mGYAlV-JJ71sOfd5gDMrS+ss4Qsz+ZyRwWe0zvLY2rRcF2Qk9dwsAz+j5K3TZlfdMuq2YnNCFK6HgAoI+1d8VoJ0cRiSQnAOUKTTep+r7YPlsdf9OiEfUzbygJ-EgbwMebsICgMAcWby17bKhzyZxyVqWR+5ogH9ysKmylodoB3M+LB962xYdoKXOSyABmO+GAmbAep7ShEApcx6E6AL0Wmcv0rcAp3vWOdounndxzATmNrLNm9KgwAE9CwVg8aO2Ks0zky74lbuj3eQBrKwjCfKu+Pa7K4qLAotpGRLbMPKWrDwm2W4Ai9KaWaWVOhPt1d8h9XIUVtm25PLtvhKpr70IHW7Zr1m9Pb7gb25U1CNvM1JI9mhY8z93h2XByoXO0gHzuQoY7LYVk0-YUNG3rWDdxUk3YLtusn7RN3hsLdnv4sF7UtjmjLdx19Z4kG9y1Y2w8tXYugRsU3QrtSvYOrOBR0g+FdQgJWVlpR+K9Uf0Zcnq4hGCMHZUIz5rzI-CraDNT2juwxwtW+uO1vdA6qAw2kD+NffQV+xeaO0PaB4FDv33fCtGWYMntSgUgu9fEYUL8ljKbXLAayPM0TDsiscyzYGl3JgpDRpRhomIxWN1xTnYTpzxTZE+8hBhZgM4DpI8Ew-YydBAMGECwGI2DJ6PbQUAIHq6AUgwBL5XttGJDWyhtN4BvmszRybYMIiOD9YxsWcLGVZ8jdelxI9OIwf4OvLiRmI-wRel-piMB6mw2rZlmpHrFJtiy+UCaO4yNjayHm-bAZhq4FItTnK9URXKpoglRaA3n0e8gdWon1rDR-ttCprKfE9T-025bSlDO7LcDGFf5pv2HB7+hwAYMZ0staTjtjMsTk6C5HgGsDj4-m00-svxlyegdHcguZ1W4x3QbTtzLDaRn9OLAyzwcos6PjzNoD2zxdLs-xs2k0HLYbncM-sijOoQ+k1MkQNP7Vs1kkhtnTPaC30bFdfciAFCJhEBh9Y-O++-pVC0wBwt84aIwAc12xHygL04XMlEKeVrmjX0rezOW+cOyenuktHRywRMs6TtiQSwcQMz6h7BxTzsgy87gTPOQRvFvMRC7nt-3kQ0Lk8XC6iSIvjkyL7Uqi6mhRGNdYR4WaBCBUq3CXDRAg331Zm472Z1Ak8VSpoVBHTuMKocXIBHGnlZlKr7XZsum48NZxQK3kVLNpUG7neZTgVw6Ou0ubm2tltQGoCBXg8EQ12xK00pxV5kRbzUqV+i6jqyu86RhnF6ECBV4nlxerpg-qFc1LcfDnZVV4EbZkgtsn1rk8SM6Wp2u+7SYcl2dqNU+Fv8jQfmtSkVWkpNOJiIdeZnBzqQbQSRHJ+a7bZ07PNQg4Rvge10q2ZijgF6Tq-7dK3EAdB4d-Ecxs9vKpeThDNKnHfa7Rdqced5VJhfLvOEjutd4gDembuIA+LkcDMTUFaugkbmjzUG66BPEUwirvmcO6BVDuC+x7ttje5PFxvj9978JHm7uw9h8IOQYdwm+2CK7ld41JRieSCNPugkfbt9zJAg+Xvc3vz3jAe6o7wQBKSVIS92awg4QWHXMTbLiCtAOQhzoEEPPaGcgiwAUAeAFAXmLwQoN0O8BvIR+I9j5pYk+Sj46hPi0eJ4RHiSCLEY8+zpw9QHvJR4WwEEnpqCdj8R+4+8fM8AnhgrOLo+cfxPfHgFAJ8kIyfRPcnyIDx7493wepEKBbCoRU8ceuP6niT2Hm08LYbZbHgz-J648Cf7QFnsT0Z74-TxTPNH-grJ8M8afxYAn4jq59U-ueJPkQATy5Ds9qePP6QSj4DhMnCe3PVn+oOF9PpRffPVnieOF+Hw+fLPDn5vOF7nxpf7PHniptp8BzKeEv6Xjz37nC96eqIqHkS2Jcw8ERsPuH7qK+tnEv3094sj0O7A8Bc2Cgjh5EB16PCUuH6MzWIOs9DB6A+vXXu0eU4txD2kNHgZ-Ye-V749xK-tT0m4GrLLfKN7-aO+g5i0UCe6Vq0CMHcKBh3f5kXcb7jYLQ9eLAfXvKyyCG9zMNn53ztJN-OPlBy7fX+b6FaW91klQq39EOt5++0aPRwsDcOeVNZYvHA7-fb0LujeF14AIdzoJFwkcwAmn8vSa90FDlfTppeawypeJZ7w90jHHPII7r33kOcghlc7iED-Tvg3SegFjeOTc+kf0g5HldoMaAM5ANDLihHxAHDvnlhgOPiQPMtLJ5rYK-tLliltAg+JOfR3yR+HevEC-GAAl8+pj-7vC-09ovpUFL7RAl2Ee-kHrCT7yA6+wWkjigAr4gAlsRfy5Su9IZ4vG+0XsCP3ZSmBBm-+f6v7X2PcjeSsp7bOnTROe8P2wND7Jlrv3Ydp6-iflew3yH71DI-I+Zvkto2SqE8Wa7CbJC7JmO9TQgVjv-IM7-T1OsPfk9k0Fc+pY7fsXPhRCAEFSqNmMqVULta2DRjZVsMAyPKuIymryL0QpVcswdVolnKUEvkduVymgBT0kNmUQDEeD0AyhqqpEAeJEyPCOpcQuWZqvjCJggxgnvVXGO2NOUZxWg0i5OQEERYwAAYciY2DfcYDdVBHVcGoPhDdBEIEaeQdJUtVo5W2CaXpP0s+rMDpBSo+MicBSHqqZ8LVvFTxgUALUA+TUVSALMDagRwQJ2hB4JbyEMJ8UXLDMBc0YgBtkWqU0mygOgaRWUhZsEgDoAswSMzP5PkCtgOoJ4W+xCccJRUzwl-EYUx4BUILJDqQXIShHaw6oaZCnol7JvmcU6hAOVtArYfgD9hs4IVBTMtIG+2cUvQOIHgwaUQWiVg1UJaFIkYAIxUZQ74V21PEHkev3CAY1PfWKh+qByBiJkhagBqBUARCESRvIQTmoBDAraBe4uOGWjwFaYZxS3UN4JQOkD7HCICPBNAol0IwgzZgKPAN0HVHUChAwfWYglJTRTlMiJJ2CEldkI2XwhxEIfzOo6BWYGkC2afJGHBHkXyDTI+zcZAEIvkStnA02ApIIisLABTB8CrbIQMoR3GJrl4kWoBe2aRuAy8QeVhgTKjAgzwUMGkDzeGUhCBJgPgHSC74QwDcAnQXiSDU7cYWHu8jArtSMwksH204hxqXxV6CFkUOXgggVQZECghUdiF-FHAuUBLg2HWOjYYfeISDX9+qAZFP0hIDmlCBxVIHi9hzIMOB2RgGBQPvgegypHCIioSMHPhWHJq34oxNYMi9hGHbzGYcUfLBRYAcFGOAqQJIe0GJN2IJOFAR8AygLuBSgdVCrN06JJAxgsYbmBWhE4YJDqQbZGUG+AKicJhuDBIR8S8ZAsFBF1gtoGfTag9kDJTiZ-0S7HaDXjT4Jjly9F5W0DHYZSE4xoQ7oEUkyJGM1xgswbeURg4gP0hCgz7VwE2hn4EYAjA1gLjg8AlAQgAOBRFYWDgIhrFxiRRwSIgDlIrgTYE4lxraQPmtHHZCnRANEGUCCQqg8YLtAtoIiV9M0DGyAok+9BzEL1smO3giR4oS5FfURZZm08APQfjAxtEjDmxxs8ba8RO5E3F4CdcH7MUml82wV+wLQI7TBGe8ITAPxm8WvHIDl9cdaMJZNNbO60Bt0iBDn3wJQcOg19NvWLQe0PDR3QQc6JA3g8NxwCGCz9CgH8Drt-ObIH-J3NaUOrCALUsk7QsZbYDxQjfEWSYC5AWAkSBWwm0Cp822WnxY1ywfsLUDqfRew1FrATwmk9U-FsILQsZccm8CJQbsN7DIdaLwy874csA3CPPZLxnCXvL30lY7tLOygZbyCwFXC+QPQB3D-PUMWvC+PLIn3DOw1O1HBA-fbSgpWNB7TYtfCM80qkCYJTlT9rNeZxzCh7LciOdPaW30W85nSsC18fvH6yZDjnE8IT5SyO50o07nATWnBrOdzQQAfXQ8IT4FLKhQwjpUfOFcxIA+pQXDhLFCg3QygyywEs2LAvy-Dv8CeCEc1g4QN9M8RbaAuFokW2AeEEAWuRjU6gWpEQjvyDbQwARYLI3RFOIj33OMRIsKjxtgI3HggihbWZ0R4DgGCI+AUeMCKfC9QBS1jdrOYiOMwFwVsIoiwGKiLpcBbACI1IRIuFSm0yI7rykjC-RSKbYiNCCOT99kWyLbCzAR1C0ihlaUDkBvAvsIXCBwhsSHCnmKiNDExwwcJp8nmLyJsJZw3CMgjbzeKJbBWwgSW2AFsUGUcjHAC8PHIrwxLwy8KmbcLyiPPaWFii4dCyKyjfI-yPXCioiTy3CRPErwk8HwgwgWwyozKKeYIo4KKii9ABTFZ4LvehCCiJw2nzxJSoy8LvCRYMPEKiDPBjyY99wiyK0jHAAPgCj6EYyL0AWo+yKv4Xwjb0zskoyVgbslLCw3yQCTPQF0DfBKMO5sQw933KjewG3yEiWwHSJPFiwqqUJMTovwQm91ohyNuik3d10cjXI+cPoQBJcch6io-Z10SjPoiqLqg1wyLjGivzMaLK99wjKLBi9QbsKqioYmqL48wvSaNy8JPffFmi2o+aO9ZHRUc3usHCX8z1sTaccHjJTnf8XcBsQOsLRAGwwgCujnw6IFfDyVKmPdBCwtsEeimY+AHZjzcBSHLCCgSsPZw2o36Nv02om+UFitoVvUXJboL9DHA+HJpFKhF4cUPMA07duyvoeY7KOqiGohT1vC0YzAhGiVwyqNGiDY-fExiQvCTxcgRossC1jfIyGIQEDYkqIti-PTTyNiWQZGNNjdY5Dn1jvYovHhjbYiWKCF7Yr2Kxi+Pa2JdirPAL3hjjYuqBRjHY72Ni9I4jL2nhcYxGPxib5NLUL0M6LYzMZMbeM2egDgmQHEhIgGt1Ih7sew2UCEgjmh5imtKJTh90zE8NH1AyLW2JiWCCeDYJjoKwgPDEYxwD5jOY-aLyQa4oOPojDw0eOgdlIlKM0ltgIGLrsE+RjhkBGpZ72BjJWL0DcAYwIBiuAMUXuKci2NT8J2i149EAoorWNAB5jD4pZhOYt4s+NGtlQYUGtsBMU+KDjmY1mK5Z+4yuKLC2AnmL7jdVfmNEMKw9PSd84bA+Jvj47SECvin476QgSb5FyFIA99BqnwhqAXEHfM+osFABhc4jWNkwv4vUBbi0wvQE4scLcmPXM1CTcw7jtzXCwOclQfBJgsLiKBPgBHRcm3BRvLPix2j+LFeLYt2YrBMVtEY1k02icyccnF8sEh2iJiLAfC00JCLBix1swLMmN6YM4yVjfi5ABSA-iDo4eJ3iffcy1USZyeRIFj-4ilGz9BEz3x3iuElhIJicE90BZA8En83cIJEtQmYtqLaxNQJQLBC2etYLNQgIsdCT80+JZEhEA4SIEoxM+i7FRhSgBt-WKAsNazA3CJdHbW0JqB+TWvSCS0sPlBoCFEiV0+ipVby07sQIyLnkj1IkH2AAskiABj4vEw3kYjK9S03lDqAYawrAIAZUN+sxQc8mVDiWNUKk5CtWOkeRoeJBSrd9E3wlMUKadEAgCOoQVCsxC9BBNEt69fRNuszE9MOBtQbVwncI3XZyI0Sb5En1KSFQo8DqSrgBpJAB1QraB31Wk8SgagKwTaHMAE4a43yZjElsC6TvLLzBRhNjM2EoRDoDkUvF7QQcBYpaE8ZKtELEh61Jj7Epi0vwqLSwg8TCknlmRM+QTEypMO7K20CwX3ZHWPCzkyVlci544xK6cNfInhZA1I9EBW9UHD8P0Tx4+KL8TEU1MImTBCKZJcJHrQFIMZd9RR2GtGdKcHiB8qJ8gV5N1fYB6wDMaHmNxwUc1QL1k5MCEQSV9QoE6Tv8bvxxhZgU5RlBWkF-megeHcpBgCCYajGaY5pOIERgKQFOAOAbgSCVbMu1Imnwl+sSIMbj8UiwDyTAHBPzJSUXeyEiNvtEABgTOgFZOFhzyGRDYCxNZ6EfllaOqAUQ2IpsVJ4IkeqFjpPsYVAlR69S9E2gUQUR1gQ2mAin0TIffMIWSDE2FNB0NErRL-ihYgBL0T94k8PPi-OdP3ASNEpFIySLohUDYTDw6jnT9sQ6hEBoayOdzQ05IX+F1STwsWP1TeE9SKD8yUvrVMQY-T+Wjkb1YYCIlNUXGGxh9qfRJzt0-bISuB3oieJ7Iv+H-nrT0UrchqtABcCKjTm0scFbTjcANLjUK5GUz1R0Qd8F+R6gzt3K1+0tJNbTu6SdJHTq7fMX98kAF+Nv5ywEnjRTDUkABnTEQOdJjSYlb-HflOJVGBUhDk9OhXTKicHHT9305JAfTq0naIHTJHIdMT9507-BPhQ5ATVbS81fxVQh9E2BG58TOA9PT8cBSdLlsI3RGPhT+UswBtkf4FbStF+eGlET0mU79GR0H0zBDYkfEADPbS902hO-DtdJ5DAz4M-IHxwvFcICrgBwllCJdKEC9X544MpNKpQWQqNOQz0-VDMSMSWSRyad-yZLkwzCYeWxPTzk8t110hM3RJEyvFfCEqQWUEZAhQjMJDLbAUM0DJ+C8k2TPR8-vWiJ2icUti2PCg4tNPABG7BlEfiNEn8hMAq4PgybEsTIQwhSZIKFOUzvWfdMSM+QXzPRBA4qNOETRE9CyItnrCUAUtLsaVFtclQULKwSyUnxI0SbMgtMKYnQKoNrhtFIBNTSQE7gAmCc0FzOfSHMz+2-sIUTNOfTv4s5xpicQesKZSCs+KOdVLNWvU+UdZEYFMRFY82BVjpkOIHVjrHYDIT4HMkiCQBZAGrMRiHM2qFbMps59PoUooLlJzibjPOK9CC41xWY4z9faiwQy44uF-iCYauMQAsEuuMB1YEEbMPDm4yLOIStzLuIBT80hPnjSlEoeOOzfEq6MyzvfMeMrsWs5+K2iUUypInSWYv7KuAH0lelvT+EydLmS94uiJazfCS1LgSXGAK3KNvIYuT98HRUxO1s6LLi3ISdfJ7K5jP4hcwL88UuHNgTSoeBMod8FFBMzMifGqCHgNMuJgmDaUYUCzBEIWgHrFkIJjg253QLU0hgGMpCORAGEjBPaVkTeb2B4gcyEDWUYU4v2lywdOtPFyG07aJBjb0sX3M17ooJEejbIzSxujdog9PxzlE9AzkjJ0vkHOR3KBP1WM8kz52nsz3SF1zp4HNgKQciXFB3XtDDUvwQhv8IFAGBGFcFChQIwOgC6h8YDh2rhJUjFCtlx1RzAMwArAJFmBgkiwH2TrqW6msA9fQ8UEh9kkwJbc3ck+jDzCI-gH0iSJAQMihPhNkM1SCaRlW-TA6ISDhChIRvSPB6g26EXAF7bPM9R9wNsHdhBItTkzkY6KvJt0lYaqHLQhVRcFB4eJDrLb0+YTGE2hb1Yel+Rd9LSGSJv8HuRAUCqCPOSDStbKF1lIlAmAXsvUuFB9snQLvT7SM83LFhgwVJkMIhRrbyCU4wgf6ACdMERcAs5FdHYxhAv9JUFeAkiMwB9lGrX3heovFbcAolZ8+giPzMMOyFPyzcC-M3yb89-j+9FYI2HxoCYMBUgkIFCFPMA8EG42yACaazjLcm5GeHc5HoK+UkhfndfxaoWFOoPRA6QLABqxOQigT59hAznNEDL8quFFS6IAiEC4ogjAqbkM4ThQ-CYkPzlpi1QTiKuBX5U8HJRo5HxlIxUIdvmjNZJBhBlZG8rCOL1u1BCTMBQeARh6A+gBvOs4TOQID6ZKgaoDqBzhIkD7NBYSYFEiQAiYyeYTAjcAs4kUGPlH5nOe-NWA2wGwrSdY0kWUV0gQRoFxxtMc90PcD2C51CAZ+f9BZ1hgYAGYLjxFw3hdoga8lDZliB1wJi0oegD6ZSrMcE+1yrEAC6xgU7cE2hfC9fL6sN4SFCMwWrHbyGIJgrbnjAbBdUCwy6uZgrONDpUIEilSQcCHuDXCgoHcKglfSC0LkQOIozV+AJ6BsEGinuOJ1+dD7UF5zU3kV8gmi8CUyLI1AkGlikkbBVdVKkN0GCQZNYmw+i3dULNlZ-0WPUgDvM8FPcyZwbyxqMkcwvMSBOio4oUhN4YKz+ZCfQIEA9bSADyOEbLEozBg9CloHEjmxSSLaMgDMGEyNPMq7FwcniwIAKM3ioh0+KZ4MGGMs3i4yxqMjYHYpNhfi34TBSDLUEsoMOXN4qoNkSwh2FdXDY5HhL0RMIqiQajd2BV03i24q8K-mUl20smxNwqmLytNXUwdlxOIvmUhXTiK6ASeZgrfIwI9ynZKETJywScllWkQrtc6RXQhLu6CnN9YwgdgCgAshe8H+l5iMUt5KESwQwZLNi4STyBYS3Iz3J2Xbl3spmCiVjfUUIYS34B0PAtX4VcQEcEXRcQe9S5hT5QKBkBUlRJMCIoQzUqbEYXEVxxKXaWsiBU3SgMGM01OGBOgQwQdakasPCxR1r08BKsBf5CWGUFTh6NTouBpInYP06LvsCAzhLlQYdK-JudOMvLlTNBlyBdA7dXTBcZyLMrbZbSfjE31X0tKCVLWRULKhTTHRaCh9MwFayCE1rCoVCpzqCIQdxogGGD6EDwPahxAKiCAFOttAdQJFAUgSUtOI4irCERLMIULORM2rPYtu8bkq7HVK-gPYqhTAHdYuJ55nULKHFrjDkvgin0lsB3Ljk1wBwjPs6aWABaAHA2vIA8h4re0gwhPloBE9AS2vI+XdpQiM0XGVxfLWrLshwClJGBmZKiQAh2eL1QBUv4BSS8hzBhbisCvgAfisEsCB-i50r5LbXeCpBKhSuKwisyHeCqhKvyUFKrKKDKznVKYK8g2ArAgdEvQqXSrEvCLSK10uxKfS3CrxFqSkMqVRAMMHicLXcxwFLoY4Lqg9AsgD2Hl5GkK7z0BPSvood4BNZIvNT6gBor+0E6ejgwSVeRtnHSDgJ7kOcDyhIsGK3eYYoxcftDDEl5AdOWLUqADN3VDMdkLoD4r9qVUrkAVyuAvs4GkUcBqNFyHqRqMjAA7HqxjOL6Qdo3wfFhMqAwdZ3igoAE+D4gtSEUHLpGAcfz80brGhUi9q7NuhqN2SyLjVI3I2si8ruOLoB8ruhAYBGwPAQKvWp4aUKrAZmC0Kl6BYAOEDMA9StTieS7xRORr8tAUAz8dkJLjluheIShEXgD4WOhrVQzYxXKBjoeCSd0JdFbQaIhKWbnCQ9AFyrqwjsPWAErRwEbygBNnIEQ5dhgWsh8MFvCNM4iiqvoASqYihEDGrDsEMG4YVyMLimLei-iv3A9AHqq6oyg4IvVBliSyj+ZDqjwuOq4ETVyTc1qsAGKqvOGDwoEqimHzL9WoYqBdAswBamIE7sOH3HAgypdwjKe0sGsYAGqaS34IayN8E4R6cdrg9A4VNLCErayYMEXpIySYBgSlHMBjRruvNu0Jr4CYu3h5EirOV1QvtbSpABoakzGgB+TPSp2pfoBhzjlplGSAUqSVDipFlAnfOEOs8gCSH8JUahmpGMzAXLEGFLMMAHhdI4SPwDCygdCEqlkatLET0Raq10AMIy7zF4E-vGo0kYnK0Eu6o-C2hVBKeBQMEfEIHHICuKbaSbkggtqvUANqugH-RwDR7MWzELTBU2sXQDAVB1adXamSHdrltb92yBbq4jW4FOEPmovk4KN6r6Bx-W6ljgNJfqjaLba5BmKh6UfFnf5zkVq1zoTax8RRAvueZSzrYDMCAtqUww4CDK5ANVWRBJgaWvviy6-uyh9TENzmEK9AMopMEZIVvh9qqpM2sSAeBZhLxTu0kIDprU4FEFLqlfGOoGA4635VZKvuPPlzpdakhUihFqR0MiCzysfJn0bmeAAHq6ICbgq5fQF3Ha41ahKOSrR6iAHHqE6lLSlzVilsDrqxwButIgm67usX526v2rMr26hWz+ZeaxUyxhlAZjMyTRwJWqJq5apMgVqkakWpgFf61WpXISao9OiA-630tUpk65AChyHtDcmHqDePurkAN6p5gNqBLe2tGM2wDBq3rtuHG1jI2GMwA0QgajJQUh0+aIFVUzAYhkJrLcqN1ipQ6j+sjJ0JfNXcrE6hHk1RNavu3Pr9KeBpoUhyXCsjL8GrBu9qW6juo9rzkPOsfrO6wusDrYq-Rnf536-mv-9uapCHL9oQ5CBPhiJSAMLVRIOQHYay0USyQBSQl3hlru2TrQ0hboC1lzAKQlaBuoKQcS3QhDrFGijldoeuARC8gNVH6gHGEqmEgdINkD94swSREHAZagwBwx1gG1AgkOYGUFk4HIDv3q0UESAEuwHFIWAsNqkbuCSRt5OyB8abg7MwshY6NQOQBR+YwH+BmIeh0EhrmIDIXVMoR5BSawlLqGNwyzEIkOgwQ08TyaoAlxuFNNmI1iUlaMITkcbZ9B0NHyGEbqDyb7QC0L2RQmrIBlqaFUunMbq6wMiiaBkLdRVM0wVoEbNZm++M5F3RZtiaTSQThEtKP6vJt9NtJFhQoQQzGwM7z61CBV8gD9SGkWcPUkEO6AQzfxrKprGSS32AbMUxtoCfGvJo0QT6-VGQA2oHFEdq-9bdG6hSGicGaBSAUGF+acUSAuPFm2Ma179oguAD4BD-G8FORe0d8ABbb5diBBb75SRC+5IWzRscAoWrbg9QwmnZq-rKpZZssADml6QJhkzOQBrJKqXyA3hsmR-wQBGQuRUJrG1KJjLNW-RXTOVptClvJapLCcHYg2GzWvjVwQsQMpCSMClWFTOwG8BmaPYWltlarzRlrGbJWqFrS0O-SdUyh2RQIkIAWcXep8UfqGyr2obTcWrtQ-1M5SrA0DRvw8duHVRXswNFT03rg4UPJtlTfqdvXHUKkTlplaOOeArSY2JRZoP86WzhD+IlgRluhaO-PSpiCzWsNV5hzGAIiCJ6Ef5q0azAacEttzZG4IHKMUcZtzbFwctpwA8mv0zaQ5mwFyjbKRdwShbZOYwQbVR+c1U6bgfcvKi51SKFswL3+C9wlbMCodsOqgkQWG2bo27Vsmq8modqbl6AVS3KS6IalNyB4gSABCAbQZ4iNIEyXtpnah2vgBWTH0SOo5YNCzgW3ad2nduo5aYjiKAqrMLppYbvIfUK5TXHejGQlp2s9p3bz6TZp1hx26lT2ai+P71fa32odsJUW221v9cOqXNsA6Z214EQpOIqwAA7IO9VFJdT2hDqHbq24eAQw3AABk-busoCkIEweK4GGEe0m0E3bgAQOD0xnOC2keZ0kyEGWJG25CBQ7325EHQ734KaFqBg6ZDoY6Z225tmwsO6UFEKzqFjvUA+AODog7OOzAtwzROsTpnbgOqUHP1SHQTu+wROwdqk6m5SBg47IO18utz+XKVpU6YQjlKJUZ6ZCQHL4OhDrU76OjTpmJ1O9VGWJLO8zq47UIBtRnpJSZuvs4GiOdo+w12lgEaAKmuBCuqfO2jts6322slMUaKOdqF4O3driCLRkALvg6N23NrM7hYctpzbB2wWt3V8zIvXvk54dZAJht-auEPkWtaVFHhBqQbDsbXm7kK6ogy4k3SaaWgJ1BQq27lXdBpAdVI3h5Id0DnhPCtCC2yprKzCNb2IENGw7623ZuGD1qRgGwgtqExhgATZZ2DyaKJbhRKg1icFn6wEA3iA5pMEJNvVkjwLjOy7sOpSCsDDCfcEqBVu7oEuV61XiD+VugPJrpBtFObsol-VRAD1bnQ5URq7SoGflVrF+ZhtUbUu2asJrhgDsKo5EIfVu0bdGjqCgBuFCkCMaiIExtJD3wSJnihLG2vNShem4JpQQ0lIZucaP6txreDPGiPzUaoWuZHebAm2UljBUcCAFh6UKQgEiaE27cHaSfqeJveaBscyGSaGcRpuUCMm1MzLVcYXJtzahQ-VD0VCm9wGKbHcsptQKQwCtTu6IkavMqpr1epuZ7fVJ2BXVHbVptBD-xDptzbb2w60R6GWUroGaHG3GmGanWukH3yJWiZqmbCMDNFJ74JSnNzKYey3spE-1BNrwQ1mj9r46XcMnp-bEGg5sCdjmw61OahYL2AubgzCiWuaB5BzruaBsiJHFQnm2HhLh0wens+bc9c1pQhfmgnCkt8WoFoMgiWsFtxwnazNHxbyw6UGugk+0FuFgkWj8NRbpFdFq0AsWrMBxak4PFtzaNEb+CL7iW85DJaJm3oPN63etQBekGWpluYyM4VlvZaGQovR79pFADCf8zwflpFrBWpmkdsRW9iIIQ9WvJslFUoDzTlbDMBVplJlW1uVVbcwEnq76MASdsSIl+3NsNbhINmFFNTW75tPAfu61rDaG1LaHtbHW8wBpN6IOoP713WsajUVoALMCCCvTX1tzb-WmayDatOb5VDbwFCNrfkbem4A-Ae+4lgTaNEJNuPkU26-oP0M220utts2rRryb82hgFzNXAYtuS6pW8tsXBK23NurboB+KHmbD+i3pgGFwOjrXSQO2TDbb5wDtooFIwwavg6R2kasoH8FQ-rX7IAJri4H52qlKVDvsDhmjt1LHtrs6h2lQo5Y92hdqeZTOLdpkGz2i9pxAr214pvbsabpsFQH2uVCfb74m3BM7GOiwF3psO3gfd7AHSzI-C17SABMGoOoMKs632tDvk6EROCmw6v0XDtLp8OkAGGFPbeCFQA3wEjrfAzmNMzfAbOlQd071Ueqg2YfwMpknwSWbTG+a9AYAHPJyO7kHsL9qMHyEHJOlDuWIHBt9tH1mOhEWiFilaQeiGUkBRF465OgTtKHFOhgbE6Eu0zpgcbc5Ts47gO-ASM62oQofE7Ch0QHg6bO+Du47aYAgRc69qNzr0APOhRK87Q+3zu46YuvIeC6OU0Lr0BwujzUi6bAaLs+JAuuLsHaSBogYNb3VdLrkhMuj4F9S1IGJPuR8uujm1giu48BK6lJXoOX8z-H+Vd7beuQDq7yBhroO7mugHVa75HDrsm6tlYQJ67z+tZtk7UaWgaoHEiAiQ2oxuuTgm6tsy8VoAZugMBu7P-RbsoRluw7sQA1u8-qa62AOgu26Xe3buTp9ulbrxHjuvfVO7dOSRUu71ZDEYW7OEB7v4JLBw2pVq9697sQAw6rGC+7ORq1p0p-uv6snya+8BADAfwP70a9pSKSs7VVaJkMaJghMEpIAIUaIqVFygeQA45WSuUBSBP0Go0l4K3XUOPFOI40h0sIyJAABQ9R0EuhdU4YlTd0XpWUcQAfZKqEtGtRzaoAbrVOQCzAoGswAuLpYMb0-R5lOIy9HtxLtwpAjFeORYAahWhvvgvRz-U86Yx8Ma14TyDY3fBJoJAEyBf9YCUgqVRjY3ARIUB2pDG5oA4wLtIgQgBVr0xzMZVGhfCuubsktawHzHsx2MagBQxkschQyxisbbYMxg8SbGksNtguKJITseoUqxw8ULKeWRsbMAi7CtFWkix-BmbHWxlaInG6GjFuHGex1GRrGLAcMdDG9eO9IogmwLcbmgugRcHggNwA8dkBTWX0p8jzRzeC9Gxc30fqB-Rs8ZYAXSQMY2NIx2VhXGgrQccux6UG8YjG5oGoXmUDRpCmOK7B4lQWUXS20fso5KJPKPEYJuaGHcEQVJr-ULsbYmQA-x+MZmHwyBgHbgkZRXVQmNIYhh-H0JuMdXaZhmMeImkADCdSBnxpmwcK5KNMkQnS-Gcnf5MHelFdGDgFZTQmqJuMc1HGYz1ktrnpbXUdGOGj0ftZP0PkHSrr6Fmivk+JxBq-I+JtKvFHuhblXhpdRjji+93LM0fYmJJ-2gdHbR50dkAOJmhuYKcI4WWE86+SLkjGgivmiNHxeyIqSAPKhHmAnK3FzUrdJ62SlzoXJ3UI8nwJhEBewIAY6EChZm7G1GrhJ20ZkbYOjcZUjOtLyCHAUeUHMPKZyKSblAtkAoAoBbJwvPvArgTKcUTAWL8CmEOKdhDFEQAHzWio6uTdtgmKJuaAYbua4TzTIPQSMbc6nO3DptGOafnxqnejZEFrI5JqjSgjv+A4HSq70xKbe0NKpIq0qo6K4EiA6IcyBagM4MTGGB68z9EVgma71MfSmTKu0UnEgKSdUnZJq0dzopJgiL0jRg0iKuBWKhKnUt9Jjmg7Ex08HUrBFJ8nnN4EIgYrDpNKoTRprO8lmvoF6iztUUnVplOlCSDIKzGRgYsZYpJUeZcKY5pDJlgGMn96iNIoEu2tIZ-AGuNUZdqWSukWKK3uaDpCKwJurlqrHxGDqJBqiy+uB8B2yVm4GZIJuoaIpJ3SKIiTpykTOmcgC6eGArpxAB2GGJxS1SHa4EsLanEAUQFLZVYd7miB2Z3Oj2GPo7moVcoJqyZ7Gpq4WdtqlK5UcPE70p6aSndpcSomnheWmoHkoJqqf+m9FQGc5qL6r6KL452kSaCLAgEYlG5t6moCFmauL0jq5fuTUH58LsHsYKGfqjPI0lH2l8BxhTwRCBbM2ADnJiTleugFJCMtKCZ8FXBOaFmQ-G2Tir0DIY4FzMg9UxB94MC+qrpC4WwoCda-HHGFZEy3DAv61q4Pq0Qg5IF0x3VeoVGgw9roI-Ncx+qY0nfgcYZWljgi85CWcdN5O0z7hrk2ULkgMCk8gDBRVdEB8FR5IWG1C-IXUNhgDgDv3aAO1REeJHGUk0s6B7HFIRwNK5rTil4RYm+VblRVMYqVaCnPQFlDXwOvLnargA0hI7ezfhSQB+ZsfRXnvICUDnb84PQM+IAIEAa+Gb5dJkCguoIkP6wMtR7A6D+Ce+bqMouOWrGZP0HmzbhO2fEVtGajYbQMj6+TQs4bfCaDP+BBUIVUaArbLOVtHPht1VuHpUeGm3iikiUubLZhVNT+CtrTNVQWEAfPt+hoYOYM56CzDBfgh1YNoHghcsAYVoA7UV0CQAFMEnFoAIAPFDaA7UBbAWxSeu1H4XAcJAAWxOFpADxRAcN-HYW8UJADtQN0LhY3R4ITgIHKwAGhatt8QDBanL6AA608Q9qjRf-n1AWxWdD9SqWJ6TRQvIpYc8EDCEBphQegriBA8znIXtDMPQJw0X0gQiMBAEBAB-AfBcJnt5CMYelfArcLaEAV-Z+GASbhIUxb-kQwc-M8ZfgBfM9yB4O4K8wKkBGu8gY86TgCJ3QVEeb1v8Qefx7XgXxQP1CRmvPCUtoDeBzMUenJYu78ltxZxsm1CJYjLAod0EoQtYf6FSValy+1thsgdaCbN6lwpayHR+bUi-gKUEAOEUjwIiX6wOgcBBIUcgNF3o13TCeEvarMEwM1RWlqAqs5Cu7yBtbwaSVmC7nOPZczHrOQSHhlEzSSCPrw8iGDnUDIJtRgBkRFpbdBRMyVg0KMANeDYgIuWGTbsLON1pZUfl5zj+XhBVqO3tv8T2YJhes0qFcXJELIfiARYDoCUgagHiTbADJOSmEq78vEQfyqOyjs+waKDFabEsVljhxXOuLchFhuURmKbBzl0FYJavMUWiGwqcpGUOWxOTwCgA2vCUCZXT-WgDZWWQJlZPJ9geAG5WXaCzlmABVgtC-J8WWBBEmAxjjlAXZMASyN4kF15AfFrOXxWNa2YTa0sg9+xcGYL08hPnf4DORVYGBj2n8sYbPqv9oVHIwppz6ZJVqWbKg4iW0cUsVyLabO4DBH6Tbg3jNMx4BvaigTJmWwNrjSxB6xPX-QnJhEE6LnV7GYdWqp4hj4m1lUfR8M2YUuiOm6ZkiIZnuAHJc3boFkiRfLchhPgpmCZRks4bQ1zYtpmc8+mc1mNlt0AzWy17NaYmxZuV3N1B5s7xAXSTSYf-mgiyYRyS+J01h5sfwSExuqUPGiEgl6IHFB8HhgoMwL7Xkd8fxhYiNMiV41YQjPjgi1fEIcXgFHqoqRHbfHvW65s0oDnVc4VBCSQjAOFHJA-csRSipAZiSzyLq9FOVvFsIDAPIlfK5hAngy5twCY4nAYNuVgHgx-LMB7QeoE3g94XWSsb64AYWMEAmpGgGR9u9rAUUuOTnvrg2+JVLsNv0tql+QTgAIAGEQZbmcPJ91h2HyBqoKKmfW1IEFAqQkC4VT95BUDJQHLK6SDYDJZQmxv-ROkcjbahtYQ2AHLQNGv1ugVgBQG8h8YcWvqKmkAZBJwfpgZK0AGlgmgRRxIY1waXL86rQcg-RzR0SY9EbvgCBYiMHngGeJL+cMh2qFqgUxBhNVvPhxIeLmuGP4dWVOUPAMAO2haEUzYMlUEHWFYggylqmiAFAOOZmJ3hUgB4A5UTeC6CvkIuk2g4ip6Cb87-ROGFCz3XRPhoBs7iCthbeVCG04kmW0z7MAgWvJn8vFckIqBhN-xYGRtgw6EMIQZXzdVw56paDagriZhBX7GAT7AWwQZFyHSAJ4YguB7ZAt2CEdB0ZiLUgh0OOAHLtoDwvuGf9UIEMJHW-rAzhIVnSB4AAgKpcvb0mFy2VQkYP1XYLzYL-0XhpQ6swtwMMZKGlDbSqNXDA2wRhXWouODdGf7VI3YPcwv5m8GVMuKoN2GDlNustDAbA01GKYv-VSazAhqG0FGpsQVdPHWIVCpCnWDgGdZO28oEtLz1p-BqjxRXAeCB-dhAtDcE2UobODiWiMCJEVDJFRLbtQMAbbZsCDN2Ol2gh1b2HrgMqH-tpQglAIHh28UP9W66hJPbc-kRwW9U+Zy9awDuQxUyuRSgcFRZBcZrZEnB63KEbTZBlcwG02U242q4lfy-hAIEcUwJPBAubAYaqxh3TwP0hyBZSfVB7kEAwHb37+sHBTabmONOApAXcfqhFwDqKSCsZG+AJhsg7YCiWiI2JUdd8V-WkJzMZccbyG2CMi-VDYgzeX-InBKugJH6x2d+LZr94AfgJaDWWwDHod+kZCam1CWQWFjorQpqarUIgFiC43lYRVXthSoCMGGgJVBfIeDY97IACBzGC0zGCUlvLJYAUER1AdQyt5qnjhjwcCAlTbQMQLUC9UAyHCRQgV-ziBl-RVAMghVF0Exg8gehHj2KJUqA5FvoNRX9IfAsvbeGru+aAeSMqLvfMAG9rGCwHGUHRuwhaMRx3LmYeDdDlRYiSmnthQxmoQDQI8XEA3QZdl5fdQzbHhRxgP4dfz4qhaShAy3Ydhqgi9dN8KFhRmgRgHSDDRwvPLRKgSAI9QV9SpsQpK3NUzY3hYAYCjIIUGMkQB-CThATaTgn8C8J8UATaNYsgSACr6t9zFB33vZ7VD6oFOYpnl2M9U-YZ2dN9nby3Rtm-cZQJ4Jtx9bDlHnoMgGp83htN4MOiE2h81WUUsR+86MgMlGxgNAWwMAXLHxRvAiA81roDnsA0Q4D2xD33lqfqkP2uOE-bqp-tnjcwOAEbA-FbMUPA8XiCD4piIPaKeuFIPzAykIoOwzaZRoPDlW-N-36D5u0YPmD1g4O6W4Dg8xaYD7g-uRd9hA4P3wII-aEnpYxLYjw2dnLKwPr9qQ40Q4YfpM2DPCyfY2IgQH8A3QnUZg6MPIDjFoQkuD4fssOUoRA8EOUD+w4ap7Wi-ZcOJADXekhWIbXfICxoPfLPAcNvIFOUz7GvdDLmkwzEOsWAn9Lnr7-dXFaRXgQ2G5MdswKp12ZSNQ-jmND141oOdDtsYhQAM+nZs3AEVzGeg74XgEh3AFKam+22oKFGAKqmu2AoOREJGB4ADqNjlZgLDILDAQAy2My8A45mQIkAsYG0zKZuOBPqGwBYWUM+2gKKArCVT-IQMHg-QF5bvgOYGoW8gON4SFQKwlkiTSa6c-3XxwygptSIKNsp1s5CxjoHlmmoQZREccAt4GuSwq9NJZ8YnF2YEIAw87Q7gAWp5t3Nx6AN4aFS8A3mH6wBgf44mOm4KY4GC0IEqF2XhJKmEOUvCYI5MOFC2vUS3HUFg+03yTqA9MPWOWYsnkIdh2Q2D+DpA5yhLg+U3OURDuiACAFMFg7EPnDiQ9cOOW0rWxpJTU+TLhbdocHuTj-E8APmWHfrC-9XTd9HToAQDxbhrZxNiCgF9UKIu5AeAPU-ZJYfbQtoQkANYRtBO4AA7so6SWwAoh7TksAoADAp8iOI1wEWBXBsgYAAkgd4CeGEAMSZ08QgOGCgDXBPT7053h7Qf08QhAzjEhXBEIDAGxJbiUM9sAvTn08jOMSQ4hDOPTlM-DO-Tp8mTPUziM6jPLAJM7DO0z-04TPbwGM5XA8UfYlrIQzss6LPWSeCCUBP8QxgNLxOAeYvlfkUA0dsE5zoFoKOYW5b45QEL1HyoMAVAEfEBCr1F9yVgXEFQBbthJEvEMNjxZ3t5i3oJJCiuh6l5hwzWKHYg74NVYg1s5yS0CDqSTplxRhg9pp+o1AoJVygM898CD53bDZBVg0mQ5X-3oUOyl93tjhhE1Ig3C80pDxGXYhuIXT64izPGzvM4bOcz8s+eJEIL4npJ6SC4iRJbwG4jXAjiRCDeIMAKwCdOXiGCFZJELlcD+IiSe6HN1tIegTP4AARXmAIYTn1mVA4Y8R87XfLMbR880oBbKVZmr1Y1tbnDb3+yu7VWkxSsrK8LEFGeHehZ58WaaVTYyYbX1rq5hm5gUBA7Si6b3-yWi-ov7ORaY3BYJ4QEtIeJYgG-KIGM9PHNrneZ0x5p06vPHo0VjAw9h2IOA0l74wtqinAOx0S4TK27clEOhxyFAxcuPYUVD7ojTwGZmqI+RUExAKAB9KwRq8jdrBmZyMS9JtcbPHyku67e1giBZmPy6oKeuHX247ZLsi-GgFL6i7RBlLpgbUvgADS5DPgAGoH9OeJFPhqBtGa1iJyFKbXNe81iE2RWVA4QZxgmmr-wRABGQdMqRk0rt4lwageYhj7H3wAcZncSMDAyzHrAYhgj5jcr7lNyQAAqeFh4gDcDkoSeYy8xAF6Jei-A7+SsBWvlQIiD1RH09Ew9TyTD00mghrnef74WeBSgAhBbSNzNWOwbjoO8rmC03kuqLoWLOPbSVChBGqCwmiOMOp6-bh5WLslEDh7KSYhSbyqhG0wDNj+3r6mxvBK+G95mZCbOiia9le+ulAY7UFMjjBPWe98Wcu1IvnrxS5yvsgOi49SuvX65wn5vWqbV4tvBO3dnhPEbEs0rJt64aJcbzPiyvXrv66hJN2hP234syBG-3rQIci83hePMrz1rZxSeHtAT4QPHDwG8e0ABRzCLoHi81OMPnngWIEPO-x0Qo8DtR6JCU8d4b5dW5gItbkxEXQMCvW43RH0OJIKBZrfZdAgpgcwmQ4E8eoBnxsvDPNAhs8H2RFgbbvjw7jzCNfH4IPb8WEvwD8Ns5-xQgV2-dvbbqfGLFEgQHH4IvblvCBtMCE+B9kpbmO4Tw47xwgjuZ8eL2uRVM5thiRIxwVS0P3zypsVhiGRcARvt0DRrya+SZCZsBzea8iLuxRXNuruzjmwHBa7qUMX+lywRoF4BtZOAnN5PIAoE2BryBG58bHuspQ9AG7xAFJuobuWrXPOwT9EzA023v3sUqR1ZBf3saPgEoaMSsGDTZQS2euiqLJ8FkSAZb8wjoUoM5WCZ5P5J2sx7XmoAa1NP10kL-6fWu5LTlidgPIiBf4LaHaww1aUK6r4Ra04-OAKERmwk3pQgIeDP60EponwMmozpuCgKrOTw7CN3Ron4HxIGxU3dNK8rIIMrgXqvylZUAJIIMt3Qlh5CP24zuugEh4DuNERB5Ae3bWJEoRiWMVEVgN1iVFrNeYWgq3VYe9vS5zuyRUz9z+kAEIShBsIEBUlxLtNiukYGUCGDJByde-u6go2nx0vYG8WPnjwWbYCIew7+8IDuqV15cketyDa-LBtHzEEnI27fR7wfdHjiDfJ4L6ij0ehBLcj3GjH6x8xA-wOx7fJTjcK-pkUdR67VdltSe6mgVoyRmIY8UImV9LM4h-jN4PGyG792RgjwEwQ1Vz3bthJTo3tjsWlN68XKEbmhhTNtYV8kpd2lSoAAfX9tXUgBPHqzIKemBHJNSfin6VGeILx2HO-x3ITs7AgmXcJ+2PTlDeHJh46+QapJdUrpMNKezFebNLHxY5t5guYZ+E040c4huxoWQWO7Bt6bRO519QIcOgBQP7lB8LpPHjo47GrgSciszhPcOlZuln0BuiAFnk8ngfW7dVnSeDMH8HKfWRFaLtR5M-Z8Wfm7T4lWfyxq4HwfNnhHm2eXr+B6nHktVPxSbshDq6weTw2B6WfuOrGQmvhlDREIZxrsUh2fm7fP2bDkQeZ7ufwHL587DkHusa7q5h0F-PCrOaFsheYxxF8OfYX77MJzarw8IufltAa6-Hhrg9VQpCntZTxSb5HeHT0ukRjAnqvUY8cXBDA+CGXA9wIKKKDQgIVQWRzzc3eWemNj6xaUcXmVTYZUrmS56uwQaR58fQGUa8CAz1sGisyGX1sB87aG3Bs8egn-BeKnn0QV9fEza9vYXNhlNqSgcYqpBsFd7HicmemQYtF-AdmNawEdeCxi15qvlI4MnJ57XhKOuZxyAW6FvrAdNk9fbX5559eVM+Pdgf-VPdR7gAdROjPOPwSSGWysCgBFk24VFhqolxXiwCBe6x516j8c38B3deeLX58xB-n+l9JfqVhmG7zFoRcEZANQ0ecLyB6YWFvBX8u+S8UqcBq63J-n7dDYs1fHe-9odLpge1f5Xm08VeuGZV8CeALbq9LfOrk8PNeM2fx-pfrWP17MAA3+oD9wZnW6YBZsaccjFuJb6cHaUt9DPSFh-IfBUtMVwUxzUD+XtlUOzhX6hVFfpUUZ+GUpXtV6j9p3kd8AfOGFCiNhVX-IHVeWsld5Pv6gNZVnr539qVV59LmtnMf6SVWZnJZ68D4XMV3vd8DxN3s8Kg+UeXhEsezHlHnL9YPnlmuZtgID518KaieF6AOECFBSLcn7Gi-PSoSPP+mGmwJ28h9kp1NPAnAeCCcBhgJwFxAOPivLMAnADAH4-DZie2tYuntDzPnLIc0swgrSgiGGfSIZd6Pv6kW269uHb0MXQ+tyXD6KeSGot4ntIP4x4I7THvT+3IsPwz5ceUbBT6A-UPrTmRACP79dlv6gQ981Nun40r7M+ni0uk-CIYiDk-EP8FgBtJn+O4zuoHPCawNDuiVyMS+3wIH+XjYv64TLU64H28eM6kGOGV4xBV-XGDed9+8ev3sBiNhPnWXJhvCX5F7JqUtKB4xefOzL7y+WAKrIEsMHpgbK-rnqTYq-7n6epJmKBZm4ouXr7Cb-UPrlS72pLMaEQVfp7uHmjWP7rF2FkNGswD5IkUMBRsBGgFYHzageFkGCKvKbGssalRv0emGbQDr7ABhAa8ktP5oOGsEtkICb9FRgAUHj7vAZ4YF2+8gIe+lHZxL0B5IfR0Hg+rKvQ75rvdWQGeHu5yYs3G+fOByBO+-zuQGvJ8PG2gAvEfc8M+-KQISrNOFa3b6o-7uvEaeZ45O036K1Z-nlI-uiij-NSGYDJe9g7TIT5uv1agt7decf4s0eeoSF58JKkXon8R+SfxsbWeQADZ4cr0XswEJ+W7er-gf7wFn9WNXXiFDirWUXn7vGZvub6XA3Tgq-B-gGK596+nXitHco27wSHol7nt-d1DQYxPiAp-zgDDlJf3fqpBGahUfmbgAnjs7CixJlpTfINPtL9ZQ3WCQFu1gfRcH2I4CDcBqFhATYATPGWj163fZlN8kw-YvigRt-bwO39ySJAR39uJ4Id4hd+9L33y6vgfV3G8CaKHl5XALCvX7btGyGD-B8VisI2j41wHiSuAlAX+21JLFTmep-KQY8XsEM-Z+o8BOyb-dwf+eNb6I6WATb-H9c36X+ynZrsUAIm7TMr8bGXSSn9Z+QZe8Fl-vIFyi7+xx3eOr3olUb4B7xv179F-ZAc5-O-IbyYmr-POzb+2+wdm7-qmz3SLin-nxuf-5mC-+oltqFXIyjz+6lXf8c5ih7Tpi0IWKFglhCueFn38svsX6cK3dOg+fqf9mMianefjwGBeM-MjW6m6D+ScbZppLLx5eK+Ql-FNA5lNDcEbqYV6lNYB-aHAtz6orZnVP+I-oEgBggN0VSQvjBQlM0BtAEV1bcAEptZFk17jrXBtsv0k8AbeciQodB2Tq2p9SlX1qDvMhJFAKZC2gvQLTByxxAjVRf5jUUuLmTZLxHQdalEQC4eAJdYzFVkNVPiweAQ8cfeBPoS2GmN+xsFZqXv3xRAXwDZeJVdU-vj9jZh2BRWEsB5AY8ctvlapkqB7kQUEaEBArnM6kJjhWthVARaNAA8FoC0DMimANEDnh79DYCYWt2AHAcjUptOEc79ntATOMHBmMLMADMOgp9lDGMnxG6B3BBogTAaSEKoA1xLAUm9PDoZgq4JUE3AZKgb4k+hBUOhBYgVflozJPJtMsVBdMgG1isKUAeqnCo+UItB2HiV1v1r+s94CFt8JCepbYO+htHIygY6HExFoNAs+9JHI+UIxV+ls+o6gbaAGgXEBhjkuUWUghROgb-JaCnXw3Ulg52eIMDugbvUptLuJ2IuMC6kPUC6rNtB3JqMD+gZCAcDHvIbYNDwWFIEkL9O0Dv9nwhxrArgPuP2ocQpfk2qjaYp5oEC04E5gzmvFBiaE29WwmYBveJ-lOENiEeQLHB5IJdQajnSEfgkw9f5L3NIdkOchYK4sB-Dyg9kHXJf5DERS6Cgoudrq0k3r8MiRuKo9VIfRvbLcsN+q9RJgHQFHACQMyBvDMTZhgAYQftQUgdwwbzAvYGiMr8KAAvYCQedEwusMYgil+QahAP82qtSCLMIMZIQEyDTDNR15gExMgVHMQzgZyDi1LgE-gPVR8gCU0fpNQAd+ntQsATmIgMNQoDzA0QqQflBHsCSC26JYAxZmQJSgAcNdcA5glevpVmUGqB2tpXsg5r2gQ5hiDmkNKCEsvRgLMHdAbNsktTwIMdczLtdzNryEXlvyEvFDi1eQTUFW9GZJxUJiDmEGwoGFL0gm9iRsXqPdQkYJ9gIlnnB+OG8Mk4FgAPmJnMyApKC77N4oV8pU0wwS9Aj8tIEfFmyh7kCLQ9qp-J4mA3NCoGqcAnAtBDgf70HcP4xZ5odAJFEsECYFkUBtlmD-4Gl0XoFcc8ugzRncFeovRizhL9pFAl1vZBZRFXB3Ag7gGEEIofZMXt6erBpRHHNx8ZGiC5BoOBZTGhBrQaSh9AX9o+yrmYY8km1+TPbY4zAxtolGwVpQbQCbAn7gCRht1vFCbB9sGph2enpwzACeCyqGUtzwXGYt1JIFegq0hN7sAo7wQiD9lk3IdweYFIyif5NgqzQkkFy1k6FixbwaeD1Ur+DDoHEo2WkE4EoN5ZSjnksKWuqhvgvpBTqKSw82tjVQ5FkcZ5G1t2nJXthIA7IPDIBlJdgEo4gKVRfFBTZ8AY2DWQn-IOtCEBpUjIBhgH4xvIFt1N1GbxUQZ-dZQu3IpqMEl5jtoEX7pulyMr1hwJG7tmOIzAFmvxFkAPpFYRnghYiIECBIokQ3hiPNfIL1t+IptBoFi8tqmEbgPGNCg-9CIdW6r4p5IVJChulfcvkPz1YeLHkXGGFAsUNyATITJDQ-nsBhyrgFa5JIpOsraZzAPjAvYHPAXgVOInQpRAEIAD0q7t49EAsMApgMFCpwFN98+osULRmkDDhi99hMiFBgALmhryJ2gq7mxlM5sAApgNeRtvIO1q7olCbACfARQfD5tOLMBryIKC4gk3cMoUlDAFtsBOsteQlQaNZ0oQVDgALVCzEG3oGoSeJR7ih5AeuN8QobmgwoRFDcgFFCTIfFCJ-i1C2oe-Q4CNFCBIgs82qnAQBofUhNgNd9iQc1D6cjYBJoUzw4CBQBFoVMBniCtDrAXlDqoRtDO0D+BbRKdxn+NTxryKkA1of7oaoadDEAiq5s+vpDywNlCXFLdCnfCdCC0GdDmLvMAfwFMAGiPVC4fB9Ds-F9CCgD9CPUv9DAYR1ClgbqEQYZlDbImdCGiJdClINeRrIq9kJWk15hPApDkAMVNbTv0B1QF9IXuCUVKuDjM-vJUV1QDn8xvkd9OmH99sgAtDhgEVDy5iAY30KWDHNCZC5oaYYGYUtDrvkOZD7ju8BNI99HOAf8nlHeN38v+JHdDhFqYSmRgAI7ppoRzC0gdzCpgMtDAft-hQIMSC7xpLC4Zgd8J-i3dckrfxUEMVCWYXrtSoOzD8wMgBOYTAAlYdd9hlHzDKFMVDGplZwnJhSUEotl9VfEx0TxGoBUgMq9kfpKxiQTQN4VD7Dy3uH853lZxhQeXNl6lzVpcqek3yqg1Q3F+VrruZMdYc3dr9jYAUodFc7YSLClkJFwcbDXUPRtcUQyKSw6lIio2fEO9RjKSx0YQioMVMVCg4fRoa6qZMZGl9U5hoo1G2JXcUwFC0U4QwA04alCewB3DXvm9DDSO3CXvnrC1rnkBryLahe4chA9brAQ8FM45pqAkDaqGPJWIWkDfFCKFvAu0kwUKLIuEKmBSNv0hLFvop9loO1YyJxDRVC0DaUDuDBIO11FHLKISBPDQwnAiBV-tg84fJbDjODjYVXjJh-riU46rvBVC4SyNi4fMo+tNwh6JHIUBAGy8mYfkBjYeqcujspACut0UuoA+cC+o6ZzGDKJeeuDhSoVAAe3vgtjob5Bi5h7B4zqXDXFrsRx-jTCE2OAj4AJAi2YY4CYoS-DrYarC5cobDmYVgZWYQ215lFSDForjYnVmkCuQQBRAgJwjmQY1DMOrPY4Fh6Ns7HAsDVhJwjVqZxmlA6IyQVikZLNZ8i4ZMY2EZd4orGkD2lLyC-gKHIYbm1UrMoQjBSjp9lIv7DK4dojTDL7CYtFFNLXkpQ+EZyD5gpFxlBiIiEeMoNxEUZxj2lb9R2sojrQUKMFKCuQsWLJFO-joiVyP7CqFCYjD4OWUDSmJ9enpJ8BnlwgPPm7svPiDFwMCaJrAEYj9lLXDc6EkC0kRG8uzCJZxPoQgoke59ZPvYNcvokiT6C5oLES3DyBEXxdWDP9OEOGA-FoFgXSOc82wC-DXBD+AgVIKJ-ur1CJvgq9QofUh0oXrCPDsM1tobtD9odeQi2Eo56BGLM+4XrC2oUDDvqnlCfvjYAZodJCjMLQjuoTqd7IUZheKuUUlYDfDg-ADda7jUip7kVB6kTJBGkc-CV4aSA2kSeIHJjjCkAHjCCqoTC-mIAC34SACooBMjfkDRRLSNYBYEC-D6lPLxfutrD3+DAxiQfKDTuEoJiQVaQvyNAswUUmAyGLnIxnvd0VVGUExvINUWACyCXSNwjWSExNUgAeZilEmAsWN7CpuF+RHmHijyQXUYsWP-C4dLjZuEUxNYEHij5eEzdmkWkD-kWYhhgF5EeQSBMFIAyizEEyildCyi34cMBTIl+RK4WSiH6qO0cbB2EmJnChSURYB8UdsB6lL-D7ulSiH6LnABESqCS-PK5kyCZDtkZxEpdOUBNwKcioQB2tfkZci5ANcigkLciTIQ8iyinqjGfnsjzago03dI5VSGlQ9VAXEBEUYwYv4QfUUDJMB6-nsjevg6jy4YAdYvqO03wJoxhgF4ikZKai2quFVVXsci-uiat3UcIxiWJCiRvsKMJ8gDUcOsGRtTvVMvBpI9HIMVVNxl6NZVraQYIETDMZtbNUpG3BohOUksgBxtkJBUVlQJCZa0eSgG0cYMw0kUUrZoQ1q0TgxHxOoEm0SDka0f2irbMTM7ag+Un4SUNBEZCNs0aeRwxqWjtYQ7QW0XwA20cPAn6CyAp0VNBYhkTUJfNwJ1-C91jBBh0t0Z4h6EI8xUFkEpI4TzUWgL5JS-keiUgPui0zHUoYwNs4jSvoISQDRQE-IRQ57r5B0BoERmmCbxG-E2pJ4PfMZUNoFMqvMArQYZAZWioA2gJuoptAgAfqD3cp9kI93TIFUrAvvZzZE2VUCkQsNrKQs9Ftkj+APBACMSwgzrBos8UAphLrI6h3TMRjnPqaV8kQS5rSv4QMBvaUAMU6VhzMmQPYN8wLAPBAjiCuAkAG8Q1wPBAj4PD8bBNei5GNYB7wG8QiQDeifwGg8E+BI92IiLc5KJuiBfm4MrzPzxz0X2Yw+L+pUhn04pwFMIGoHiMjSPJ8waAeYEAF6M26v1RSoFOYWVmJx4GteZrWKIF-HAeYeQnwBLMUEo-Kv44yihEA3MUxMEQHIM-IJmBPQCytZnnuitXjUNRClZixkBfpL0TywQXvaFOwuZijFNw0dWvn4K3oeFRWnK8QXuzx9BPZEksVGRqAAFNxhtkNLohBFl0XWiqkGui5qp0YkNi1w4XoTk-Mb2AygpuicviDFN0WUNy6iuJh0eeIrbOojgfDOiW0SOjsIi1ii-NGj8Dl1icGJujPtIn8QADgB0eP3YHMnNjRQNciKBDOj2sUtilOhliisukoFxKiM0ALYM1sWpipoOkod4J1Anyswl9KEVlWcGlhZtj1gt4gdjsOu1jrsQUA7ZHNt6Bo5iisowt7se-xDsXUNIAO8t-qptjRskVlvsN9j+sY9ijsdyBs6hdjc-uvEQAJWVsGPNlqVjRjcka58pPgxi6vNn0p3sD5+eGJhwyNpAgcfFEjyGhMrtvQBjTuYMXeu1iGhvRc70YgcZ8k+juAC+jMIEih30eWArgN9h4IBUI8fi2A9lngsE+BTUJKhi5FwJSRL-MJJD0Sx1KkiHxgAC2ipsVOAY+EX4rXqXCIrAWpSQsdwIcX9ipoA0NWeOWB2sbZRXAHQZ6pFp1ExFbVp+ChANjMrjWtgZ0LcW1BkrOrUTLGVZhNNbiI3D49YGDgoSvkeiuSpDi9cQ5BHJOZxEKBrjb0Sx1OyFNAaenSJIJJABQpEi4rVOXkGYDIBUhoQB+ZvGtpyF05EGqWxwuITiJHiys7xmQiKEQ21OyAFMgpsYcOEKUQqZqdxtCrUAddJxEDCtjMdkRT1sdr-o7qMaRbMRVCWuMX8KBHmtS8UmB8sRkiNQc4UupEo4PQIQBJhrHjfOoQBLZptw3uEPj+1rD4IwKNBRar2jP4QIxiYW9wW0fmit-uTDm0TWi18Tn9l8VWiW0YzgnGIplvuPeka0Qfjr0J2iGGJWie0YNjzVIOiT8X2j22hfi21I6AJEcoFTFESFHbDxg9sDGoUoFed+HoXQERKCVgOhpiacmMEUirICTYBvAE4EvAc-gf9OIraRUfpMZhYeUAZ3B6QLVn0xmCrTBgkbvie0TXiTRrjMlmBy5CZkFxNQI3Ci+PviORJtB8rKfjKCdDBCceVV+8TKAAGIe0LAE5MWao6iVyC7CEQKgSIsaSYUxCitTyEr47pgNNv1pSE70ppF+7DwTRCQBgaBhANY1sIT8YKgTVKmjwaeCEZ22lFoarrHCUtB+VpXBFoBLFIS2oTfiFENQSH8Ri5sMtGlhPIbVMCd7V4CWB0OpLUVQIKpEBENYByxgKI36sD4OBpw0WasvV9VnoAZ3PzYFbFaowuLasMNquxG1g0tV2Lg8nUZxUMAFG9EgLA9V2A1MGXEG5V2GvjUyGviwibQA58V0BZ8UUBIOOwS2pEo5V2HcjJ6ubD-9Aew7kfpFSiTFD9IsUTnuobV62nIBV2OyMPxm70miSh4RRlmi8wTABJRrVxYpjsheiT2R9vgrNuiVOlMQH38-rAYtPylChy5raQFtMnseyFJMVaPuALQMsRwGF-hTiDfZ4NqDxJdisA-RvEBDrPIBFACoA1ADgAnOkntqACIAxACAAahMwB1AFwB8ZroBUeHZBUEACBu2vYB1UO-wrgEChmaHUFeoPbBayMFxlKFxVeqkGt8Ku8sT0TeZJhifAAQBqCrieIBGAHcTk9BoBGcdoAniSIBKnkAA).

<details>
<summary>Quick line-by-line summary</summary>
If you're short on time and just want a very high level summary, here's a comprehensive list, grouped by type.

**Highlights:**
- 9.12 KB to 7.23 KB, or a little over 20% smaller.
- Memory overhead reduced by as much as 35% in Chromium (20% in Firefox) compared to v2.
- A base of ES2018 is assumed, including syntax.
- IE compatibility is no more, and most IE hacks have been removed.
- No more magic attributes to fuss with!

**Additions:**
- New vnode: `m.layout((dom) => ...)`, scheduled to be invoked after render
- New vnode: `m.remove((dom) => ...)`, scheduled to be invoked after the render in which it's removed from
- New vnode: `m.retain()`, retains the current vnode at that given position
- New vnode: `m.set(contextKeys, ...children)`, sets context keys you can get via the third parameter in components
- New vnode: `m.use([...deps], ...children)`, works similar to React's `useEffect`
- New vnode: `m.init(async (signal) => ...)`, callback return works just like event listeners
- New utility: `tracked = m.tracked()` to manage delayed removal
- New utility: `m.throttler()`
- New utility: `m.debouncer()`

**Changes:**
- Vnode have reduced in size (10 to 6) and gained much shorter property names (to reduce code size).
- `key:` attribute &rarr; `m.keyed(view, (item) => [key, vnode])`
- `m.buildPathname(template, query)` &rarr; `m.p(template, query)`
- `m.buildQueryString(query)` &rarr; `m.query(query)`
- In event listeners, return `false` to prevent redraws.
- Event listeners can return promises that are awaited before redrawing. Whatever it resolves to is taken as the return value.
- If setting an attribute throws, the error is caught and logged unless `removeOnThrow: false` is passed to `m.render`.
- If rendering a view throws, the view is removed and the error is caught and logged unless `removeOnThrow: false` is passed to `m.render`.
- `m.route(elem, defaultRoute, {...routes})` -> `m.route(prefix, view)`
- `m.mount(...)` now returns a `redraw` function that works like `m.redraw`, but only for that one root. `redraw` is also set in the context via the `redraw` key.
- `m.render(...)` now accepts an options object for its third parameter. `redraw` sets the redraw function (and is made available in the context).
- Components are now either `(attrs, old, context) => vnode` functions or an `(attrs, null, context) => ...` function returning that
- `m.request(url, opts)` &rarr; `m.fetch(url, opts)`, accepts all `window.fetch` options, `onprogress`, `extract`, and `responseType`.

**Removals:**
- All submodules other than `mithril/stream` - the main library no longer needs the DOM to load
- The built-in router no longer does its own route dispatching
- `m.trust` - use `innerHTML` instead
- `m.censor`
- Magic attributes
- `m.vnode(...)` - use `m.normalize` if it's truly necessary
- `m.mount(root, null)` - use `m.render(root, null)` instead
- `m.redraw()` -> either `redraw` function returned from `m.mount` or the `redraw` context key
- `oninit`
- `oncreate`/`onupdate` - use `m.layout(...)` instead
- `onremove` - use `m.remove(...)` instead
- `onbeforeupdate` - use `m.retain()` instead
- `onbeforeremove` - use `m.tracked()` utility to manage parents instead
- `m.parsePathname`
- `m.parseQueryString`
- `ev.redraw = false` - return/resolve with `false` or reject/throw from event handlers
- Support for symbols in `style` attribute objects - those now throw. (This won't likely impact many.)

**Miscellaneous:**
- Optimized `mithril/stream` to require a lot less allocation - I don't have precise numbers, but it should both be faster and require less memory.
- Redid the benchmark program.
</details>

### Benchmarks

For the raw benchmark data and specifics on how the memory benchmark was performed, [see this gist](https://gist.github.com/dead-claudia/1ad36ebd98862a0a828fdf21309f7053). I initially posted the full data here, but apparently it's gotten too ~~powerful~~big for GitHub Issues - I got the error message "There was an error posting your comment: Body is too long" when I tried.

#### Memory benchmarks

**v2.2.8:**
- Chromium:
  - `window` final retained size: 1001416 bytes
  - Vnode root final retained size: 188020 bytes
  - Average retained size per item: 7211.0 bytes
- Gecko:
  - GC root final retained size: 4184729 bytes
  - Vnode root final retained size: 388088 bytes
  - Average retained size per item: 38398 bytes

**This PR:**
- Chromium:
  - `window` final retained size: 862976 bytes
  - Vnode root final retained size: 115996 bytes
  - Average retained size per item: 5812.6 bytes
- Gecko:
  - GC root final retained size: 4004569 bytes
  - Vnode root final retained size: 310128 bytes
  - Average retained size per item: 36576 bytes

**Raw DOM:**
- Chromium:
  - `window` final retained size: 611780 bytes
  - Average retained size per item: 3275.3 bytes
- Gecko:
  - GC root final retained size: 3394065 bytes
  - Average retained size per item: 30412 bytes

**Raw empty:**
- Chromium:
  - `window` size: 287292 bytes
- Gecko:
  - GC root size: 383289 bytes

#### CPU benchmarks

> Notes:
> - I show both estimated median ("Med.") and 99th percentile ("P99") since those are what best predict end user experience.
> - "v2" refers to v2.2.9, while "v3" refers to the code in this PR.

**Chromium (Blink):**

| Benchmark                                | Med. v2 | Med. v3 | Change | P99 v2  | P99 v3  | Change |
| :--------------------------------------- | :-----: | :-----: | :----: | :-----: | :-----: | :----: |
| do nothing                               | 4997551 | 4659861 |        | 2120021 | 2033344 |        |
| route match                              | 3614782 |  580969 | -83.9% | 1468955 |  261742 | -82.2% |
| route non-match                          | 3713216 | 2602891 | -29.9% | 1513114 | 1134868 | -25.0% |
| path generate with string interpolations |  618107 |  938630 | +51.9% |  257342 |  448619 | +74.3% |
| path generate with number interpolations |  627418 | 1050786 | +67.5% |  259070 |  457516 | +76.6% |
| path generate no interpolations          | 3733366 | 2063431 | -44.7% | 1545921 |  964335 | -37.6% |
| construct `simpleTree`                   |  36281  |  55630  | +53.3% |  14875  |  25021  | +68.2% |
| construct `nestedTree`                   | 4399797 | 3791234 | -13.8% | 1843460 | 1790158 | -2.89% |
| construct `mutateStylesPropertiesTree`   |   1307  |   2187  | +67.3% |   539   |   1115  |  +107% |
| construct `repeatedTree`                 | 4470342 | 3824937 | -14.4% | 1837281 | 1802728 | -1.88% |
| construct `shuffledKeyedTree`            |   2294  |   5754  |  +151% |   993   |   2772  |  +179% |
| render `simpleTree`                      |  11453  |  12179  | +6.34% |   4792  |   4744  | -1.00% |
| render `nestedTree`                      |   9837  |  10939  | +11.2% |   3900  |   4958  | +27.1% |
| render `mutateStylesPropertiesTree`      |   76.4  |   101   | +31.7% |   45.4  |   53.0  | +16.7% |
| render `repeatedTree`                    |  76066  |  46428  | -39.0% |  38602  |  20138  | -47.8% |
| render `shuffledKeyedTree`               |   684   |   727   | +6.22% |   108   |   76.0  | -29.6% |
| add/remove `simpleTree`                  |   1650  |   901   | -45.4% |   613   |   313   | -49.0% |
| add/remove `nestedTree`                  |   1567  |   906   | -42.2% |   553   |   329   | -40.4% |
| add/remove `mutateStylesPropertiesTree`  |   108   |   99.2  | -8.49% |   61.0  |   53.0  | -13.1% |
| add/remove `repeatedTree`                |   6005  |   3975  | -33.8% |   2177  |   1053  | -51.6% |
| add/remove `shuffledKeyedTree`           |   594   |   567   | -4.58% |   264   |   261   | -1.06% |
| mount `simpleTree`                       |   1382  |   994   | -28.0% |   529   |   363   | -31.4% |
| mount all                                |   47.8  |   47.0  | -1.67% |   29.2  |   28.2  | -3.42% |
| redraw `simpleTree`                      |  11006  |  11959  | +8.66% |   4565  |   5164  | +13.1% |

**Firefox (Gecko):**

| Benchmark                                | Med. v2  | Med. v3  | Change | P99 v2  | P99 v3  | Change |
| :--------------------------------------- | :------: | :------: | :----: | :-----: | :-----: | :----: |
| do nothing                               | 14823314 | 14375924 |        | 5925703 | 6371058 |        |
| route match                              |  8043812 |  1232765 | -84.7% | 3522805 |  526285 | -85.1% |
| route non-match                          |  8043243 |  4615883 | -42.6% | 3475679 | 2173199 | -37.5% |
| path generate with string interpolations |  627252  |  2137280 |  +241% |  138999 |  897648 |  +546% |
| path generate with number interpolations |  632250  |  2135230 |  +238% |  130060 |  889377 |  +584% |
| path generate no interpolations          |  8434450 |  4320984 | -48.8% | 3731146 | 1700677 | -54.4% |
| construct `simpleTree`                   |   29233  |   47591  | +62.8% |  12956  |  19637  | +51.6% |
| construct `nestedTree`                   |  9499372 | 10018884 | +5.47% | 5250779 | 4386436 | -16.5% |
| construct `mutateStylesPropertiesTree`   |   1969   |   2383   | +21.0% |   811   |   753   | -7.15% |
| construct `repeatedTree`                 |  9270115 |  9779863 | +5.50% | 4198525 | 4489073 | +6.92% |
| construct `shuffledKeyedTree`            |   6065   |   3755   | -38.1% |   2358  |   1675  | -29.0% |
| render `simpleTree`                      |   11100  |   10263  | -7.54% |   6174  |   6129  | -0.72% |
| render `nestedTree`                      |   9619   |   9585   | -0.35% |   5484  |   5723  | +4.36% |
| render `mutateStylesPropertiesTree`      |   74.0   |   80.0   | +8.11% |   25.6  |   36.2  | +41.4% |
| render `repeatedTree`                    |   59826  |   53520  | -10.5% |  27791  |  23875  | -14.1% |
| render `shuffledKeyedTree`               |    266   |    221   | -17.0% |   89.4  |   74.6  | -16.6% |
| add/remove `simpleTree`                  |   1567   |   1065   | -32.0% |   480   |   482   | +0.33% |
| add/remove `nestedTree`                  |   1557   |   1084   | -30.4% |   437   |   382   | -12.7% |
| add/remove `mutateStylesPropertiesTree`  |   77.8   |   76.6   | -1.52% |   36.8  |   31.1  | -15.6% |
| add/remove `repeatedTree`                |   11523  |   8843   | -23.3% |   4135  |   4206  | +1.71% |
| add/remove `shuffledKeyedTree`           |    332   |    301   | -9.34% |   132   |   139   | +5.15% |
| mount simpleTree                         |   1222   |    819   | -33.0% |   240   |   320   | +33.3% |
| mount all                                |   37.0   |   31.0   | -16.2% |   21.8  |   17.2  | -21.1% |
| redraw simpleTree                        |   10148  |   10376  | +2.25% |   5475  |   6912  | +26.3% |

## Motivation and Context
<!--- Why is this change required? What problem does it solve? -->
<!--- If it fixes an open issue, please link to the issue here. -->

This resolves a number of ergonomic issues around the API, crossing out many long-standing feature requests and eliminating a number of gotchas.

<details>
<summary>Related issues</summary>
- Fixes https://github.com/MithrilJS/mithril.js/issues/1937 by enabling it to be done in userland, mostly via `m.render(elem, vnode, {removeOnThrow: true})`
- Resolves https://github.com/MithrilJS/mithril.js/issues/2310 by dropping `m.trust`
- Resolves https://github.com/MithrilJS/mithril.js/issues/2505 by not resolving routes
- Resolves https://github.com/MithrilJS/mithril.js/issues/2531 by not resolving routes
- Fixes https://github.com/MithrilJS/mithril.js/issues/2555
- Resolves https://github.com/MithrilJS/mithril.js/issues/2592 by dropping `onbeforeremove`
- Fixes https://github.com/MithrilJS/mithril.js/issues/2621 by making each mount independent of other mount points
- Fixes https://github.com/MithrilJS/mithril.js/issues/2645
- Fixes https://github.com/MithrilJS/mithril.js/issues/2778
- Fixes https://github.com/MithrilJS/mithril.js/issues/2794 by dropping internal `ospec`
- Fixes https://github.com/MithrilJS/mithril.js/issues/2799
- Resolves https://github.com/MithrilJS/mithril.js/issues/2802 by dropping `m.request`
</details>

<details>
<summary>Related discussions</summary>
- Resolves https://github.com/MithrilJS/mithril.js/discussions/2754
- Resolves https://github.com/MithrilJS/mithril.js/discussions/2775 by not resolving routes
- Implements https://github.com/MithrilJS/mithril.js/discussions/2912
- Implements https://github.com/MithrilJS/mithril.js/discussions/2915 by throwing
- Resolves https://github.com/MithrilJS/mithril.js/discussions/2916 by dropping `m.request`
- Implements https://github.com/MithrilJS/mithril.js/discussions/2917 with some minor changes
- Implements https://github.com/MithrilJS/mithril.js/discussions/2918
- Implements https://github.com/MithrilJS/mithril.js/discussions/2919
- Implements https://github.com/MithrilJS/mithril.js/discussions/2920
- Resolves https://github.com/MithrilJS/mithril.js/discussions/2922 by dropping `m.request`
- Resolves https://github.com/MithrilJS/mithril.js/discussions/2924 by dropping `m.request`
- Implements https://github.com/MithrilJS/mithril.js/discussions/2925
- Resolves https://github.com/MithrilJS/mithril.js/discussions/2926 by dropping `m.request`
- Resolves https://github.com/MithrilJS/mithril.js/discussions/2929 by not doing it (doesn't fit with the model)
- Resolves https://github.com/MithrilJS/mithril.js/discussions/2931 by not resolving routes
- Resolves https://github.com/MithrilJS/mithril.js/discussions/2934 by dropping `m.request`
- Resolves https://github.com/MithrilJS/mithril.js/discussions/2935 by not resolving routes
- Partially implements https://github.com/MithrilJS/mithril.js/discussions/2936
- Partially implements https://github.com/MithrilJS/mithril.js/discussions/2937, intentionally skips rest
- Resolves https://github.com/MithrilJS/mithril.js/discussions/2941 by not resolving routes
- Implements https://github.com/MithrilJS/mithril.js/discussions/2942 by offering a configurable `route` context key
- Implements https://github.com/MithrilJS/mithril.js/discussions/2943
- Implements https://github.com/MithrilJS/mithril.js/discussions/2945
- Resolves https://github.com/MithrilJS/mithril.js/discussions/2946 by making the router a component instead (thus making it implicit)
- Implements https://github.com/MithrilJS/mithril.js/discussions/2948 by throwing
- Resolves https://github.com/MithrilJS/mithril.js/discussions/2950 by dropping `m.request`
</details>

<details>
<summary>Things this does *not* resolve</summary>
- https://github.com/MithrilJS/mithril.js/issues/2256 (This needs some further digging to lock down precisely what needs done)
- https://github.com/MithrilJS/mithril.js/issues/2315
- https://github.com/MithrilJS/mithril.js/issues/2359
- https://github.com/MithrilJS/mithril.js/issues/2612
- https://github.com/MithrilJS/mithril.js/issues/2623
- https://github.com/MithrilJS/mithril.js/issues/2643
- https://github.com/MithrilJS/mithril.js/issues/2809
- https://github.com/MithrilJS/mithril.js/issues/2886
</details>

## New API

This is all in the style of https://mithril.js.org/api.html. I also include comparisons to v2. Collapsed so you can skip past it without scrolling for days.

<details>
<summary>New API overview</summary>

### Vnodes

Vnodes have changed under the hood massively. Now, everything is packed into a much smaller object (10 to 6) when normalized. This means that in large apps, you can get away with way more components before you see perf issues. (Significantly reducing memory overhead is a partial goal of this change.)

Each type below also contains a quick explainer of the underlying normalized vnode object representing them. If a field isn't documented below, it's either not used or an implementation detail.

> Note that `vnode.m & m.TYPE_MASK` is using the bitwise AND operator to select only the low 4 bits of the `vnode.m` field of the normalized vnode. `vnode.m` is also guaranteed to be non-negative except for `m.retain()`, in which the whole field is always `-1`. All other bits (from offset 4 to offset 30) are an implementation detail unless stated otherwise. At the time of writing, 9 of the remaining 27 bits are currently in use.
>
> Note that once Mithril receives a vnode, the vnode could get modified.

#### `onbeforeupdate` &rarr; `m.retain()`

Return `m.retain()` if you want to retain the previous vnode. Also, components always receive the previous attributes via their second argument (`null` on first render).

Here's an overoptimized, overabstracted counter to show the difference:

This PR:

```javascript
function CounterDisplay(attrs, old) {
	if (old && attrs.current === old.current) {
		return m.retain()
	}

	return m("div.counter", [
		m("button.counter-increment", {onclick: attrs.onincrement}, "ðŸ”¼"),
		m("div.counter-value", attrs.current),
		m("button.counter-decrement", {onclick: attrs.ondecrement}, "ðŸ”½"),
	])
}

function Counter() {
	let count = 0
	return () => m(CounterDisplay, {
		current: count,
		onincrement() { count++ },
		ondecrement() { count++ },
	})
}
```

v2:

```javascript
const CounterDisplay = {
	onbeforeupdate: (vnode, old) => vnode.attrs.count !== old.attrs.count,
	view: ({attrs}) => m("div.counter", [
		m("button.counter-increment", {onclick: attrs.onincrement}, "ðŸ”¼"),
		m("div.counter-value", attrs.current),
		m("button.counter-decrement", {onclick: attrs.ondecrement}, "ðŸ”½"),
	]),
}

function Counter() {
	let count = 0
	return {
		view: () => m(CounterDisplay, {
			current: count,
			onincrement() { count++ },
			ondecrement() { count++ },
		}),
	}
}
```

**Normalized vnode fields:**

- `vnode.m` is specially set to -1.
- On render, this vnode becomes a clone of whatever vnode it's retaining, provided it's not a hole (boolean, `null`, or `undefined`). For instance, if the vnode it was retaining is an `m("div")`, it gets its `vnode.d` field set to the rendered DOM element.

#### `oncreate`/`onupdate`/`onremove` &rarr; `m.layout`/`m.remove`

DOM-related lifecycle methods have been moved to vnodes. Here's an example using [the FullCalendar Bootstrap 4 plugin](https://www.npmjs.com/package/@fullcalendar/bootstrap) (an old version of this is currently used in the docs), show the difference:

> In both, it uses the same setup usage as is currently shown [in the README on npm](https://www.npmjs.com/package/@fullcalendar/bootstrap). It then wraps it the same way Mithril's docs currently wrap it.

This PR, option 1: nest the `m.layout` and `m.remove`

```javascript
import { Calendar } from "@fullcalendar/core"
import bootstrapPlugin from "@fullcalendar/bootstrap"
import dayGridPlugin from "@fullcalendar/daygrid"

function FullCalendar(attrs) {
	let calendar

	return () => m("div", [
		m.layout((elem) => {
			if (calendar == null) {
				calendar = new Calendar(elem, {
					plugins: [
						bootstrapPlugin,
						dayGridPlugin,
					],
					themeSystem: "bootstrap",
					initialView: "dayGridMonth"
				})
				attrs.onready(calendar)
			}

			calendar.render()
		}),

		m.remove(() => calendar.destroy()),
	])
}

function Demo() {
	let calendar

	return () => [
		m("h1", "Calendar"),
		m(FullCalendar, {onready(c) { calendar = c }}),
		m("button", {onclick() { calendar.prev() }}, "Mithril.js Button -"),
		m("button", {onclick() { calendar.next() }}, "Mithril.js Button +"),
	]
}

m.mount(document.body, () => m(Demo))
```

This PR, option 2: use `vnode.d` to get the element

```javascript
import { Calendar } from "@fullcalendar/core"
import bootstrapPlugin from "@fullcalendar/bootstrap"
import dayGridPlugin from "@fullcalendar/daygrid"

function FullCalendar(attrs) {
	let calendar
	let div

	return () => [
		div = m("div"),

		m.layout(() => {
			if (calendar == null) {
				calendar = new Calendar(div.d, {
					plugins: [
						bootstrapPlugin,
						dayGridPlugin,
					],
					themeSystem: "bootstrap",
					initialView: "dayGridMonth"
				})
				attrs.onready(calendar)
			}

			calendar.render()
		}),

		m.remove(() => calendar.destroy()),
	]
}

function Demo() {
	let calendar

	return () => [
		m("h1", "Calendar"),
		m(FullCalendar, {onready(c) { calendar = c }}),
		m("button", {onclick() { calendar.prev() }}, "Mithril.js Button -"),
		m("button", {onclick() { calendar.next() }}, "Mithril.js Button +"),
	]
}

m.mount(document.body, () => m(Demo))
```

v2:

```javascript
import { Calendar } from "@fullcalendar/core"
import bootstrapPlugin from "@fullcalendar/bootstrap"
import dayGridPlugin from "@fullcalendar/daygrid"

function FullCalendar() {
	let calendar

	return {
		view: () => m("div"),
		oncreate(vnode) {
			calendar = new Calendar(vnode.dom, {
				plugins: [
					bootstrapPlugin,
					dayGridPlugin,
				],
				themeSystem: "bootstrap",
				initialView: "dayGridMonth"
			})
			vnode.attrs.onready(calendar)
			calendar.render()
		},
		onupdate: () => calendar.render(),
		onremove: () => calendar.destroy(),
	}
}

function Demo() {
	let calendar

	return {
		view: () => [
			m("h1", "Calendar"),
			m(FullCalendar, {onready(c) { calendar = c }}),
			m("button", {onclick() { calendar.prev() }}, "Mithril.js Button -"),
			m("button", {onclick() { calendar.next() }}, "Mithril.js Button +"),
		],
	}
}

m.mount(document.body, Demo)
```

**Normalized vnode fields:**

- `vnode.m & m.TYPE_MASK` is `m.TYPE_LAYOUT` for `m.layout(...)`, `m.TYPE_REMOVE` for `m.remove(...)`.
- `vnode.a` holds the callback for both types.

#### `m(selector, attrs, children)`, JSX `<selector {...attrs}>{children}</selector>`

Same as before, but with a few important differences:

- No magic lifecycle methods. Use relevant vnodes as needed. (For similar reasons, `m.censor` is removed.)
- Event handlers await their callbacks before deciding whether to redraw, and they use `return false` to prevent redraw rather than to "capture" the event (use `m.capture(ev)` for that).
- The element's identity is no longer the tag name, but the whole selector. If that changes, the element is replaced, even if the two selectors share a tag name.

This PR:

```javascript
// Simple case
m("div.class#id", {title: "title"}, ["children"])

// Simple events
m("div", {
	onclick(e) {
		console.log(e)
	},
})

// Prevent redraw
m("div", {
	onclick(e) {
		return false
	},
})

// Redraw after doing something async
m("button.save", {
	async onclick(e) {
		m.capture(e)
		try {
			await m.fetch(m.p("/save/:id", {id: attrs.id}), {
				body: JSON.stringify({value: ev.target.value}),
			})
		} catch (e) {
			error = e.message
		}
	},
}, "Save")
```

v2:

```javascript
// Simple case
m("div.class#id", {title: "title"}, ["children"])

// Simple events
m("div", {
	onclick(e) {
		console.log(e)
	},
})

// Prevent redraw
m("div", {
	onclick(e) {
		e.redraw = false
	},
})

// Redraw after doing something async
m("button.save", {
	async onclick(e) {
		e.redraw = false
		e.preventDefault()
		e.stopPropagation()
		try {
			await m.request("/save/:id", {
				params: {id: attrs.id},
				body: JSON.stringify({value: ev.target.value}),
			})
		} catch (e) {
			error = e.message
		}
		m.redraw()
	},
}, "Save")
```

**Normalized vnode fields:**

- `vnode.m & m.TYPE_MASK` is `m.TYPE_ELEMENT`.
- `vnode.t` holds the selector, `"div.class#id"` in this case.
- `vnode.a` holds the attributes. Note that if both the selector and attributes have a `class`/`className` attribute, they're now normalized to `class`, not `className`.
- `vnode.c` holds the (normalized) children.
- `vnode.d` holds the DOM element, once rendered.

#### `m(Component, attrs, children)`, JSX `<Component {...attrs}>{children}</Component>`

Usage is the same as before, but with one difference: no magic lifecycle methods. You'll need to use special attributes to expose inner DOM nodes, lifecycle, and state, and you'll need to use lifecycle vnodes outside the component for everything else. (For similar reasons, `m.censor` is removed.)

The component *definition* differs a lot, though, and that'll be covered later.

> Note: be careful with `attrs.children` - that takes precedence over children arguments in both `m(Component)` and `m(".selector")` vnodes, and so you may have to extract it as done below.

This PR:

```javascript
function Greeter({...attrs, children}) {
	return m("div", attrs, ["Hello ", children])
}

// consume it
m(Greeter, {style: "color: red;"}, "world")

// renders to this HTML:
// <div style="color: red;">Hello world</div>
```

v2:

```javascript
// define a component
const Greeter = {
	view(vnode) {
		return m("div", vnode.attrs, ["Hello ", vnode.children])
	},
}

// consume it
m(Greeter, {style: "color: red;"}, "world")

// renders to this HTML:
// <div style="color: red;">Hello world</div>
```

**Normalized vnode fields:**

- `vnode.m & m.TYPE_MASK` is `m.TYPE_COMPONENT`.
- `vnode.t` holds the component, `Greeter` in this case.
- `vnode.a` holds the attributes. Any children passed in are merged in as `{...attrs, children}`, but they are not normalized.
- `vnode.c` holds the instance vnode, once rendered.

#### Holes: `null`, `undefined`, `false`, and `true`

Holes work exactly the same as before, with all the same rules. And like before, they're normalized to `null`.

#### `"text"`

Text vnodes work exactly the same as before, with all the same rules. Anything neither a hole, a fragment array, nor a normalized vnode is stringified. Symbols can even be stringified like before.

**Normalized vnode fields:**

- `vnode.m & m.TYPE_MASK` is `m.TYPE_TEXT`.
- `vnode.a` holds the (stringified) text.

#### `[...children]`, `m(m.Fragment, ...children)`, JSX `<>{children}</>`

Unkeyed fragments work the same as before, but with three differences:

- If you truly want or need a pre-normalized vnode, you were probably using `m.fragment(...)`. Use `m.normalize([...])` or `m(m.Fragment, ...)` instead - there's no longer a dedicated normalized fragment vnode factory.
- `m.Fragment` actually *looks* like a component, rather than looking like an element selector (and being faked as a component in TypeScript types).
- Fragments can't have lifecycle methods, not even through `m(m.Fragment, ...)`.

Skipping examples, since it's the same across both aside from the above.

**Normalized vnode fields:**

- `vnode.m & m.TYPE_MASK` is `m.TYPE_FRAGMENT`.
- `vnode.c` holds the (normalized) children.

#### `m.keyed(list, view)`, `m.keyed([...entries])`

Keyed fragments have changed. Instead of returning an array of vnodes with `key` properties, you use `m.keyed(...)`. In this new model, keys are more implicit, and while there's a few more brackets and parentheses, it's a bit easier to follow due to the added context of "this is a keyed list, not a normal one" given by the `m.keyed` call.

This PR:

```javascript
const colors = ["red", "yellow", "blue", "gray"]
let counter = 0

function getColor() {
	const color = colors[counter]
	counter = (counter + 1) % colors.length
	return color
}

function Boxes() {
	const boxes = new Map()
	let nextKey = 0

	function add() {
		boxes.set(nextKey++, getColor())
	}

	function remove(key) {
		boxes.delete(key)
	}

	return () => [
		m("button", {onclick: add}, "Add box, click box to remove"),
		m(".container", m.keyed(boxes, ([key, box]) => [
			key,
			m(".box",
				{
					"data-color": box.color,
					onclick() { remove(key) },
				},
				m(".stretch")
			)
		])),
	]
}
```

v2:

```javascript
const colors = ["red", "yellow", "blue", "gray"]
let counter = 0

function getColor() {
	const color = colors[counter]
	counter = (counter + 1) % colors.length
	return color
}

function Boxes() {
	const boxes = new Map()
	let nextKey = 0

	function add() {
		boxes.set(nextKey++, getColor())
	}

	function remove(key) {
		boxes.delete(key)
	}

	return {
		view: () => [
			m("button", {onclick: add}, "Add box, click box to remove"),
			m(".container", Array.from(boxes, ([key, box]) => (
				m(".box",
					{
						key,
						"data-color": box.color,
						onclick() { remove(key) },
					},
					m(".stretch")
				)
			))),
		],
	}
}
```

**Normalized vnode fields:**

- `vnode.m & m.TYPE_MASK` is `m.TYPE_KEYED`.
- `vnode.c` holds the key to (normalized) child map.

#### `m.use([...deps], ...children)`

For cases where you want to reset something based on state, this makes that way easier for you, and it's much more explicit than a single-item keyed list. (In fact, it was such a common question during v0.2 and v1 days that we *had* to eventually document it.) This new factory provides a better story, one that should also hopefully facilitate hooks-like use cases as well.

This PR:

```javascript
m.mount(rootElem, function() {
	let match

	if (m.match(this.route, "/")) {
		return m(Home)
	}

	if (match = m.match(this.route, "/person/:id")) {
		return m(Layout, m.use([match.id], m(Person, {id: match.id})))
	}

	m.route.set("/")
})
```

v2:

```javascript
m.route(rootElem, "/", {
	"/": Home,
	"/person/:id": {
		render: ({attrs}) => m(Layout, [m(Person, {id: attrs.id, key: attrs.id})]),
	},
	// ...
})
```

**Normalized vnode fields:**

- `vnode.m & m.TYPE_MASK` is `m.TYPE_USE`.
- `vnode.a` holds the collected dependency array (`deps` can be any iterable, not just an array).
- `vnode.c` holds the (normalized) children.

#### `m.set({key: value, ...}, ...children)`

This type is entirely new, without a v2 equivalent. You've probably noticed a bunch of `this.route` and `this.redraw()` spattered everywhere. Well, `this.redraw()` is provided implicitly by the runtime, but the new `m.route(...)` directly uses `m.set({route}, view())` internally.

**Normalized vnode fields:**

- `vnode.m & m.TYPE_MASK` is `m.TYPE_USE`.
- `vnode.a` holds the collected dependency array (`deps` can be any iterable, not just an array).
- `vnode.c` holds the (normalized) children.

#### `m.inline(view)`

This type is entirely new, without a v2 equivalent. It's equivalent to the following component, but is optimized for internally (and is its own vnode type).

```javascript
function Inline({view}) {
	// Call with the context as both `this` and the first argument. Doing it this way reduces how
	// many arrow functions you need, and it also provides an easier way to read context state.
	return view.call(this, this)
}

m.inline = (view) => m(Inline, {view})
```

It's used internally by the new `m.route(prefix, view)`. See that helper for more details on how this plays out in practice.

**Normalized vnode fields:**

- `vnode.m & m.TYPE_MASK` is `m.TYPE_INLINE`.
- `vnode.a` holds the view function.
- `vnode.c` holds the instance vnode, once rendered.

### `m.mount(element, component)` &rarr; `m.mount(element, view)`

This PR:

```javascript
const state = {
	count: 0,
	inc() { state.count++ },
}

function Counter() {
	return m("div", {onclick: state.inc}, state.count)
}

m.mount(document.body, () => m(Counter))
```

v2:

```javascript
const state = {
	count: 0,
	inc() { state.count++ },
}

const Counter = {
	view: () => m("div", {onclick: state.inc}, state.count)
}

m.mount(document.body, Counter)
```

### `m.redraw()` &rarr; `context.redraw()`

This PR, option 1: use from a component

> This way makes for easier local cleanup.

```javascript
function Counter() {
	let count = 0
	const timer = setInterval(() => {
		count++
		this.redraw()
	}, 1000)
	return () => [
		m("div", count),
		m.remove(() => clearInterval(timer))
	]
}

m.mount(document.body, () => m(Counter))
```

This PR, option 2: use from a mount view callback

```javascript
let count = 0

m.mount(document.body, function (isInit) {
	if (isInit) {
		setInterval(() => {
			count++
			this.redraw()
		}, 1000)
	}
	return m("div", count)
})
```

v2:

```javascript
function Counter() {
	let count = 0
	const timer = setInterval(() => {
		count++
		m.redraw()
	}, 1000)
	return {
		onremove: () => clearInterval(timer),
		view: () => m("div", count),
	}
}

m.mount(document.body, Counter)
```

### Routing: `m.route(root, defaultRoute, {...routes})` &rarr; `m.route(prefix, view)`

It's more verbose, but there are unique benefits to doing it this way.

- Adding and tweaking routes requires not any more code movement than a magic object. If you want to regain that, you can still do it with a simple wrapper.
- Abstracting routes is as simple as creating a function. The framework doesn't need any special functionality for that.
- Allowing route matching anywhere means you can just as easily do routing only where you need to. You don't need to specially wrap everything just to make it work. (I've partly run into this trap with other routing frameworks.)
- You don't need as much effort to glue together a component and a route that doesn't quite perfectly match what that view component expects. (I've been bit by this many times.)
- If your default route varies based on context, this lets you do that.
- Conditional routes are trivial. Just use `if` statements to guard your routes.

The main goal here is to just get as out of your way as possible. Give you the helpers needed to easily solve it yourself with only basic abstractions, instead of trying to magically solve routing for you and ultimately failing because the abstraction didn't quite work as you needed it to.

> Note that prefixes are now required - there is no longer a default. They help for documentation, so you can just look at the call and know right away what the prefix is.
>
> Also, `m.match`/`route.match` templates are cached just like hyperscript selectors. Updating those too often may result in memory leaks.

This PR, option 1: define using static strings and/or regexps

```javascript
m.mount(document.body, () => m.route("#!", ({route}) => {
	let match

	if (route.path === "/home") {
		return m(Home)
	}

	if (match = /^\/user\/([^/]+)$/.exec(route.path)) {
		return m(ShowUser, {id: decodeURIComponent(match[0])})
	}

	route.set("/home") // navigate to default route
}))
```

This PR, option 2: use `route.match(...)` (equivalent to `m.match(route, path)`) to match route templates

> This method has been benchmarked to oblivion. Hundreds of routes aren't a problem. If anything, they're *less* of a problem now.

```javascript
m.mount(document.body, () => m.route("#!", ({route}) => {
	let match
	if (route.match("/home")) return m(Home)
	if (match = route.match("/user/:id")) return m(ShowUser, {id: match.id})
	route.set("/home") // navigate to default route
}))
```

v2:

```javascript
m.route.prefix = "#!" // Technically redundant as it's the v2 default
m.route(document.body, "/home", {
	"/home": Home,
	"/user/:id": ShowUser,
})
```

Note that while the above uses the first argument, the `view` is actually passed into an `m.inline`, so it receives all the context, not just the `route` key, and it also receives it as both `this` and the first parameter. So this is equivalent to the second option:

```javascript
m.mount(document.body, () => m.route("#!", function () {
	let match

	if (this.route.match("/home")) {
		return m(Home)
	}

	if (match = this.route.match("/user/:id")) {
		return m(ShowUser, {id: match.id})
	}

	// And finally, set your default path here.
	this.route.set("/home")
}))
```

**route.set(path)**

```javascript
route.set("/home")
```

**Current route**

```javascript
// Returns the full current route, including query and hash
const fullCurrentRoute = route.current
// Returns the current path, including query and hash
const currentPath = route.path
// Returns the current query parameters in a `URLSearchParams` instance.
const currentQuery = route.query
```

#### `m(m.route.Link, ...)` &rarr; `m.link(href, opts?)`

This PR:

```javascript
// Simple static routes can just be given directly
m("a", m.link("/home"), "Go to home page")

// If you want parameters, use `m.p`.
m("a", m.link(m.p("/user/:id", {id: user.id})), user.name)

// If you want to replace the URL state on click, you can pass the same options you can pass to
// `route.set(url, opts)`.
m("a.wizard-exit", {ping: m.p("/event", {a: "wizard-exit", s: wizardState})}, [
	m.link("/things/list", {replace: true}),
	"Exit create wizard",
])
```

v2:

```javascript
// Simple static routes can just be given directly
m(m.route.Link, {href: "/home"}, "Go to home page")

// If you want parameters, use `m.p`.
m(m.route.Link, {href: "/user/:id", params: {id: user.id}}, user.name)

// If you want to replace the URL state on click, you can pass the same options you can pass to
// `route.set(url, opts)`.
m(m.route.Link, {
	class: "wizard-exit",
	ping: m.buildPathname("/event", {a: "wizard-exit", s: wizardState}),
	href: "/things/list",
	replace: true,
}, "Exit create wizard")
```

#### What happened to route resolvers?

Instead of accepting components, everything is essentially a `render` function from v2. But for `onmatch`, the only two legitimate uses for it are auth and lazy route loading. There's better ways to handle both:

- For lazy route loading, there's a `Comp = m.lazy({fetch: () => import("./path/to/Comp.js")})` helper.
- For auth, lazily rendering a view is the wrong abstraction. It needs to check for auth from a cached token, prompt on immediate failure, and render the original view on successful auth in either case.
- On the website, it currently mentions data pre-loading as a use case. That shouldn't use `onmatch`. Instead, the view for it should be rendered right away, just with loading placeholders for parts that aren't yet ready to show. Trying to force that into a lazy loading system would just cause blank screen flickering and other stuff that at best doesn't look pretty and at worst causes accessibility issues.

### `m.buildPathname(template, params)` &rarr; `m.p(template, params)`

It's the same API, just with a shorter name as it's expected to be used a lot more. It also has an entirely new implementation that's almost twice as fast when parameters are involved, to match that same expected jump in usage.

> `m.fetch`, `m.link`, and `route.set` expect raw strings and don't accept template parameters, unlike their v2 equivalents.

Here's another example of how it could end up used.

```javascript
// Issues a fetch to `PUT /api/v1/users/1?name=test`
const result = await fetch(m.p("/api/v1/users/:id", {id: 1, name: "test"}), {
	method: "PUT",
})
console.log(result)
```

### `m.buildQueryString(object)` &rarr; `m.query(object)`

Same as before, just with a shorter name to complement `m.p`. It also reuses some of the optimizations created for `m.p`.

```javascript
// "a=1&b=2"
const querystring = m.query({a: "1", b: "2"})
```

### `m.request(url, opts?)` &rarr; `m.fetch(url, opts)`

The new `m.fetch` accepts all the same arguments as `window.fetch`, plus a few other options:

- `opts.responseType`: Selects the type of value to return (default: `"json"`)
  - `"json"`: Parse the result as JSON and return the parsed result
  - `"formdata"`: Parse the result as `multipart/form-data` and return the parsed `FormData` object
  - `"arraybuffer"`: Collect the result into an `ArrayBuffer` object and return it
  - `"blob"`: Collect the result into a `Blob` object and return it
  - `"text"`: Collect the result into a UTF-8 string and return it
  - `"document"`: Parse the result as HTML/XML and return the parsed `Document` object
- `opts.extract`: Instead of using `responseType` to determine how to extract it, you can provide a `(response) => result` message to extract the result. Only called on 2xx and takes precedence over `opts.responseType`.
- `opts.onprogress`: Pass a `(current, total) => ...` function to get called on download progress.

> Unfortunately, upload progress isn't currently monitorable using `fetch`: https://github.com/whatwg/fetch/issues/607. However, this wasn't possible in any previous version of Mithril without using `config(xhr) { xhr.upload.onprogress = ... }` directly in options, so this isn't much of a removal.

`m.fetch` returns a promise that resolves according to `opts.responseType` and `opts.extract` on 2xx, rejects with an error on anything else. Errors returned through rejections have the following properties:

- `message`: The returned UTF-8 text, or the status text if empty. If an error was thrown during the `m.fetch` call, its message is duplicated here instead.
- `status`: The status code, or 0 if it failed before receiving a response.
- `response`: The response from the inner `fetch` call, or `undefined` if the inner `fetch` call itself failed to return a response.
- `cause`: If an error was thrown during the `m.fetch` call, this is set to that error.

### `m.throttler()`

This is a general-purpose bi-edge throttler, with a dynamically configurable limit. It's much better than your typical `throttle(f, ms)` because it lets you easily separate the trigger and reaction using a single shared, encapsulated state object. That same separation is also used to make the rate limit dynamically reconfigurable on hit.

Create as `throttled = m.throttler(ms)` and do `if (await throttled()) return` to rate-limit the code that follows. The result is one of three values, to allow you to identify edges:

- Leading edge: `undefined`
- Trailing edge: `false`, returned only if a second call was made
- No edge: `true`

Call `throttled.update(ms)` to update the interval. This not only impacts future delays, but also any current one.

To dispose, like on component removal, call `throttled.dispose()`.

If you don't sepecify a delay, it defaults to 500ms on creation, which works well enough for most needs. There is no default for `throttled.update(...)` - you must specify one explicitly.

> Important note: due to the way this is implemented in basically all runtimes, the throttler's clock might not tick during sleep, so if you do `await throttled()` and immediately sleep in a low-power state for 5 minutes, you might have to wait another 10 minutes after resuming to a high-power state.

Example usage:

```javascript
function Search() {
	const throttled = m.throttler()
	let results, error
	return () => [
		m.remove(throttled.dispose),
		m("input[type=search]", {
			oninput: async (ev) => {
				// Skip redraw if rate limited - it's pointless
				if (await throttled()) return false
				error = results = null
				this.redraw()
				try {
					results = await m.fetch(m.p("/search", {q: ev.target.value}))
				} catch (e) {
					error = e.message
				}
			},
		}),
		results.map((result) => m(SearchResult, {result})),
		!error || m(ErrorDisplay, {error})),
	]
}
```

Here's the v2 equivalent of the above code, to show how this (and async event listeners) help reduce how much you need to write.

```javascript
function Search() {
	let timer, results, error

	async function doSearch(query) {
		error = results = null
		try {
			results = await m.request("/search", {params: {q: query}})
		} catch (e) {
			error = e.message
		}
		m.redraw()
	}

	return {
		onremove: () => clearTimeout(timer),
		view: () => [
			m("input[type=search]", {
				oninput: (ev) => {
					if (timer) {
						ev.redraw = false // Skip redraw while throttled
					} else {
						timer = setTimeout(() => { timer = null })
						doSearch(ev.target.value)
					}
				},
			}),
			results.map((result) => m(SearchResult, {result})),
			!error || m(ErrorDisplay, {error})),
		],
	}
}
```

### `m.debouncer()`

A general-purpose bi-edge debouncer, with a dynamically configurable limit. It's much better than your typical `debounce(f, ms)` because it lets you easily separate the trigger and reaction using a single shared, encapsulated state object. That same separation is also used to make the rate limit dynamically reconfigurable on hit.

Create as `debounced = m.debouncer(ms)` and do `if (await debounced()) return` to rate-limit the code that follows. The result is one of three values, to allow you to identify edges:

- Leading edge: `undefined`
- Trailing edge: `false`, returned only if a second call was made
- No edge: `true`

Call `debounced.update(ms)` to update the interval. This not only impacts future delays, but also any current one.

To dispose, like on component removal, call `debounced.dispose()`.

If you don't sepecify a delay, it defaults to 500ms on creation, which works well enough for most needs. There is no default for `debounced.update(...)` - you must specify one explicitly.

> Important note: due to the way this is implemented in basically all runtimes, the throttler's clock might not tick during sleep, so if you do `await throttled()` and immediately sleep in a low-power state for 5 minutes, you might have to wait another 10 minutes after resuming to a high-power state.

Example usage:

```js
function SaveButton() {
	const debounced = m.debouncer()
	let results, error
	return (attrs) => [
		m.remove(debounced.dispose),
		m("input[type=text].value", {
			async oninput(ev) {
				// Skip redraw if rate limited - it's pointless
				if ((await debounced()) !== false) return "skip-redraw"
				try {
					await m.fetch(m.p("/save/:id", {id: attrs.id}), {
						body: JSON.stringify({value: ev.target.value}),
					})
				} catch (e) {
					error = e.message
				}
			},
		}),
		results.map((result) => m(SearchResult, {result})),
		!error || m(ErrorDisplay, {error})),
	]
}
```

Here's the v2 equivalent of the above code, to show how this (and async event listeners in general) help reduce how much you need to write.

```javascript
function SaveButton() {
	let timer, results, error

	return {
		onremove: () => clearTimeout(timer),
		view: (vnode) => [
			m("input[type=text].value", {
				oninput(ev) {
					ev.redraw = false // Skip redraw while waiting
					clearTimeout(timer)
					timer = setTimeout(async () => {
						timer = null
						error = results = null
						try {
							results = await m.request("/save/:id", {params: {id: vnode.attrs.id}})
						} catch (e) {
							error = e.message
						}
						m.redraw()
					})
					value = ev.target.value
				},
			}),
			results.map((result) => m(SearchResult, {result})),
			!error || m(ErrorDisplay, {error})),
		],
	}
}
```

### `onbeforeremove` &rarr; `m.tracked(redraw, initial?)`, `m.trackedList(redraw, initial?)`

In v2, for managing animations, you'd do something like this:

```javascript
const Fader = {
	view: (vnode) => Boolean(vnode.attrs.show) && m("div", {
		onbeforeremove: (vnode) => new Promise((resolve) => {
			vnode.dom.addEventListener("transitionend", resolve, {once: true})
			vnode.dom.classList.add("fade-out")
		}),
	}, "Hi"),
}

function AnimatedTodoList() {
	const items = new Map()
	let nextItem = ""
	let id = 0

	return {
		view: () => m(".todo-list", [
			m(".todo-list-add", [
				m("input[type=text].next-item-value", {
					value: nextItem,
					oninput(ev) { nextItem = ev.target.value },
				}),
				m("button.next-item-add", {
					onclick() { items.set(id++, nextItem) },
				}, "Add"),
			]),
			m(".todo-list-items", Array.from(items, ([key, value]) => (
				m(".todo-item", {
					key,
					onbeforeremove: (vnode) => new Promise((resolve) => {
						vnode.dom.ontransitionend = (ev) => {
							resolve()
							return false
						}
						vnode.dom.classList.add("fade-out")
					}),
				}, [
					m(".item-value", value),
					m("button.remove", {
						onclick() {
							items.delete(key)
						},
					}, "Remove"),
				])
			))),
		]),
	}
}
```

In this PR, things are done a bit differently as it's much lower-level: you don't remove right away, but instead you first trigger the animation, and then you remove. Tracking the virtual list needed for this is complicated, but that's where `m.tracked()` and `m.trackedList()` come in to help - those help track it for you. You just need to make sure to render what they say is live in the given moment.

Here's the equivalent for this PR:

```javascript
function Fader() {
	const trackHit = m.tracked(this.redraw)

	return (attrs) => m.keyed(trackHit(attrs.show), (handle) => [
		handle.key,
		m("div", {
			class: handle.signal.aborted && "fade-out",
			ontransitionend: handle.release,
		}, "Hi"),
	])
}

function AnimatedTodoList() {
	const items = m.trackedList(this.redraw)
	let nextItem = ""
	let id = 0

	return () => m(".todo-list", [
		m(".todo-list-add", [
			m("input[type=text].next-item-value", {
				value: nextItem,
				oninput(ev) { nextItem = ev.target.value },
			}),
			m("button.next-item-add", {
				onclick() { items.set(id++, nextItem) },
			}, "Add"),
		]),
		m(".todo-list-items", m.keyed(items.live(), (handle) => [
			handle.key,
			m(".todo-item", {
				class: handle.signal.aborted && "fade-out",
				ontransitionend: handle.release,
			}, [
				m(".item-value", handle.value),
				m("button.remove", {onclick: handle.remove}, "Remove"),
			]),
		])),
	])
}
```

Separating this from the framework also helps bring better structure. For page transitions, you could do something like this:

```javascript
function Page(attrs) {
	return m("div", {
		class: this.pageHandle.signal.aborted && "fade-out",
		ontransitionend: this.pageHandle.release,
	}, [
		attrs.children,
	])
}

const defaultRoute = "/home"
const routes = {
	"/home": () => m(Home),
	"/user/:id": ({id}) => m.m(ShowUser, {id}),
}

function App() {
	const trackHit = m.tracked(this.redraw)

	return () => m.route("#!", ({route}) => {
		const template = Object.keys(routes).some((t) => route.match(t))

		return m.keyed(trackHit(template), (handle) => Boolean(handle.value) && [
			handle.key,
			m.set({pageHandle: handle}, m(Page, routes[handle.value](match)))
		])
	})
}

m.mount(document.body, () => m(App))
```

This replacement also comes with a unique advantage: you get a pre-made signal that you can use to immediately abort stuff like fetches *before* the node is removed.

```js
function ShowUser({id}) {
	let user, error

	queueMicrotask(async () => {
		const response = await fetch(m.p("/api/user/:id", {id}), {signal: this.pageHandle.signal})
		try {
			if (response.ok) {
				user = await response.json()
			} else {
				error = await response.text()
			}
		} catch (e) {
			error = e.message
		}
		this.redraw()
	})

	return () => [
		user != null && m(".user-info", [
			m(".user-name", user),
		]),
		error != null && m(".error", error),
		user == null && error == null && m(".loading"),
	]
}
```

#### `m.tracked()` API

- `tracked = m.tracked(redraw, initial?)`: Create a tracked value. Default initial value is `undefined`, but you should
- `handles = tracked(state)`: Track an incoming state value. Returns a list of handles

#### `m.trackedList()` API

- `tracked = m.trackedList(redraw, initial?)`: Create a tracked value.
- `handles = tracked(state)`: Track an incoming state value. Returns a list of handles

### `oninit` &rarr; `m.init(callback)`

In general, `oninit` is redundant, even in v2. However, `m.init` has some use in it that makes it not entirely redundant.

To take the `ShowUser` example from before:

```javascript
function ShowUser({id}) {
	let user, error

	queueMicrotask(async () => {
		const response = await fetch(m.p("/api/user/:id", {id}), {signal: this.pageHandle.signal})
		try {
			if (response.ok) {
				user = await response.json()
			} else {
				error = await response.text()
			}
		} catch (e) {
			error = e.message
		}
		this.redraw()
	})

	return () => [
		user != null && m(".user-info", [
			m(".user-name", user),
		]),
		error != null && m(".error", error),
		user == null && error == null && m(".loading"),
	]
}
```

Let's assume there wasn't a `this.pageHandle` in the context:

```javascript
function ShowUser({id}) {
	const ctrl = new AbortController()
	let user, error

	queueMicrotask(async () => {
		const response = await fetch(m.p("/api/user/:id", {id}), {signal: ctrl.signal})
		try {
			if (response.ok) {
				user = await response.json()
			} else {
				error = await response.text()
			}
		} catch (e) {
			error = e.message
		}
		this.redraw()
	})

	return () => [
		m.remove(() => ctrl.abort()),
		user != null && m(".user-info", [
			m(".user-name", user),
		]),
		error != null && m(".error", error),
		user == null && error == null && m(".loading"),
	]
}
```

This could save a couple lines by using `m.init`.

```javascript
function ShowUser({id}) {
	let user, error

	return () => [
		m.init(async (signal) => {
			const response = await fetch(m.p("/api/user/:id", {id}), {signal})
			try {
				if (response.ok) {
					user = await response.json()
				} else {
					error = await response.text()
				}
			} catch (e) {
				error = e.message
			}
		}),
		user != null && m(".user-info", [
			m(".user-name", user),
		]),
		error != null && m(".error", error),
		user == null && error == null && m(".loading"),
	]
}
```

The closest v2 equivalent would be this, similar to the above variant without `m.init`:

```javascript
function ShowUser({id}) {
	const ctrl = new AbortController()
	let user, error

	queueMicrotask(async () => {
		const response = await fetch(m.p("/api/user/:id", {id}), {signal: ctrl.signal})
		try {
			if (response.ok) {
				user = await response.json()
			} else {
				error = await response.text()
			}
		} catch (e) {
			error = e.message
		}
		this.redraw()
	})

	return {
		onremove: () => ctrl.abort(),
		view: () => [
			user != null && m(".user-info", [
				m(".user-name", user),
			]),
			error != null && m(".error", error),
			user == null && error == null && m(".loading"),
		],
	}
}
```

It's a bit niche, but it can save code in certain situations. It also has the added benefit of scheduling the block to not block frame rendering. (This was done before with `queueMicrotask`, but common idioms aren't usually aware of that.)

> Note that the similar `Comp = m.lazy({fetch: () => import("./path/to/Comp.js")})` does *not* do similar, but it's also aiming to minimize load delay, letting the initial tree be built during script fetch - there's different perf considerations there.

</details>

## How Has This Been Tested?
<!--- Please describe in detail how you tested your changes. -->
<!--- Include details of your testing environment, and the tests you ran to -->
<!--- see how your change affects other areas of the code, etc. -->
I've written a bunch of new tests, and every current test (to the extent I've kept them) pass. At the time of writing, there's about 219k tests, but all but about 8k of that is for the near exhaustive `m.fetch` tests.

## Types of changes
<!--- What types of changes does your code introduce? Put an `x` in all the boxes that apply: -->
- [x] Bug fix (non-breaking change which fixes an issue)
- [x] New feature (non-breaking change which adds functionality)
- [x] Breaking change (fix or feature that would cause existing functionality to change)

## Checklist
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [x] I have added tests to cover my changes.
- [x] All new and existing tests passed.
- [x] My change requires a documentation update, and I've opened a pull request to update it already: I need to write that first, and that may be a bit.
- [x] I have read https://mithril.js.org/contributing.html.
